var tipuesearch = {"pages":[{"title":" DYNAMICS ","text":"DYNAMICS Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"forced_ode_container – DYNAMICS ","text":"type, public, extends(ode_container) :: forced_ode_container An extension of the ode_container type from the DIFFEQ library\nthat allows for the definition and analysis of forced systems of\nODE's. Contents Variables forcing_function Components Type Visibility Attributes Name Initial procedure( ode_excite ), public, pointer, nopass :: forcing_function A pointer to a routine defining the forcing function.","tags":"","loc":"type\\forced_ode_container.html"},{"title":"frf – DYNAMICS ","text":"type, public :: frf Contents Variables frequency responses Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency complex(kind=real64), public, allocatable, dimension(:,:) :: responses","tags":"","loc":"type\\frf.html"},{"title":"harmonic_ode_container – DYNAMICS ","text":"type, public, extends(ode_container) :: harmonic_ode_container An extension of the ode_container type from the DIFFEQ library\nthat allows for the definition and analysis of systems of ODE's\nexposed to harmonic excitation. Contents Variables excitation_frequency Type-Bound Procedures frequency_sweep Components Type Visibility Attributes Name Initial real(kind=real64), public :: excitation_frequency The excitation frequency. Type-Bound Procedures generic, public :: frequency_sweep => hoc_frf_sweep, hoc_frf_sweep_2 private  function hoc_frf_sweep(sys, freq, iv, solver, ncycles, ntransient, points, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name class( harmonic_ode_container ), intent(inout) :: sys The harmonic_ode_container object containing the equations to \nanalyze.  To properly use this object, extend the \nharmonic_ode_container object and overload the ode routine to \ndefine the ODE's.  Use the excitation_frequency property to\nobtain the desired frequency from the solver. real(kind=real64), intent(in), dimension(:) :: freq An M-element array containing the frequency points at which the \nsolution should be computed.  Notice, whatever units are utilized\nfor this array are also the units of the excitation_frequency\nproperty in @p sys.  It is recommended that the units be set to \nHz.  Additionally, this array cannot contain any zero-valued \nelements as the ODE solution time for each frequency is \ndetermined by the period of oscillation and number of cycles. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses. private  function hoc_frf_sweep_2(sys, nfreq, freq1, freq2, iv, solver, ncycles, ntransient, points, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name class( harmonic_ode_container ), intent(inout) :: sys The harmonic_ode_container object containing the equations to \nanalyze.  To properly use this object, extend the \nharmonic_ode_container object and overload the ode routine to \ndefine the ODE's.  Use the excitation_frequency property to\nobtain the desired frequency from the solver. integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency.  It is recommended that the units be set\nto Hz. real(kind=real64), intent(in) :: freq2 The ending frequency.  It is recommended that the units be set to\nHz. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses.","tags":"","loc":"type\\harmonic_ode_container.html"},{"title":"chirp – DYNAMICS","text":"public pure elemental function chirp(t, amp, span, f1Hz, f2Hz) result(rst) Evaluates a linear chirp function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate the \nchirp. real(kind=real64), intent(in) :: amp The amplitude. real(kind=real64), intent(in) :: span The duration of the time it takes to sweep from the start \nfrequency to the end frequency. real(kind=real64), intent(in) :: f1Hz The lower excitation frequency, in Hz. real(kind=real64), intent(in) :: f2Hz The upper excitation frequency, in Hz. Return Value real(kind=real64) The value of the function at t. Contents","tags":"","loc":"proc\\chirp.html"},{"title":"compute_modal_damping – DYNAMICS","text":"public pure elemental function compute_modal_damping(lambda, alpha, beta) result(rst) Computes the modal damping factors given the\nproportional damping terms and where , , and is the eigenvalue of the system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lambda The square of the modal frequency - the eigen value. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . Return Value real(kind=real64) The modal damping parameter. Contents","tags":"","loc":"proc\\compute_modal_damping.html"},{"title":"rotate_x – DYNAMICS","text":"public pure function rotate_x(angle) result(rst) Constructs the rotation matrix describing a rotation about an\nx-axis such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_x.html"},{"title":"rotate_y – DYNAMICS","text":"public pure function rotate_y(angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_y.html"},{"title":"rotate_z – DYNAMICS","text":"public pure function rotate_z(angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_z.html"},{"title":"modal_response – DYNAMICS","text":"public  subroutine modal_response(mass, stiff, freqs, modeshapes, err) Uses dynamics_error_handling linalg Computes the modal frequencies and modes shapes for \nmulti-degree-of-freedom system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must\nbe symmetric. real(kind=real64), intent(out), allocatable, dimension(:) :: freqs An allocatable N-element array where the modal frequencies will\nbe returned in ascending order with units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional, allocatable N-by-N matrix where the N mode shapes\nfor the system will be returned.  The mode shapes are stored in\ncolumns. class(errors), intent(inout), optional, target :: err Contents","tags":"","loc":"proc\\modal_response.html"},{"title":"normalize_mode_shapes – DYNAMICS","text":"public  subroutine normalize_mode_shapes(x) Normalizes mode shape vectors such that the largest magnitude\nvalue in the vector is one. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: x The matrix of mode shape vectors with one vector per column. Contents","tags":"","loc":"proc\\normalize_mode_shapes.html"},{"title":"frequency_response – DYNAMICS","text":"public interface frequency_response Computes the frequency response functions for a system of ODE's. Contents Module Procedures frf_fft frf_modal_prop_damp frf_modal_prop_damp_2 Module Procedures private  function frf_fft(sys, span, iv, fs, solver, win, err) result(rst) Computes the frequency response of each equation in a system of \nforced differential equations. Arguments Type Intent Optional Attributes Name class( forced_ode_container ), intent(inout) :: sys The forced_ode_container object containing the equations to\nanalyze. real(kind=real64), intent(in) :: span The duration of the time-domain analysis. real(kind=real64), intent(in), dimension(:) :: iv An N-element containing the initial conditions for each of the\nN differential equations being analyzed. real(kind=real64), intent(in), optional :: fs An optional rate at which to sample the differential equation \nsolution.  The default rate is 1024 Hz, assuming that the input\nspan is provided in units of seconds. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. class(window), intent(in), optional, target :: win An optional parameter allowing the differential equation solution\nto be windowed as part of the FFT process used to construct the\nsystem transfer functions.  The default is a Hamming window sized\nto contain the entirety of the solution. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp(mass, stiff, alpha, beta, freq, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . real(kind=real64), intent(in), dimension(:) :: freq An M-element array of frequency values at which to evaluate the\nfrequency response functions. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp_2(mass, stiff, alpha, beta, nfreq, freq1, freq2, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency.  It is recommended that the units be set\nto Hz. real(kind=real64), intent(in) :: freq2 The ending frequency.  It is recommended that the units be set to\nHz. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses.","tags":"","loc":"interface\\frequency_response.html"},{"title":"modal_excite – DYNAMICS","text":"interface public  subroutine modal_excite(freq, frc) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency. complex(kind=real64), intent(out), dimension(:) :: frc An N-element array where the forcing function should be\nwritten. Description Defines the interface to a routine for defining the forcing\nfunction for a modal frequency analysis.","tags":"","loc":"interface\\modal_excite.html"},{"title":"ode_excite – DYNAMICS","text":"interface public  function ode_excite(t) result(rst) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate\nthe excitation function. Return Value real(kind=real64) The result. Description Defines the interface for a ODE excitation function.","tags":"","loc":"interface\\ode_excite.html"},{"title":"report_generic_counting_error – DYNAMICS","text":"public  subroutine report_generic_counting_error(name, str1, val, str2, flag, err) A generic error reporting routine. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: str1 The first string. integer(kind=int32), intent(in) :: val The integer value. character(len=*), intent(in) :: str2 The second string. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=512), public :: errmsg","tags":"","loc":"proc\\report_generic_counting_error.html"},{"title":"report_matrix_size_mismatch_error – DYNAMICS","text":"public  subroutine report_matrix_size_mismatch_error(name, mtx1, mtx2, m1, n1, m2, n2, err) Reports a mismatch in matrix sizes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: mtx1 The name of the first matrix. character(len=*), intent(in) :: mtx2 The name of the second matrix. integer(kind=int32), intent(in) :: m1 The number of rows in the first matrix. integer(kind=int32), intent(in) :: n1 The number of columns in the first matrix. integer(kind=int32), intent(in) :: m2 The number of rows in the second matrix. integer(kind=int32), intent(in) :: n2 The number of columns in the second matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_matrix_size_mismatch_error.html"},{"title":"report_memory_error – DYNAMICS","text":"public  subroutine report_memory_error(name, flag, err) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: flag The flag returned from the allocate statement. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_nonsquare_mass_matrix_error – DYNAMICS","text":"public  subroutine report_nonsquare_mass_matrix_error(name, m, n, err) Reports an error relating to a non-square mass matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the mass matrix. integer(kind=int32), intent(in) :: n The number of columns found in the mass matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonsquare_mass_matrix_error.html"},{"title":"report_nonsquare_stiffness_matrix_error – DYNAMICS","text":"public  subroutine report_nonsquare_stiffness_matrix_error(name, m, n, err) Reports an error relating to a non-square stiffness matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the stiffness matrix. integer(kind=int32), intent(in) :: n The number of columns found in the stiffness matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonsquare_stiffness_matrix_error.html"},{"title":"report_null_forcing_routine_error – DYNAMICS","text":"public  subroutine report_null_forcing_routine_error(name, err) Reports a null forcing routine pointer error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents","tags":"","loc":"proc\\report_null_forcing_routine_error.html"},{"title":"report_zero_difference_error – DYNAMICS","text":"public  subroutine report_zero_difference_error(name, var1, val1, var2, val2, flag, err) Reports a zero-difference between two variables where a non-zero\ndifference was expected. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var1 The name of the first variable. real(kind=real64), intent(in) :: val1 The value of the first variable. character(len=*), intent(in) :: var2 The name of the second variable. real(kind=real64), intent(in) :: val2 The value of the second variable. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_zero_difference_error.html"},{"title":"report_zero_valued_frequency_error – DYNAMICS","text":"public  subroutine report_zero_valued_frequency_error(name, index, err) Reports an error associated with a zero-valued frequency value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: index The array index at which the zero-valued frequency was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_zero_valued_frequency_error.html"},{"title":"dynamics – DYNAMICS","text":"Uses iso_fortran_env diffeq ferror Contents Interfaces frequency_response modal_excite ode_excite Derived Types forced_ode_container frf harmonic_ode_container Functions chirp compute_modal_damping rotate_x rotate_y rotate_z Subroutines modal_response normalize_mode_shapes Interfaces public        interface frequency_response Computes the frequency response functions for a system of ODE's. private  function frf_fft(sys, span, iv, fs, solver, win, err) result(rst) Computes the frequency response of each equation in a system of \nforced differential equations. Arguments Type Intent Optional Attributes Name class( forced_ode_container ), intent(inout) :: sys The forced_ode_container object containing the equations to\nanalyze. real(kind=real64), intent(in) :: span The duration of the time-domain analysis. real(kind=real64), intent(in), dimension(:) :: iv An N-element containing the initial conditions for each of the\nN differential equations being analyzed. real(kind=real64), intent(in), optional :: fs An optional rate at which to sample the differential equation \nsolution.  The default rate is 1024 Hz, assuming that the input\nspan is provided in units of seconds. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. class(window), intent(in), optional, target :: win An optional parameter allowing the differential equation solution\nto be windowed as part of the FFT process used to construct the\nsystem transfer functions.  The default is a Hamming window sized\nto contain the entirety of the solution. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp(mass, stiff, alpha, beta, freq, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . real(kind=real64), intent(in), dimension(:) :: freq An M-element array of frequency values at which to evaluate the\nfrequency response functions. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp_2(mass, stiff, alpha, beta, nfreq, freq1, freq2, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency.  It is recommended that the units be set\nto Hz. real(kind=real64), intent(in) :: freq2 The ending frequency.  It is recommended that the units be set to\nHz. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. interface public  subroutine modal_excite(freq, frc) Defines the interface to a routine for defining the forcing\nfunction for a modal frequency analysis. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency. complex(kind=real64), intent(out), dimension(:) :: frc An N-element array where the forcing function should be\nwritten. interface public  function ode_excite(t) result(rst) Defines the interface for a ODE excitation function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate\nthe excitation function. Return Value real(kind=real64) The result. Derived Types type, public, extends(ode_container) :: forced_ode_container An extension of the ode_container type from the DIFFEQ library\nthat allows for the definition and analysis of forced systems of\nODE's. Components Type Visibility Attributes Name Initial procedure( ode_excite ), public, pointer, nopass :: forcing_function A pointer to a routine defining the forcing function. type, public :: frf Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency complex(kind=real64), public, allocatable, dimension(:,:) :: responses type, public, extends(ode_container) :: harmonic_ode_container An extension of the ode_container type from the DIFFEQ library\nthat allows for the definition and analysis of systems of ODE's\nexposed to harmonic excitation. Components Type Visibility Attributes Name Initial real(kind=real64), public :: excitation_frequency The excitation frequency. Type-Bound Procedures generic,\n                  public\n                  :: frequency_sweep =>\n                    hoc_frf_sweep, hoc_frf_sweep_2 Functions public pure elemental function chirp (t, amp, span, f1Hz, f2Hz) result(rst) Evaluates a linear chirp function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate the \nchirp. real(kind=real64), intent(in) :: amp The amplitude. real(kind=real64), intent(in) :: span The duration of the time it takes to sweep from the start \nfrequency to the end frequency. real(kind=real64), intent(in) :: f1Hz The lower excitation frequency, in Hz. real(kind=real64), intent(in) :: f2Hz The upper excitation frequency, in Hz. Return Value real(kind=real64) The value of the function at t. public pure elemental function compute_modal_damping (lambda, alpha, beta) result(rst) Computes the modal damping factors given the\nproportional damping terms and where , , and is the eigenvalue of the system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lambda The square of the modal frequency - the eigen value. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . Return Value real(kind=real64) The modal damping parameter. public pure function rotate_x (angle) result(rst) Constructs the rotation matrix describing a rotation about an\nx-axis such that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. public pure function rotate_y (angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. public pure function rotate_z (angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Subroutines public  subroutine modal_response (mass, stiff, freqs, modeshapes, err) Computes the modal frequencies and modes shapes for \nmulti-degree-of-freedom system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must\nbe symmetric. real(kind=real64), intent(out), allocatable, dimension(:) :: freqs An allocatable N-element array where the modal frequencies will\nbe returned in ascending order with units of Hz. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional, allocatable N-by-N matrix where the N mode shapes\nfor the system will be returned.  The mode shapes are stored in\ncolumns. class(errors), intent(inout), optional, target :: err public  subroutine normalize_mode_shapes (x) Normalizes mode shape vectors such that the largest magnitude\nvalue in the vector is one. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: x The matrix of mode shape vectors with one vector per column.","tags":"","loc":"module\\dynamics.html"},{"title":"dynamics_error_handling – DYNAMICS","text":"Uses iso_fortran_env diffeq ferror Contents Variables DYN_INVALID_INPUT_ERROR DYN_MATRIX_SIZE_ERROR DYN_MEMORY_ERROR DYN_NULL_POINTER_ERROR DYN_ZERO_VALUED_FREQUENCY_ERROR Subroutines report_generic_counting_error report_matrix_size_mismatch_error report_memory_error report_nonsquare_mass_matrix_error report_nonsquare_stiffness_matrix_error report_null_forcing_routine_error report_zero_difference_error report_zero_valued_frequency_error Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DYN_INVALID_INPUT_ERROR = DIFFEQ_INVALID_INPUT_ERROR Defines an error associated with an invalid input. integer(kind=int32), public, parameter :: DYN_MATRIX_SIZE_ERROR = 100100 Defines an error associated with an incorrectly sized matrix. integer(kind=int32), public, parameter :: DYN_MEMORY_ERROR = DIFFEQ_MEMORY_ALLOCATION_ERROR Defines an error associated with memory allocations. integer(kind=int32), public, parameter :: DYN_NULL_POINTER_ERROR = DIFFEQ_NULL_POINTER_ERROR Defines an error associated with a null pointer. integer(kind=int32), public, parameter :: DYN_ZERO_VALUED_FREQUENCY_ERROR = 100101 Defins an error associated with a zero-valued frequency. Subroutines public  subroutine report_generic_counting_error (name, str1, val, str2, flag, err) A generic error reporting routine. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: str1 The first string. integer(kind=int32), intent(in) :: val The integer value. character(len=*), intent(in) :: str2 The second string. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_matrix_size_mismatch_error (name, mtx1, mtx2, m1, n1, m2, n2, err) Reports a mismatch in matrix sizes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: mtx1 The name of the first matrix. character(len=*), intent(in) :: mtx2 The name of the second matrix. integer(kind=int32), intent(in) :: m1 The number of rows in the first matrix. integer(kind=int32), intent(in) :: n1 The number of columns in the first matrix. integer(kind=int32), intent(in) :: m2 The number of rows in the second matrix. integer(kind=int32), intent(in) :: n2 The number of columns in the second matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_memory_error (name, flag, err) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: flag The flag returned from the allocate statement. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonsquare_mass_matrix_error (name, m, n, err) Reports an error relating to a non-square mass matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the mass matrix. integer(kind=int32), intent(in) :: n The number of columns found in the mass matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonsquare_stiffness_matrix_error (name, m, n, err) Reports an error relating to a non-square stiffness matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the stiffness matrix. integer(kind=int32), intent(in) :: n The number of columns found in the stiffness matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_null_forcing_routine_error (name, err) Reports a null forcing routine pointer error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_zero_difference_error (name, var1, val1, var2, val2, flag, err) Reports a zero-difference between two variables where a non-zero\ndifference was expected. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var1 The name of the first variable. real(kind=real64), intent(in) :: val1 The value of the first variable. character(len=*), intent(in) :: var2 The name of the second variable. real(kind=real64), intent(in) :: val2 The value of the second variable. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_zero_valued_frequency_error (name, index, err) Reports an error associated with a zero-valued frequency value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: index The array index at which the zero-valued frequency was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution.","tags":"","loc":"module\\dynamics_error_handling.html"},{"title":"dynamics.f90 – DYNAMICS","text":"Contents Modules dynamics Source Code dynamics.f90 Source Code module dynamics use iso_fortran_env use ferror use diffeq , only : ode_container , ode_integrator implicit none private public :: ode_excite public :: modal_excite public :: forced_ode_container public :: harmonic_ode_container public :: frf public :: chirp public :: frequency_response public :: compute_modal_damping public :: modal_response public :: normalize_mode_shapes public :: rotate_x public :: rotate_y public :: rotate_z interface function ode_excite ( t ) result ( rst ) !! Defines the interface for a ODE excitation function. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: t !! The value of the independent variable at which to evaluate !! the excitation function. real ( real64 ) :: rst !! The result. end function subroutine modal_excite ( freq , frc ) !! Defines the interface to a routine for defining the forcing !! function for a modal frequency analysis. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: freq !! The excitation frequency. complex ( real64 ), intent ( out ), dimension (:) :: frc !! An N-element array where the forcing function should be !! written. end subroutine end interface type , extends ( ode_container ) :: forced_ode_container !! An extension of the ode_container type from the DIFFEQ library !! that allows for the definition and analysis of forced systems of !! ODE's. procedure ( ode_excite ), pointer , nopass :: forcing_function !! A pointer to a routine defining the forcing function. end type type , extends ( ode_container ) :: harmonic_ode_container !! An extension of the ode_container type from the DIFFEQ library !! that allows for the definition and analysis of systems of ODE's !! exposed to harmonic excitation. real ( real64 ) :: excitation_frequency !! The excitation frequency. contains generic , public :: frequency_sweep => hoc_frf_sweep , hoc_frf_sweep_2 procedure , private :: hoc_frf_sweep procedure , private :: hoc_frf_sweep_2 end type type frf real ( real64 ), allocatable , dimension (:) :: frequency complex ( real64 ), allocatable , dimension (:,:) :: responses end type interface frequency_response !! Computes the frequency response functions for a system of ODE's. module procedure :: frf_fft module procedure :: frf_modal_prop_damp module procedure :: frf_modal_prop_damp_2 end interface contains ! ------------------------------------------------------------------------------ pure elemental function chirp ( t , amp , span , f1Hz , f2Hz ) result ( rst ) !! Evaluates a linear chirp function. real ( real64 ), intent ( in ) :: t !! The value of the independent variable at which to evaluate the !! chirp. real ( real64 ), intent ( in ) :: amp !! The amplitude. real ( real64 ), intent ( in ) :: span !! The duration of the time it takes to sweep from the start !! frequency to the end frequency. real ( real64 ), intent ( in ) :: f1Hz !! The lower excitation frequency, in Hz. real ( real64 ), intent ( in ) :: f2Hz !! The upper excitation frequency, in Hz. real ( real64 ) :: rst !! The value of the function at t. real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) real ( real64 ) :: c c = ( f2Hz - f1Hz ) / span rst = amp * sin ( 2.0d0 * pi * t * ( 0.5d0 * c * t + f1Hz )) end function ! ------------------------------------------------------------------------------ function frf_fft ( sys , span , iv , fs , solver , win , err ) result ( rst ) !! Computes the frequency response of each equation in a system of !! forced differential equations. use spectrum use diffeq , only : dprk45_integrator use dynamics_error_handling class ( forced_ode_container ), intent ( inout ) :: sys !! The forced_ode_container object containing the equations to !! analyze. real ( real64 ), intent ( in ) :: span !! The duration of the time-domain analysis. real ( real64 ), intent ( in ), dimension (:) :: iv !! An N-element containing the initial conditions for each of the !! N differential equations being analyzed. real ( real64 ), intent ( in ), optional :: fs !! An optional rate at which to sample the differential equation !! solution.  The default rate is 1024 Hz, assuming that the input !! span is provided in units of seconds. class ( ode_integrator ), intent ( inout ), optional , target :: solver !! An optional differential equation solver.  The default solver !! is the Dormand-Prince Runge-Kutta integrator from the DIFFEQ !! library. class ( window ), intent ( in ), optional , target :: win !! An optional parameter allowing the differential equation solution !! to be windowed as part of the FFT process used to construct the !! system transfer functions.  The default is a Hamming window sized !! to contain the entirety of the solution. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. type ( frf ) :: rst !! The resulting frequency responses. ! Local Variables integer ( int32 ) :: i , npts , neqn , nfreq , flag real ( real64 ) :: dt , sampleRate , df real ( real64 ), allocatable , dimension (:) :: t , force real ( real64 ), allocatable , dimension (:,:) :: sol class ( ode_integrator ), pointer :: integrator type ( dprk45_integrator ), target :: defaultIntegrator class ( window ), pointer :: w type ( hamming_window ), target :: defaultWindow class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( fs )) then sampleRate = fs else sampleRate = 1.024d3 end if if ( present ( solver )) then integrator => solver else integrator => defaultIntegrator end if dt = 1.0d0 / sampleRate npts = floor ( span / dt ) + 1 neqn = size ( iv ) if ( present ( win )) then w => win else w => defaultWindow w % size = npts end if nfreq = compute_transform_length ( w % size ) ! Input Checking if (. not . associated ( sys % forcing_function )) go to 10 ! Memory Allocation allocate ( rst % responses ( nfreq , neqn ), stat = flag ) if ( flag == 0 ) allocate ( rst % frequency ( nfreq ), stat = flag ) if ( flag == 0 ) allocate ( t ( npts ), stat = flag ) if ( flag == 0 ) allocate ( force ( npts ), stat = flag ) if ( flag /= 0 ) go to 20 ! Construct the array and forcing function do i = 1 , npts t ( i ) = dt * ( i - 1.0d0 ) force ( i ) = sys % forcing_function ( t ( i )) end do ! Solve the ODE's sol = integrator % solve ( sys , t , iv , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the transfer function of each result do i = 1 , neqn rst % responses (:, i ) = siso_transfer_function ( w , force , sol (:, i + 1 ), & err = errmgr ) if ( errmgr % has_error_occurred ()) return end do ! Build the frequency vector df = frequency_bin_width ( sampleRate , w % size ) rst % frequency = ( / ( df * i , i = 0 , nfreq - 1 ) / ) ! End return ! Null Forcing Function 10 continue call report_null_forcing_routine_error ( \"frf_fft\" , errmgr ) return ! Memory Allocation Error 20 continue call report_memory_error ( \"frf_fft\" , flag , errmgr ) return end function ! ------------------------------------------------------------------------------ function frf_modal_prop_damp ( mass , stiff , alpha , beta , freq , frc , & modes , modeshapes , err ) result ( rst ) !! Computes the frequency response functions for a !! multi-degree-of-freedom system that uses proportional damping such !! that the damping matrix  C  is related to the stiffness an mass !! matrices by proportional damping coefficients  \\alpha  and !!  \\beta  by  C = \\alpha M + \\beta K . use linalg , only : eigen , sort , mtx_mult , LA_NO_OPERATION , LA_TRANSPOSE use dynamics_error_handling real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . real ( real64 ), intent ( in ), dimension (:) :: freq !! An M-element array of frequency values at which to evaluate the !! frequency response functions. procedure ( modal_excite ), pointer , intent ( in ) :: frc !! A pointer to a routine used to compute the modal forcing !! function. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:) :: modes !! An optional N-element allocatable array that, if supplied, will !! be used to retrieve the modal frequencies, in units of Hz. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:,:) :: modeshapes !! An optional N-by-N allocatable matrix that, if supplied, will be !! used to retrieve the N mode shapes with each vector occupying !! its own column. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices !!      are not square, or if the mass and stiffness matrices are !!      different sized. !! - DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer !!      is undefined. type ( frf ) :: rst !! The resulting frequency responses. ! Parameters real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) complex ( real64 ), parameter :: j = ( 0.0d0 , 1.0d0 ) complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , flag complex ( real64 ) :: s real ( real64 ), allocatable , dimension (:) :: lambda , zeta real ( real64 ), allocatable , dimension (:,:) :: mmtx , kmtx complex ( real64 ), allocatable , dimension (:) :: vals , q , f , u complex ( real64 ), allocatable , dimension (:,:) :: vecs class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( freq ) n = size ( mass , 1 ) ! Input Checking if ( size ( mass , 2 ) /= n ) go to 20 if ( size ( stiff , 1 ) /= size ( stiff , 2 )) go to 30 if ( size ( stiff , 1 ) /= n . or . size ( stiff , 2 ) /= n ) go to 40 if (. not . associated ( frc )) go to 50 ! TO DO: Check for symmetry ! Memory allocations allocate ( mmtx ( n , n ), source = mass , stat = flag ) if ( flag == 0 ) allocate ( kmtx ( n , n ), source = stiff , stat = flag ) if ( flag == 0 ) allocate ( zeta ( n ), stat = flag ) if ( flag == 0 ) allocate ( q ( n ), stat = flag ) if ( flag == 0 ) allocate ( vals ( n ), stat = flag ) if ( flag == 0 ) allocate ( f ( n ), stat = flag , source = zero ) if ( flag == 0 ) allocate ( u ( n ), stat = flag ) if ( flag == 0 ) allocate ( vecs ( n , n ), stat = flag ) if ( flag == 0 ) allocate ( rst % responses ( m , n ), stat = flag ) if ( flag == 0 ) allocate ( rst % frequency ( m ), source = freq , stat = flag ) if ( flag /= 0 ) go to 10 ! Compute the eigenvalues and eigenvectors call eigen ( kmtx , mmtx , vals , vecs = vecs , err = errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( lambda ( n ), source = real ( vals ), stat = flag ) if ( flag /= 0 ) go to 10 ! Compute the damping terms zeta = compute_modal_damping ( lambda , alpha , beta ) ! Compute each transfer function do i = 1 , m call frc ( freq ( i ), f ) call mtx_mult ( LA_TRANSPOSE , one , vecs , f , zero , u ) s = j * ( 2.0d0 * pi * freq ( i )) q = u / ( s ** 2 + 2.0d0 * zeta * sqrt ( lambda ) * s + lambda ) call mtx_mult ( LA_NO_OPERATION , one , vecs , q , zero , rst % responses ( i ,:)) end do ! If needed, return the modal frequencies and mode shapes if ( present ( modes ) . or . present ( modeshapes )) then ! Sort the modal information call sort ( vals , vecs ) end if if ( present ( modes )) then allocate ( modes ( n ), source = sqrt ( real ( vals )) / ( 2.0d0 * pi ), & stat = flag ) if ( flag /= 0 ) go to 10 end if if ( present ( modeshapes )) then allocate ( modeshapes ( n , n ), source = real ( vecs ), stat = flag ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory error 10 continue call report_memory_error ( \"frf_modal_prop_damp\" , flag , errmgr ) return ! Error: Mass matrix is not square 20 continue call report_nonsquare_mass_matrix_error ( \"frf_modal_prop_damp\" , & size ( mass , 1 ), size ( mass , 2 ), errmgr ) return ! Error: Stiffness matrix is not square 30 continue call report_nonsquare_stiffness_matrix_error ( \"frf_modal_prop_damp\" , & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Error: Stiffness matrix is not sized correctly 40 continue call report_matrix_size_mismatch_error ( \"frf_modal_prop_damp\" , & \"mass\" , \"stiffness\" , size ( mass , 1 ), size ( mass , 2 ), & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Null forcing term pointer 50 continue call report_null_forcing_routine_error ( \"frf_modal_prop_damp\" , & errmgr ) return end function ! ------------------------------------------------------------------------------ function frf_modal_prop_damp_2 ( mass , stiff , alpha , beta , nfreq , freq1 , & freq2 , frc , modes , modeshapes , err ) result ( rst ) !! Computes the frequency response functions for a !! multi-degree-of-freedom system that uses proportional damping such !! that the damping matrix  C  is related to the stiffness an mass !! matrices by proportional damping coefficients  \\alpha  and !!  \\beta  by  C = \\alpha M + \\beta K . use linalg , only : eigen , sort , mtx_mult , LA_NO_OPERATION , LA_TRANSPOSE use dynamics_error_handling real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . integer ( int32 ), intent ( in ) :: nfreq !! The number of frequency values to analyze.  This value must be !! at least 2. real ( real64 ), intent ( in ) :: freq1 !! The starting frequency.  It is recommended that the units be set !! to Hz. real ( real64 ), intent ( in ) :: freq2 !! The ending frequency.  It is recommended that the units be set to !! Hz. procedure ( modal_excite ), pointer , intent ( in ) :: frc !! A pointer to a routine used to compute the modal forcing !! function. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:) :: modes !! An optional N-element allocatable array that, if supplied, will !! be used to retrieve the modal frequencies, in units of Hz. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:,:) :: modeshapes !! An optional N-by-N allocatable matrix that, if supplied, will be !! used to retrieve the N mode shapes with each vector occupying !! its own column. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices !!      are not square, or if the mass and stiffness matrices are !!      different sized. !! - DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer !!      is undefined. type ( frf ) :: rst !! The resulting frequency responses. ! Local Variables integer ( int32 ) :: i , flag real ( real64 ) :: df real ( real64 ), allocatable , dimension (:) :: freq class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( abs ( freq1 - freq2 ) < sqrt ( epsilon ( freq1 ))) then call report_zero_difference_error ( \"frf_modal_prop_damp_2\" , & \"freq1\" , freq1 , \"freq2\" , freq2 , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if if ( nfreq < 2 ) then call report_generic_counting_error ( \"frf_modal_prop_damp_2\" , & \"The number of frequency points must be at least 2, \" // & \"but was found to be \" , nfreq , \".\" , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if ! Process df = ( freq2 - freq1 ) / ( nfreq - 1.0d0 ) allocate ( freq ( nfreq ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"frf_modal_prop_damp_2\" , flag , errmgr ) return end if freq = ( / ( df * i + freq1 , i = 0 , nfreq - 1 ) / ) rst = frequency_response ( mass , stiff , alpha , beta , freq , frc , modes , & modeshapes , err ) end function ! ------------------------------------------------------------------------------ pure elemental function compute_modal_damping ( lambda , alpha , beta ) & result ( rst ) !! Computes the modal damping factors  \\zeta_i  given the !! proportional damping terms  \\alpha  and  \\beta  where !!  \\alpha + \\beta \\omega_{i}&#94;2 = 2 \\zeta_{i} \\omega_{i} , !!  \\lambda_{i} = \\omega_{i}&#94;2 , and  \\lambda_i  is the !!  i&#94;{th}  eigenvalue of the system. real ( real64 ), intent ( in ) :: lambda !! The square of the modal frequency - the eigen value. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . real ( real64 ) rst !! The modal damping parameter. ! Local Variables integer ( int32 ) :: n ! Process rst = ( alpha + beta * lambda ) / ( 2.0d0 * sqrt ( lambda )) end function ! ------------------------------------------------------------------------------ subroutine modal_response ( mass , stiff , freqs , modeshapes , err ) !! Computes the modal frequencies and modes shapes for !! multi-degree-of-freedom system. use dynamics_error_handling use linalg , only : eigen , sort real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must !! be symmetric. real ( real64 ), intent ( out ), allocatable , dimension (:) :: freqs !! An allocatable N-element array where the modal frequencies will !! be returned in ascending order with units of Hz. real ( real64 ), intent ( out ), allocatable , optional , dimension (:,:) :: & modeshapes !! An optional, allocatable N-by-N matrix where the N mode shapes !! for the system will be returned.  The mode shapes are stored in !! columns. class ( errors ), intent ( inout ), optional , target :: err ! Parameters real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) ! Local Variables integer ( int32 ) :: n , flag real ( real64 ), allocatable , dimension (:,:) :: mmtx , kmtx complex ( real64 ), allocatable , dimension (:) :: vals complex ( real64 ), allocatable , dimension (:,:) :: vecs class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( mass , 1 ) ! Input Checking if ( size ( mass , 2 ) /= n ) go to 10 if ( size ( stiff , 1 ) /= size ( stiff , 2 )) go to 20 if ( size ( stiff , 1 ) /= n . or . size ( stiff , 2 ) /= n ) go to 30 ! TO DO: Check for symmetry ! Memory allocations allocate ( mmtx ( n , n ), source = mass , stat = flag ) if ( flag == 0 ) allocate ( kmtx ( n , n ), source = stiff , stat = flag ) if ( flag == 0 ) allocate ( vals ( n ), stat = flag ) if ( flag == 0 . and . present ( modeshapes )) & allocate ( vecs ( n , n ), stat = flag ) if ( flag /= 0 ) go to 40 ! Solve the eigen problem if ( present ( modeshapes )) then call eigen ( kmtx , mmtx , vals , vecs = vecs , err = errmgr ) if ( errmgr % has_error_occurred ()) return call sort ( vals , vecs ) allocate ( modeshapes ( n , n ), source = real ( vecs ), stat = flag ) if ( flag /= 0 ) go to 40 else call eigen ( kmtx , mmtx , vals , err = errmgr ) if ( errmgr % has_error_occurred ()) return call sort ( vals ) end if ! Convert the eigenvalues to frequency values allocate ( freqs ( n ), source = sqrt ( abs ( real ( vals ))) / ( 2.0d0 * pi ), & stat = flag ) if ( flag /= 0 ) go to 40 ! End return ! Non-square mass matrix error handler 10 continue call report_nonsquare_mass_matrix_error ( \"modal_response\" , & size ( mass , 1 ), size ( mass , 2 ), errmgr ) return ! Non-square stiffness matrix error handler 20 continue call report_nonsquare_stiffness_matrix_error ( \"modal_response\" , & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Stiffness and mass matrix size mismatch error handler 30 continue call report_matrix_size_mismatch_error ( \"modal_response\" , & \"mass\" , \"stiffness\" , size ( mass , 1 ), size ( mass , 2 ), & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Memory error handler 40 continue call report_memory_error ( \"modal_response\" , flag , errmgr ) return end subroutine ! ------------------------------------------------------------------------------ subroutine normalize_mode_shapes ( x ) !! Normalizes mode shape vectors such that the largest magnitude !! value in the vector is one. real ( real64 ), intent ( inout ), dimension (:,:) :: x !! The matrix of mode shape vectors with one vector per column. ! Local Variables integer ( int32 ) :: i , loc real ( real64 ) :: factor ! Process do i = 1 , size ( x , 2 ) loc = maxloc ( abs ( x (:, i )), 1 ) factor = x ( loc , i ) x (:, i ) = x (:, i ) / factor end do end subroutine ! ****************************************************************************** ! HARMONIC_ODE_CONTAINER ROUTINES ! ------------------------------------------------------------------------------ function hoc_frf_sweep ( sys , freq , iv , solver , ncycles , ntransient , & points , err ) result ( rst ) !! Computes the frequency response of each equation of a system of !! harmonically excited ODE's by sweeping through frequency. use spectrum , only : next_power_of_two use diffeq , only : dprk45_integrator use dynamics_error_handling class ( harmonic_ode_container ), intent ( inout ) :: sys !! The harmonic_ode_container object containing the equations to !! analyze.  To properly use this object, extend the !! harmonic_ode_container object and overload the ode routine to !! define the ODE's.  Use the excitation_frequency property to !! obtain the desired frequency from the solver. real ( real64 ), intent ( in ), dimension (:) :: freq !! An M-element array containing the frequency points at which the !! solution should be computed.  Notice, whatever units are utilized !! for this array are also the units of the excitation_frequency !! property in @p sys.  It is recommended that the units be set to !! Hz.  Additionally, this array cannot contain any zero-valued !! elements as the ODE solution time for each frequency is !! determined by the period of oscillation and number of cycles. real ( real64 ), intent ( in ), dimension (:) :: iv !! An N-element array containing the initial conditions for each of !! the N ODEs. class ( ode_integrator ), intent ( inout ), optional , target :: solver !! An optional differential equation solver.  The default solver !! is the Dormand-Prince Runge-Kutta integrator from the DIFFEQ !! library. integer ( int32 ), intent ( in ), optional :: ncycles !! An optional parameter controlling the number of cycles to !! analyze when determining the amplitude and phase of the response. !! The default is 20. integer ( int32 ), intent ( in ), optional :: ntransient !! An optional parameter controlling how many of the initial !! \"transient\" cycles to ignore.  The default is 200. integer ( int32 ), intent ( in ), optional :: points !! An optional parameter controlling how many evenly spaced !! solution points should be considered per cycle.  The default is !! 1000.  Notice, there must be at least 2 points per cycle for the !! analysis to be effective.  The algorithm utilizes a discrete !! Fourier transform to determine the phase and amplitude, and in !! order to satisfy Nyquist conditions, the value must be at least !! 2. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. !! - DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter !!      is given. !! - DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued !!      frequency was supplied. type ( frf ) :: rst !! The resulting frequency responses. ! Parameters real ( real64 ), parameter :: zerotol = sqrt ( epsilon ( 0.0d0 )) ! Local Variables integer ( int32 ) :: i , j , nfreq , neqn , nc , nt , ntotal , npts , ppc , flag , & nfft , i1 , ncpts real ( real64 ) :: dt , tare , phase , amp real ( real64 ), allocatable , dimension (:) :: ic , t real ( real64 ), allocatable , dimension (:,:) :: sol complex ( real64 ), allocatable , dimension (:) :: xpts class ( ode_integrator ), pointer :: integrator type ( dprk45_integrator ), target :: default_integrator class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ncycles )) then nc = ncycles else nc = 20 end if if ( present ( ntransient )) then nt = ntransient else nt = 200 end if if ( present ( points )) then ppc = points else ppc = 1000 end if nfreq = size ( freq ) neqn = size ( iv ) ntotal = nt + nc npts = ntotal * ppc ncpts = nc * ppc i1 = npts - ncpts + 1 nfft = 2 ** next_power_of_two ( ppc * nc ) ! Set up the integrator if ( present ( solver )) then integrator => solver else integrator => default_integrator end if ! Input Checking if ( nc < 1 ) go to 20 if ( nt < 1 ) go to 30 if ( ppc < 2 ) go to 40 do i = 1 , nfreq if ( abs ( freq ( i )) < zerotol ) go to 50 end do ! Local Memory Allocation allocate ( rst % responses ( nfreq , neqn ), stat = flag ) if ( flag == 0 ) allocate ( rst % frequency ( nfreq ), source = freq , & stat = flag ) if ( flag == 0 ) allocate ( ic ( neqn ), stat = flag , source = iv ) if ( flag == 0 ) allocate ( t ( npts ), stat = flag ) if ( flag == 0 ) allocate ( xpts ( nfft ), stat = flag , source = ( 0.0d0 , 0.0d0 )) if ( flag /= 0 ) go to 10 ! Cycle over each frequency point do i = 1 , nfreq ! Define the time vector dt = ( 1.0d0 / freq ( i )) / ( ppc - 1.0d0 ) t = ( / ( dt * j , j = 0 , npts - 1 ) / ) ! Update the frequency sys % excitation_frequency = freq ( i ) ! Compute the solution sol = integrator % solve ( sys , t , ic , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Reset the initial conditions to the last solution point ic = sol ( npts , 2 :) ! Determine the magnitude and phase for each equation do j = 1 , neqn rst % responses ( i , j ) = get_magnitude_phase ( sol ( i1 :, j + 1 ), xpts ) end do end do ! End return ! Memory Error 10 continue call report_memory_error ( \"hoc_frf_sweep\" , flag , errmgr ) return ! Number of Cycles Error 20 continue call report_generic_counting_error ( \"hoc_frf_sweep\" , & \"The number of cycles to analyze must be at least 1; \" // & \"however, a value of \" , nc , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Number of Transient Cycles Error 30 continue call report_generic_counting_error ( \"hoc_frf_sweep\" , & \"The number of transient cycles must be at least 1; \" // & \"however, a value of \" , nt , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Points Per Cycle Error 40 continue call report_generic_counting_error ( \"hoc_frf_sweep\" , & \"The number of points per cycle must be at least 2; \" // & \"however, a value of \" , ppc , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Zero-Valued Frequency Error 50 continue call report_zero_valued_frequency_error ( \"hoc_frf_sweep\" , i , errmgr ) return end function ! ---------- function get_magnitude_phase ( x , xzeros ) result ( rst ) !! Returns the magnitude and phase of a signal. use fftpack , only : fft use spectrum , only : compute_transform_length ! Arguments real ( real64 ), intent ( in ), dimension (:) :: x !! The array containing the signal. complex ( real64 ), intent ( inout ), dimension (:) :: xzeros !! A workspace array for the FFT operation. complex ( real64 ) :: rst !! The complex-valued result defining both magnitude and phase. ! Local Variables integer ( int32 ) :: ind , m , n , nx real ( real64 ) :: amp , phase ! Initialization nx = size ( x ) n = size ( xzeros ) m = compute_transform_length ( n ) amp = 0.5d0 * ( maxval ( x ) - minval ( x )) ! Zero pad the data xzeros (: nx ) = cmplx ( x , 0.0d0 , real64 ) xzeros ( nx + 1 :) = cmplx ( 0.0d0 , 0.0d0 , real64 ) ! Compute the FFT to estimate the phase xzeros = fft ( xzeros ) ind = maxloc ( abs ( xzeros (: m )), 1 ) phase = atan2 ( aimag ( xzeros ( ind )), real ( xzeros ( ind ))) rst = cmplx ( amp * cos ( phase ), amp * sin ( phase ), real64 ) end function ! ------------------------------------------------------------------------------ function hoc_frf_sweep_2 ( sys , nfreq , freq1 , freq2 , iv , solver , ncycles , & ntransient , points , err ) result ( rst ) !! Computes the frequency response of each equation of a system of !! harmonically excited ODE's by sweeping through frequency. use spectrum , only : next_power_of_two use diffeq , only : dprk45_integrator use dynamics_error_handling class ( harmonic_ode_container ), intent ( inout ) :: sys !! The harmonic_ode_container object containing the equations to !! analyze.  To properly use this object, extend the !! harmonic_ode_container object and overload the ode routine to !! define the ODE's.  Use the excitation_frequency property to !! obtain the desired frequency from the solver. integer ( int32 ), intent ( in ) :: nfreq !! The number of frequency values to analyze.  This value must be !! at least 2. real ( real64 ), intent ( in ) :: freq1 !! The starting frequency.  It is recommended that the units be set !! to Hz. real ( real64 ), intent ( in ) :: freq2 !! The ending frequency.  It is recommended that the units be set to !! Hz. real ( real64 ), intent ( in ), dimension (:) :: iv !! An N-element array containing the initial conditions for each of !! the N ODEs. class ( ode_integrator ), intent ( inout ), optional , target :: solver !! An optional differential equation solver.  The default solver !! is the Dormand-Prince Runge-Kutta integrator from the DIFFEQ !! library. integer ( int32 ), intent ( in ), optional :: ncycles !! An optional parameter controlling the number of cycles to !! analyze when determining the amplitude and phase of the response. !! The default is 20. integer ( int32 ), intent ( in ), optional :: ntransient !! An optional parameter controlling how many of the initial !! \"transient\" cycles to ignore.  The default is 200. integer ( int32 ), intent ( in ), optional :: points !! An optional parameter controlling how many evenly spaced !! solution points should be considered per cycle.  The default is !! 1000.  Notice, there must be at least 2 points per cycle for the !! analysis to be effective.  The algorithm utilizes a discrete !! Fourier transform to determine the phase and amplitude, and in !! order to satisfy Nyquist conditions, the value must be at least !! 2. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. !! - DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter !!      is given. !! - DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued !!      frequency was supplied. type ( frf ) :: rst !! The resulting frequency responses. ! Local Variables integer ( int32 ) :: i , flag real ( real64 ) :: df real ( real64 ), allocatable , dimension (:) :: freq class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( abs ( freq1 - freq2 ) < sqrt ( epsilon ( freq1 ))) then call report_zero_difference_error ( \"hoc_frf_sweep_2\" , & \"freq1\" , freq1 , \"freq2\" , freq2 , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if if ( nfreq < 2 ) then call report_generic_counting_error ( \"hoc_frf_sweep_2\" , & \"The number of frequency points must be at least 2, \" // & \"but was found to be \" , nfreq , \".\" , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if ! Process df = ( freq2 - freq1 ) / ( nfreq - 1.0d0 ) allocate ( freq ( nfreq ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"hoc_frf_sweep_2\" , flag , errmgr ) return end if freq = ( / ( df * i + freq1 , i = 0 , nfreq - 1 ) / ) rst = sys % frequency_sweep ( freq , iv , solver , ncycles , ntransient , & points , err ) end function ! ****************************************************************************** ! KINEMATICS ROUTINES ! ****************************************************************************** pure function rotate_x ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about an !! x-axis such that !!  \\overrightarrow{r_2} = \\textbf{R}_x \\overrightarrow{r_1} . !! !!  \\textbf{R}_x = \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ 0 & !! \\cos{\\theta_x} & -\\sin{\\theta_x} \\\\ 0 & \\sin{\\theta_x} & !! \\cos{\\theta_x} \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ 1.0d0 , 0.0d0 , 0.0d0 , 0.0d0 , c , s , 0.0d0 , - s , c ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ pure function rotate_y ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about a y-axis !! such that !!  \\overrightarrow{r_2} = \\textbf{R}_y \\overrightarrow{r_1} . !! !!  \\textbf{R}_y = \\left[ \\begin{matrix} \\cos{\\theta_y} & 0 & !! \\sin{\\theta_y} \\\\ 0 & 1 & 0 \\\\ -\\sin{\\theta_y} & 0 & !! \\cos{\\theta_y} \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ c , 0.0d0 , - s , 0.0d0 , 1.0d0 , 0.0d0 , s , 0.0d0 , c ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ pure function rotate_z ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about a y-axis !! such that !!  \\overrightarrow{r_2} = \\textbf{R}_z \\overrightarrow{r_1} . !! !!  \\textbf{R}_z = \\left[ \\begin{matrix} \\cos{\\theta_z} & !! -\\sin{\\theta_z} & 0 \\\\ \\sin{\\theta_z} & \\cos{\\theta_z} & 0 \\\\ !! 0 & 0 & 1 \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ c , s , 0.0d0 , - s , c , 0.0d0 , 0.0d0 , 0.0d0 , 1.0d0 ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics.f90.html"},{"title":"dynamics_error_handling.f90 – DYNAMICS","text":"Contents Modules dynamics_error_handling Source Code dynamics_error_handling.f90 Source Code module dynamics_error_handling use ferror use iso_fortran_env use diffeq , only : DIFFEQ_INVALID_INPUT_ERROR , & DIFFEQ_MEMORY_ALLOCATION_ERROR , DIFFEQ_NULL_POINTER_ERROR implicit none integer ( int32 ), parameter :: DYN_MEMORY_ERROR = DIFFEQ_MEMORY_ALLOCATION_ERROR !! Defines an error associated with memory allocations. integer ( int32 ), parameter :: DYN_NULL_POINTER_ERROR = DIFFEQ_NULL_POINTER_ERROR !! Defines an error associated with a null pointer. integer ( int32 ), parameter :: DYN_INVALID_INPUT_ERROR = DIFFEQ_INVALID_INPUT_ERROR !! Defines an error associated with an invalid input. integer ( int32 ), parameter :: DYN_MATRIX_SIZE_ERROR = 100100 !! Defines an error associated with an incorrectly sized matrix. integer ( int32 ), parameter :: DYN_ZERO_VALUED_FREQUENCY_ERROR = 100101 !! Defins an error associated with a zero-valued frequency. contains ! ------------------------------------------------------------------------------ subroutine report_null_forcing_routine_error ( name , err ) !! Reports a null forcing routine pointer error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Report the error call err % report_error ( name , & \"No forcing function routine was supplied.\" , & DYN_NULL_POINTER_ERROR ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_memory_error ( name , flag , err ) !! Reports a memory allocation error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: flag !! The flag returned from the allocate statement. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MEMORY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonsquare_mass_matrix_error ( name , m , n , err ) !! Reports an error relating to a non-square mass matrix. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: m !! The number of rows found in the mass matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns found in the mass matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The mass matrix is not square.  \" // & \"It was found to be \" , m , \"-by-\" , n , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonsquare_stiffness_matrix_error ( name , m , n , err ) !! Reports an error relating to a non-square stiffness matrix. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: m !! The number of rows found in the stiffness matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns found in the stiffness matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The stiffness matrix is not square.  \" // & \"It was found to be \" , m , \"-by-\" , n , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_mismatch_error ( name , mtx1 , mtx2 , m1 , n1 , & m2 , n2 , err ) !! Reports a mismatch in matrix sizes. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: mtx1 !! The name of the first matrix. character ( len = * ), intent ( in ) :: mtx2 !! The name of the second matrix. integer ( int32 ), intent ( in ) :: m1 !! The number of rows in the first matrix. integer ( int32 ), intent ( in ) :: n1 !! The number of columns in the first matrix. integer ( int32 ), intent ( in ) :: m2 !! The number of rows in the second matrix. integer ( int32 ), intent ( in ) :: n2 !! The number of columns in the second matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The size of the \" // mtx1 // \" matrix (\" , m1 , & \"-by-\" , n1 , \") does not match the size of the \" // mtx2 , & \" matrix (\" , m2 , \"-by-\" , n2 , \").\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_zero_valued_frequency_error ( name , index , err ) !! Reports an error associated with a zero-valued frequency value. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: index !! The array index at which the zero-valued frequency was found. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"A zero-valued frequency was found at index \" , & index , \".\" call err % report_error ( name , trim ( errmsg ), & DYN_ZERO_VALUED_FREQUENCY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_generic_counting_error ( name , str1 , val , str2 , flag , err ) !! A generic error reporting routine. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: str1 !! The first string. integer ( int32 ), intent ( in ) :: val !! The integer value. character ( len = * ), intent ( in ) :: str2 !! The second string. integer ( int32 ), intent ( in ) :: flag !! The error flag. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 512 ) :: errmsg ! Report the error write ( errmsg , 100 ) str1 , val , str2 call err % report_error ( name , trim ( errmsg ), flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_zero_difference_error ( name , var1 , val1 , var2 , val2 , & flag , err ) !! Reports a zero-difference between two variables where a non-zero !! difference was expected. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var1 !! The name of the first variable. real ( real64 ), intent ( in ) :: val1 !! The value of the first variable. character ( len = * ), intent ( in ) :: var2 !! The name of the second variable. real ( real64 ), intent ( in ) :: val2 !! The value of the second variable. integer ( int32 ), intent ( in ) :: flag !! The error flag. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"A non-zero difference between \" // var1 // & \" (\" , val1 , \"), and \" // var2 // \" (\" , val2 , \") was expected.\" call err % report_error ( name , trim ( errmsg ), flag ) ! Formatting 100 format ( A , F0 . 4 , A , F0 . 4 , A ) end subroutine ! ------------------------------------------------------------------------------ ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_error_handling.f90.html"}]}