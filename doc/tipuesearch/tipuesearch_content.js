var tipuesearch = {"pages":[{"title":" DYNAMICS ","text":"DYNAMICS Developer Info Jason Christopherson","tags":"home","loc":"index.html"},{"title":"state_space – DYNAMICS ","text":"type, public :: state_space Defines a state-space representation of a dynamic system.  This\nimplementation takes the form: Where: denotes time. is the state vector. is the input vector. is the output vector. Contents Variables A B C D Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: A The N-by-N dynamics matrix, where N is the number of state\nvariables. real(kind=real64), public, allocatable, dimension(:,:) :: B The N-by-M input matrix, where M is the number of inputs. real(kind=real64), public, allocatable, dimension(:,:) :: C The P-by-N output matrix, where P is the number of outputs. real(kind=real64), public, allocatable, dimension(:,:) :: D The P-by-M feedthrough matrix.","tags":"","loc":"type\\state_space.html"},{"title":"transfer_function – DYNAMICS ","text":"type, public :: transfer_function Defines a transfer function for a continuous system of the form . Contents Variables X Y Type-Bound Procedures evaluate initialize poles to_ccf_state_space to_ocf_state_space zeros Components Type Visibility Attributes Name Initial type(polynomial), public :: X The denominator polynomial in .  The polynomial coefficients\nare stored in acending order such that . type(polynomial), public :: Y The numerator polynomial in .  The polynomial coefficients\nare stored in acending order such that . Type-Bound Procedures generic, public :: evaluate => tf_eval_omega, tf_eval_s private pure elemental function tf_eval_omega(this, omega) result(rst) Evaluates the transfer function at the specified value of the\nLaplace variable . Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer_function object. real(kind=real64), intent(in) :: omega The frequency, in rad/s, at which to evaluate the transfer \nfunction. Return Value complex(kind=real64) The value of the transfer function. private pure elemental function tf_eval_s(this, s) result(rst) Evaluates the transfer function at the specified value of the\nLaplace variable . Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer_function object. complex(kind=real64), intent(in) :: s The Laplace variable at which to evaluate the transfer function. Return Value complex(kind=real64) The value of the transfer function. generic, public :: initialize => tf_init_poly, tf_init_array private  subroutine tf_init_poly(this, y, x) Initializes a new transfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(inout) :: this The transfer_function object. class(polynomial), intent(in) :: y The numerator polynomial in . class(polynomial), intent(in) :: x The denominator polynomial in . private  subroutine tf_init_array(this, y, x) Initializes a new transfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(inout) :: this The transfer_function object. real(kind=real64), intent(in), dimension(:) :: y The numerator polynomial in .  The polynomial coefficients\nare stored in acending order such that . real(kind=real64), intent(in), dimension(:) :: x The denominator polynomial in .  The polynomial coefficients\nare stored in acending order such that . procedure, public :: poles => tf_poles private  function tf_poles(this, err) result(rst) Computes the poles of the transfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer_function object. class(errors), intent(inout), optional, target :: err An error handling object. Return Value complex(kind=real64), allocatable, dimension(:) The poles of the transfer function. procedure, public :: to_ccf_state_space => tf_to_ccf_statespace private  function tf_to_ccf_statespace(this) result(rst) Converts a transfer_function type into a controllable canonical form\nstate_space type.  See this article\nfor a description of this form. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer_function to convert. Return Value type( state_space ) The resulting state-space object. procedure, public :: to_ocf_state_space => tf_to_ocf_statespace private  function tf_to_ocf_statespace(this) result(rst) Converts a transfer_function type into an observable canonical form\nstate_space type.  See this article\nfor a description of this form. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer_function to convert. Return Value type( state_space ) The resulting state-space object. procedure, public :: zeros => tf_zeros private  function tf_zeros(this, err) result(rst) Computes the zeros of the transfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: this The transfer function object. class(errors), intent(inout), optional, target :: err An error handling object. Return Value complex(kind=real64), allocatable, dimension(:) The zeros of the transfer function.","tags":"","loc":"type\\transfer_function.html"},{"title":"frf – DYNAMICS ","text":"type, public :: frf A container for a frequency response function, or series of frequency\nresponse functions. Contents Variables frequency responses Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency An N-element array containing the frequency values at which the \nFRF is provided.  The units of this array are the same as the\nunits of the frequency values passed to the routine used to \ncompute the frequency response. complex(kind=real64), public, allocatable, dimension(:,:) :: responses An N-by-M matrix containing the M frequency response functions\nevaluated at each of the N frequency points.","tags":"","loc":"type\\frf.html"},{"title":"mimo_frf – DYNAMICS ","text":"type, public :: mimo_frf A container for the frequency responses of a system of multiple \ninputs and multiple outputs (MIMO). Contents Variables frequency responses Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency An N-element array containing the frequency values at which the \nFRF is provided.  The units of this array are the same as the\nunits of the frequency values passed to the routine used to \ncompute the frequency response. complex(kind=real64), public, allocatable, dimension(:,:,:) :: responses An N-by-M-by-P array containing the frequency response functions\nfor each of the M outputs corresponding to each of the P inputs.","tags":"","loc":"type\\mimo_frf.html"},{"title":"beam_element_2d – DYNAMICS ","text":"type, public, extends( line_element ) :: beam_element_2d Defines a two-dimensional Bernoulli-Euler beam element. Contents Variables area material moment_of_inertia node_1 node_2 Type-Bound Procedures constitutive_matrix evaluate_shape_function external_force_vector get_dimensionality get_dof_per_node get_node get_node_count get_terminal_nodes jacobian length mass_matrix rotation_matrix shape_function_matrix stiffness_matrix strain_displacement_matrix Components Type Visibility Attributes Name Initial real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. real(kind=real64), public :: moment_of_inertia The beam moment of inertia (second moment of area). type( node ), public :: node_1 The first node of the element (s = -1). type( node ), public :: node_2 The second node of the element (s = 1). Type-Bound Procedures procedure, public :: constitutive_matrix => b2d_constitutive_matrix private pure function b2d_constitutive_matrix(this) result(rst) Computes the constitutive matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: evaluate_shape_function => b2d_shape_function private pure function b2d_shape_function(this, i, s) result(rst) Evaluates the i-th shape function at natural coordinate s. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. integer(kind=int32), intent(in) :: i The index of the shape function to evaluate. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate\nthe shape function. Return Value real(kind=real64) The value of the i-th shape function at s. procedure, public :: external_force_vector => le_ext_force_vector private pure function le_ext_force_vector(this, q, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. real(kind=real64), intent(in), dimension(:) :: q The surface traction forces vector or body force vector. For instance, a 2D problem this vector would look like [qx, qy]**T. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. procedure, public :: get_dimensionality => b2d_dimensionality private pure function b2d_dimensionality(this) result(rst) Gets the dimensionality of the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. Return Value integer(kind=int32) The dimensionality. procedure, public :: get_dof_per_node => b2d_dof_per_node private pure function b2d_dof_per_node(this) result(rst) Gets the number of degrees of freedom per node. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. Return Value integer(kind=int32) The number of DOF per node. procedure, public :: get_node => b2d_get_node private pure function b2d_get_node(this, i) result(rst) Gets the requested node from the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. integer(kind=int32), intent(in) :: i The local index of the node to retrieve. Return Value type( node ) The requested node. procedure, public :: get_node_count => b2d_get_node_count private pure function b2d_get_node_count(this) result(rst) Gets the number of nodes for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. Return Value integer(kind=int32) The number of nodes. procedure, public :: get_terminal_nodes => b2d_terminal_nodes private pure subroutine b2d_terminal_nodes(this, i1, i2) Gets the terminal node numbers for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. integer(kind=int32), intent(out) :: i1 The index of the node at the head of the element. integer(kind=int32), intent(out) :: i2 The index of the node at the tail of the element. procedure, public :: jacobian => b2d_jacobian private pure function b2d_jacobian(this, s) result(rst) Computes the Jacobian matrix for a 2D beam element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The Jacobian matrix. procedure, public :: length => le_length private pure function le_length(this) result(rst) Computes the length of the line_element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. Return Value real(kind=real64) The length of the line element. procedure, public :: mass_matrix => b2d_mass_matrix private pure function b2d_mass_matrix(this, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: rotation_matrix => b2d_rotation_matrix private pure function b2d_rotation_matrix(this) result(rst) Computes the rotation matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting 6-by-6 rotation matrix. procedure, public :: shape_function_matrix => b2d_shape_function_matrix_2d private pure function b2d_shape_function_matrix_2d(this, s) result(rst) Computes the shape function matrix for a beam element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the shape\nfunctions. Return Value real(kind=real64), allocatable, dimension(:,:) The shape function matrix. procedure, public :: stiffness_matrix => b2d_stiffness_matrix private pure function b2d_stiffness_matrix(this, rule) result(rst) Computes the stiffness matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: strain_displacement_matrix => b2d_strain_disp_matrix_2d private pure function b2d_strain_disp_matrix_2d(this, s) result(rst) Computes the strain-displacement matrix for a 2D beam element. Arguments Type Intent Optional Attributes Name class( beam_element_2d ), intent(in) :: this The beam_element_2d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The strain-displacement matrix.","tags":"","loc":"type\\beam_element_2d.html"},{"title":"beam_element_3d – DYNAMICS ","text":"type, public, extends( line_element ) :: beam_element_3d Defines a three-dimensional Bernoulli-Euler beam element. Contents Variables Ixx Iyy Izz area material node_1 node_2 orientation_point Type-Bound Procedures constitutive_matrix evaluate_shape_function external_force_vector get_dimensionality get_dof_per_node get_node get_node_count get_terminal_nodes jacobian length mass_matrix rotation_matrix shape_function_matrix stiffness_matrix strain_displacement_matrix Components Type Visibility Attributes Name Initial real(kind=real64), public :: Ixx The beam moment of inertia about the element x-axis. real(kind=real64), public :: Iyy The beam moment of inertia about the element y-axis. real(kind=real64), public :: Izz The beam moment of inertia about the element z-axis. real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. type( node ), public :: node_1 The first node of the element (s = -1). type( node ), public :: node_2 The second node of the element (s = 1). type( point ), public :: orientation_point A point used to determine the orientation of the beam in 3D\nspace.  The orientation point is measured relative to the first\nnode in the element.  Specifically, the element z axis is assumed\nto be defined by the location of this point relative to the\nlocation of node 1. Type-Bound Procedures procedure, public :: constitutive_matrix => b3d_constitutive_matrix private pure function b3d_constitutive_matrix(this) result(rst) Computes the constitutive matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: evaluate_shape_function => b3d_shape_function private pure function b3d_shape_function(this, i, s) result(rst) Evaluates the i-th shape function at natural coordinate s. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. integer(kind=int32), intent(in) :: i The index of the shape function to evaluate. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate\nthe shape function. Return Value real(kind=real64) The value of the i-th shape function at s. procedure, public :: external_force_vector => le_ext_force_vector private pure function le_ext_force_vector(this, q, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. real(kind=real64), intent(in), dimension(:) :: q The surface traction forces vector or body force vector. For instance, a 2D problem this vector would look like [qx, qy]**T. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. procedure, public :: get_dimensionality => b3d_dimensionality private pure function b3d_dimensionality(this) result(rst) Gets the dimensionality of the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. Return Value integer(kind=int32) The dimensionality. procedure, public :: get_dof_per_node => b3d_dof_per_node private pure function b3d_dof_per_node(this) result(rst) Gets the number of degrees of freedom per node. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. Return Value integer(kind=int32) The number of DOF per node. procedure, public :: get_node => b3d_get_node private pure function b3d_get_node(this, i) result(rst) Gets the requested node from the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. integer(kind=int32), intent(in) :: i The local index of the node to retrieve. Return Value type( node ) The requested node. procedure, public :: get_node_count => b3d_get_node_count private pure function b3d_get_node_count(this) result(rst) Gets the number of nodes for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. Return Value integer(kind=int32) The number of nodes. procedure, public :: get_terminal_nodes => b3d_terminal_nodes private pure subroutine b3d_terminal_nodes(this, i1, i2) Gets the terminal node numbers for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. integer(kind=int32), intent(out) :: i1 The index of the node at the head of the element. integer(kind=int32), intent(out) :: i2 The index of the node at the tail of the element. procedure, public :: jacobian => b3d_jacobian private pure function b3d_jacobian(this, s) result(rst) Computes the Jacobian matrix for a 3D beam element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The Jacobian matrix. procedure, public :: length => le_length private pure function le_length(this) result(rst) Computes the length of the line_element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. Return Value real(kind=real64) The length of the line element. procedure, public :: mass_matrix => b3d_mass_matrix private pure function b3d_mass_matrix(this, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: rotation_matrix => b3d_rotation_matrix private pure function b3d_rotation_matrix(this) result(rst) Computes the rotation matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting 12-by-12 rotation matrix. procedure, public :: shape_function_matrix => b3d_shape_function_matrix_3d private pure function b3d_shape_function_matrix_3d(this, s) result(rst) Computes the shape function matrix for a beam element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the shape\nfunctions. Return Value real(kind=real64), allocatable, dimension(:,:) The shape function matrix. procedure, public :: stiffness_matrix => b3d_stiffness_matrix private pure function b3d_stiffness_matrix(this, rule) result(rst) Computes the stiffness matrix for the element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: strain_displacement_matrix => b3d_strain_disp_matrix_3d private pure function b3d_strain_disp_matrix_3d(this, s) result(rst) Computes the strain-displacement matrix for a 3D beam element. Arguments Type Intent Optional Attributes Name class( beam_element_3d ), intent(in) :: this The beam_element_3d object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinate at which to evaluate the matrix. Return Value real(kind=real64), allocatable, dimension(:,:) The strain-displacement matrix.","tags":"","loc":"type\\beam_element_3d.html"},{"title":"element – DYNAMICS ","text":"type, public, abstract :: element Defines an element. Contents Variables material Type-Bound Procedures constitutive_matrix evaluate_shape_function external_force_vector get_dimensionality get_dof_per_node get_node get_node_count jacobian mass_matrix shape_function_matrix stiffness_matrix strain_displacement_matrix Components Type Visibility Attributes Name Initial type( material ), public :: material The material. Type-Bound Procedures procedure(element_const_matrix_function), public, deferred, pass :: constitutive_matrix pure function element_const_matrix_function(this) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_shape_function), public, deferred, pass :: evaluate_shape_function pure function element_shape_function(this, i, s) result(rst) Prototype Defines the signature of a routine for computing the value of\nthe i-th element shape function at natural coordinate. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in) :: i The index of the shape function to evaluate. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which to evaluate\nthe shape function. Return Value real(kind=real64) The value of the i-th shape function at s. procedure, public :: external_force_vector => e_ext_force_vector private pure function e_ext_force_vector(this, q, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: q The surface traction forces vector or body force vector. For instance, a 2D problem this vector would look like [qx, qy]**T. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. procedure(element_query), public, deferred, pass :: get_dimensionality pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(element_query), public, deferred, pass :: get_dof_per_node pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(element_get_node), public, deferred, pass :: get_node pure function element_get_node(this, i) result(rst) Prototype Defines the signature of a function for retrieving the requested\nnode from the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in) :: i The local index of the node to retrieve. Return Value type( node ) The node. procedure(element_query), public, deferred, pass :: get_node_count pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(element_matrix_function), public, deferred, pass :: jacobian pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: mass_matrix => e_mass_matrix private pure function e_mass_matrix(this, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_matrix_function), public, deferred, pass :: shape_function_matrix pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: stiffness_matrix => e_stiffness_matrix private pure function e_stiffness_matrix(this, rule) result(rst) Computes the stiffness matrix for the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_matrix_function), public, deferred, pass :: strain_displacement_matrix pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix.","tags":"","loc":"type\\element.html"},{"title":"line_element – DYNAMICS ","text":"type, public, abstract, extends( element ) :: line_element Defines a line element type. Contents Variables area material Type-Bound Procedures constitutive_matrix evaluate_shape_function external_force_vector get_dimensionality get_dof_per_node get_node get_node_count get_terminal_nodes jacobian length mass_matrix rotation_matrix shape_function_matrix stiffness_matrix strain_displacement_matrix Components Type Visibility Attributes Name Initial real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. Type-Bound Procedures procedure(element_const_matrix_function), public, deferred, pass :: constitutive_matrix pure function element_const_matrix_function(this) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_shape_function), public, deferred, pass :: evaluate_shape_function pure function element_shape_function(this, i, s) result(rst) Prototype Defines the signature of a routine for computing the value of\nthe i-th element shape function at natural coordinate. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in) :: i The index of the shape function to evaluate. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which to evaluate\nthe shape function. Return Value real(kind=real64) The value of the i-th shape function at s. procedure, public :: external_force_vector => le_ext_force_vector private pure function le_ext_force_vector(this, q, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. real(kind=real64), intent(in), dimension(:) :: q The surface traction forces vector or body force vector. For instance, a 2D problem this vector would look like [qx, qy]**T. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: DYN_ONE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_FOUR_POINT_INTEGRATION_RULE The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:) The resulting vector. procedure(element_query), public, deferred, pass :: get_dimensionality pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(element_query), public, deferred, pass :: get_dof_per_node pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(element_get_node), public, deferred, pass :: get_node pure function element_get_node(this, i) result(rst) Prototype Defines the signature of a function for retrieving the requested\nnode from the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. integer(kind=int32), intent(in) :: i The local index of the node to retrieve. Return Value type( node ) The node. procedure(element_query), public, deferred, pass :: get_node_count pure function element_query(this) result(rst) Prototype Defines the signature of a function performing a query on an\ninteger-valued property of a element type. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. Return Value integer(kind=int32) The resulting value. procedure(line_element_get_terminal), public, deferred, pass :: get_terminal_nodes pure subroutine line_element_get_terminal(this, i1, i2) Prototype Defines the signature of a routine for returning the terminal\nnode numbers. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. integer(kind=int32), intent(out) :: i1 The index of the node at the head of the element. integer(kind=int32), intent(out) :: i2 The index of the node at the tail of the element. procedure(element_matrix_function), public, deferred, pass :: jacobian pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: length => le_length private pure function le_length(this) result(rst) Computes the length of the line_element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. Return Value real(kind=real64) The length of the line element. procedure, public :: mass_matrix => le_mass_matrix private pure function le_mass_matrix(this, rule) result(rst) Computes the mass matrix for the element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(line_element_const_matrix_function), public, deferred, pass :: rotation_matrix pure function line_element_const_matrix_function(this) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the line_element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_matrix_function), public, deferred, pass :: shape_function_matrix pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure, public :: stiffness_matrix => le_stiffness_matrix private pure function le_stiffness_matrix(this, rule) result(rst) Computes the stiffness matrix for the element. Arguments Type Intent Optional Attributes Name class( line_element ), intent(in) :: this The line_element object. integer(kind=int32), intent(in), optional :: rule The integration rule.  The rule must be one of the following: MECH_ONE_POINT_INTEGRATION_RULE MECH_TWO_POINT_INTEGRATION_RULE MECH_THREE_POINT_INTEGRATION_RULE MECH_FOUR_POINT_INTEGRATION_RULE The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. procedure(element_matrix_function), public, deferred, pass :: strain_displacement_matrix pure function element_matrix_function(this, s) result(rst) Prototype Defines the signature of a routine for returning a matrix\nassociated with the element. Arguments Type Intent Optional Attributes Name class( element ), intent(in) :: this The element object. real(kind=real64), intent(in), dimension(:) :: s The value of the natural coordinates at which the matrix\nshould be evaluated. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix.","tags":"","loc":"type\\line_element.html"},{"title":"material – DYNAMICS ","text":"type, public :: material Defines a linear-elastic-isotropic material. Contents Variables density modulus poissons_ratio Components Type Visibility Attributes Name Initial real(kind=real64), public :: density The density of the material. real(kind=real64), public :: modulus The modulus of elasticity of the material. real(kind=real64), public :: poissons_ratio The Poisson's ratio of the material.","tags":"","loc":"type\\material.html"},{"title":"node – DYNAMICS ","text":"type, public, extends( point ) :: node Defines a node. Contents Variables dof index x y z Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freeedom associated with this node. integer(kind=int32), public :: index The global index of the node. real(kind=real64), public :: x The x-coordinate. real(kind=real64), public :: y The y-coordinate. real(kind=real64), public :: z The z-coordinate.","tags":"","loc":"type\\node.html"},{"title":"point – DYNAMICS ","text":"type, public :: point Defines a point in 3D, Cartesian space. Contents Variables x y z Components Type Visibility Attributes Name Initial real(kind=real64), public :: x The x-coordinate. real(kind=real64), public :: y The y-coordinate. real(kind=real64), public :: z The z-coordinate.","tags":"","loc":"type\\point.html"},{"title":"dynamic_system_measurement – DYNAMICS ","text":"type, public :: dynamic_system_measurement A container of a single measurement data set. Contents Variables input output t Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: input The input data. real(kind=real64), public, allocatable, dimension(:) :: output The output data. real(kind=real64), public, allocatable, dimension(:) :: t The time points at which the measurements were taken.","tags":"","loc":"type\\dynamic_system_measurement.html"},{"title":"model_information – DYNAMICS ","text":"type, public :: model_information A container for model information. Contents Variables excitation model user_info Components Type Visibility Attributes Name Initial class(base_interpolator), public, pointer :: excitation An interpolation object allowing sampling of the excitation \nfunction. real(kind=real64), public, allocatable, dimension(:) :: model An array containing the model parameters. class(*), public, pointer :: user_info Information the user has passed along.","tags":"","loc":"type\\model_information.html"},{"title":"lti_solve – DYNAMICS","text":"public  function lti_solve(mdl, u, t, ic, solver, args, err) result(rst) Solves the LTI system given by the specified state space model. Arguments Type Intent Optional Attributes Name class( state_space ), intent(in) :: mdl The state_space model to solve. procedure( ss_excitation ), intent(in), pointer :: u The routine used to compute the excitation vector. real(kind=real64), intent(in), dimension(:) :: t The time points at which to compute the solution.  The array must\nhave at least 2 values; however, more may be specified.  If only\n2 values are specified, the integrator will compute the solution at\nthose points, but it will also return any intermediate integration\nsteps that may be required.  However, if more than 2 points are\ngiven, the integrator will return the solution values only at the\nspecified time points. real(kind=real64), intent(in), dimension(:) :: ic The initial condition vector.  This array must be the same size as\nthe number of state variables. class(ode_integrator), intent(in), optional, target :: solver The ODE solver to utilize.  If not specified, the default solver\nis a 4th/5th order Runge-Kutta integrator. class(*), intent(inout), optional :: args An optional container for arguments to pass to the excitation\nroutine. class(errors), intent(inout), optional, target :: err An error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The solution.  The time points at which the solution was evaluated\nare stored in the first column and the output(s) are stored in the\nremaining column(s). Contents","tags":"","loc":"proc\\lti_solve.html"},{"title":"operator(*) – DYNAMICS","text":"public interface operator(*) Contents Module Procedures tf_tf_mult poly_tf_mult tf_poly_mult tf_scalar_mult scalar_tf_mult Module Procedures private  function tf_tf_mult(x, y) result(rst) Multiplies two transfer functions. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function poly_tf_mult(x, y) result(rst) Multiplies a polynomial and a transfer function to result in a new\ntransfer function. Arguments Type Intent Optional Attributes Name class(polynomial), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function tf_poly_mult(x, y) result(rst) Multiplies a transfer function and a polynomial to result in a new\ntransfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. class(polynomial), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function tf_scalar_mult(x, y) result(rst) Multiplies a transfer function by a scalar value. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. real(kind=real64), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function scalar_tf_mult(x, y) result(rst) Multiplies a transfer function by a scalar value. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function.","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"ss_excitation – DYNAMICS","text":"interface public  subroutine ss_excitation(t, u, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The time value at which to compute the excitation. real(kind=real64), intent(out), dimension(:) :: u The excitation vector. class(*), intent(inout), optional :: args An optional argument used to pass objects in and out of the\nroutine. Description A routine for computing the excitation vector for a state-space\nmodel.","tags":"","loc":"interface\\ss_excitation.html"},{"title":"report_array_index_out_of_bounds_error – DYNAMICS","text":"public  subroutine report_array_index_out_of_bounds_error(name, var, ind, sz, err) Reports an array index-out-of-bounds error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: ind The offending index. integer(kind=int32), intent(in) :: sz The array size. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_array_index_out_of_bounds_error.html"},{"title":"report_array_size_error – DYNAMICS","text":"public  subroutine report_array_size_error(name, var, expected, actual, err) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: expected The expected array size. integer(kind=int32), intent(in) :: actual The actual array size. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_array_size_error.html"},{"title":"report_constraint_count_error – DYNAMICS","text":"public  subroutine report_constraint_count_error(name, expected, actual, err) Reports an error associated with an incorrect number of constraints. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: expected The expected number of constraints. integer(kind=int32), intent(in) :: actual The actual number of constraints. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_constraint_count_error.html"},{"title":"report_generic_counting_error – DYNAMICS","text":"public  subroutine report_generic_counting_error(name, str1, val, str2, flag, err) A generic error reporting routine. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: str1 The first string. integer(kind=int32), intent(in) :: val The integer value. character(len=*), intent(in) :: str2 The second string. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=512), public :: errmsg","tags":"","loc":"proc\\report_generic_counting_error.html"},{"title":"report_matrix_size_error – DYNAMICS","text":"public  subroutine report_matrix_size_error(name, var, expect_rows, expect_cols, actual_rows, actual_cols, err) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: expect_rows The expected number of rows. integer(kind=int32), intent(in) :: expect_cols The expected number of columns. integer(kind=int32), intent(in) :: actual_rows The actual number of rows. integer(kind=int32), intent(in) :: actual_cols The actual number of columns. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=512), public :: errmsg","tags":"","loc":"proc\\report_matrix_size_error.html"},{"title":"report_matrix_size_mismatch_error – DYNAMICS","text":"public  subroutine report_matrix_size_mismatch_error(name, mtx1, mtx2, m1, n1, m2, n2, err) Reports a mismatch in matrix sizes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: mtx1 The name of the first matrix. character(len=*), intent(in) :: mtx2 The name of the second matrix. integer(kind=int32), intent(in) :: m1 The number of rows in the first matrix. integer(kind=int32), intent(in) :: n1 The number of columns in the first matrix. integer(kind=int32), intent(in) :: m2 The number of rows in the second matrix. integer(kind=int32), intent(in) :: n2 The number of columns in the second matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_matrix_size_mismatch_error.html"},{"title":"report_memory_error – DYNAMICS","text":"public  subroutine report_memory_error(name, flag, err) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: flag The flag returned from the allocate statement. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_memory_error.html"},{"title":"report_nonmonotonic_array_error – DYNAMICS","text":"public  subroutine report_nonmonotonic_array_error(name, var, ind, err) Reports a nonmonotonic array error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: ind The index of the occurrence of nonmonotonicity. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonmonotonic_array_error.html"},{"title":"report_nonsquare_mass_matrix_error – DYNAMICS","text":"public  subroutine report_nonsquare_mass_matrix_error(name, m, n, err) Reports an error relating to a non-square mass matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the mass matrix. integer(kind=int32), intent(in) :: n The number of columns found in the mass matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonsquare_mass_matrix_error.html"},{"title":"report_nonsquare_matrix_error – DYNAMICS","text":"public  subroutine report_nonsquare_matrix_error(name, var, m, n, err) Reports an error relating to a non-square matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: m The number of rows found in the matrix. integer(kind=int32), intent(in) :: n The number of columns found in the matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonsquare_matrix_error.html"},{"title":"report_nonsquare_stiffness_matrix_error – DYNAMICS","text":"public  subroutine report_nonsquare_stiffness_matrix_error(name, m, n, err) Reports an error relating to a non-square stiffness matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the stiffness matrix. integer(kind=int32), intent(in) :: n The number of columns found in the stiffness matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_nonsquare_stiffness_matrix_error.html"},{"title":"report_null_forcing_routine_error – DYNAMICS","text":"public  subroutine report_null_forcing_routine_error(name, err) Reports a null forcing routine pointer error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents","tags":"","loc":"proc\\report_null_forcing_routine_error.html"},{"title":"report_overconstraint_error – DYNAMICS","text":"public  subroutine report_overconstraint_error(name, err) Reports an overconstraint error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents","tags":"","loc":"proc\\report_overconstraint_error.html"},{"title":"report_zero_difference_error – DYNAMICS","text":"public  subroutine report_zero_difference_error(name, var1, val1, var2, val2, flag, err) Reports a zero-difference between two variables where a non-zero\ndifference was expected. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var1 The name of the first variable. real(kind=real64), intent(in) :: val1 The value of the first variable. character(len=*), intent(in) :: var2 The name of the second variable. real(kind=real64), intent(in) :: val2 The value of the second variable. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_zero_difference_error.html"},{"title":"report_zero_valued_frequency_error – DYNAMICS","text":"public  subroutine report_zero_valued_frequency_error(name, index, err) Reports an error associated with a zero-valued frequency value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: index The array index at which the zero-valued frequency was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Contents Variables errmsg Variables Type Visibility Attributes Name Initial character(len=256), public :: errmsg","tags":"","loc":"proc\\report_zero_valued_frequency_error.html"},{"title":"chirp – DYNAMICS","text":"public pure elemental function chirp(t, amp, span, f1Hz, f2Hz) result(rst) Evaluates a linear chirp function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate the \nchirp. real(kind=real64), intent(in) :: amp The amplitude. real(kind=real64), intent(in) :: span The duration of the time it takes to sweep from the start \nfrequency to the end frequency. real(kind=real64), intent(in) :: f1Hz The lower excitation frequency, in Hz. real(kind=real64), intent(in) :: f2Hz The upper excitation frequency, in Hz. Return Value real(kind=real64) The value of the function at t. Contents","tags":"","loc":"proc\\chirp.html"},{"title":"compute_modal_damping – DYNAMICS","text":"public pure elemental function compute_modal_damping(lambda, alpha, beta) result(rst) Computes the modal damping factors given the\nproportional damping terms and where , , and is the eigenvalue of the system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lambda The square of the modal frequency - the eigen value. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . Return Value real(kind=real64) The modal damping parameter. Contents","tags":"","loc":"proc\\compute_modal_damping.html"},{"title":"fit_frf – DYNAMICS","text":"public  function fit_frf(mt, n, freq, rsp, maxp, minp, init, stats, alpha, controls, settings, info, err) result(rst) Uses peaks Fits an experimentally obtained frequency response by model for either a\nreceptance model: or an accelerance model: . Internally, the code uses a Levenberg-Marquardt solver to determine the\nparameters.  The initial guess for the solver is determined by a \npeak finding algorithm used to locate the resonant modes in frequency.\nfrom this result, estimates for both the amplitude and natural frequency\nvalues are obtained.  The damping parameters are assumed to be equal\nfor all modes and set to a default value of 0.1. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: mt The excitation method.  The options are as follows. FRF_ACCELERANCE_MODEL: Use an accelerance model. FRF_RECEPTANCE_MODEL: Use a receptance model. integer(kind=int32), intent(in) :: n The model order (# of resonant modes). real(kind=real64), intent(in), dimension(:) :: freq An M-element array containing the excitation frequency values in \nunits of rad/s. complex(kind=real64), intent(in), dimension(:) :: rsp An M-element array containing the frequency response to fit. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional 3*N-element array that can be used as upper limits on \nthe parameter values. If no upper limit is requested for a particular\nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional 3*N-element array that can be used as lower limits on \nthe parameter values. If no lower limit is requested for a particalar\nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: init An optional 3 N-element array that, if supplied, provides an initial\nguess for each of the 3 N model parameters for the iterative solver.\nIf supplied, this array replaces the peak finding algorithm for\nestimating an initial guess. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional 3*N-element array that, if supplied, will be used to\nreturn statistics about the fit for each model parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence intervals.\nThe default value is 0.05 such that a 95% confidence interval is \ncalculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_ARRAY_SIZE_ERROR: Occurs if freq and rsp are not the same size. DYN_UNDERDEFINED_PROBLEM_EROR: Occurs if the requested model \n     order is too high for the number of data points available. DYN_TOLERANCE_TOO_SMALL_ERROR: Occurs if the requested solver \n     tolerance is too small to be practical for this problem. DYN_TOO_FEW_ITERATIONS_ERROR: Occurs if convergence cannot be \n     achieved in the allowed number of solver iterations. Return Value real(kind=real64), allocatable, dimension(:) An array containing the model parameters stored as . Contents","tags":"","loc":"proc\\fit_frf.html"},{"title":"modal_response – DYNAMICS","text":"public  subroutine modal_response(mass, stiff, freqs, modeshapes, err) Uses linalg dynamics_error_handling Computes the modal frequencies and modes shapes for \nmulti-degree-of-freedom system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must\nbe symmetric. real(kind=real64), intent(out), allocatable, dimension(:) :: freqs An allocatable N-element array where the modal frequencies will\nbe returned in ascending order with units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional, allocatable N-by-N matrix where the N mode shapes\nfor the system will be returned.  The mode shapes are stored in\ncolumns. class(errors), intent(inout), optional, target :: err Contents","tags":"","loc":"proc\\modal_response.html"},{"title":"normalize_mode_shapes – DYNAMICS","text":"public  subroutine normalize_mode_shapes(x) Normalizes mode shape vectors such that the largest magnitude\nvalue in the vector is one. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: x The matrix of mode shape vectors with one vector per column. Contents","tags":"","loc":"proc\\normalize_mode_shapes.html"},{"title":"evaluate_accelerance_frf_model – DYNAMICS","text":"public interface evaluate_accelerance_frf_model Contents Module Procedures evaluate_accelerance_frf_model_scalar evaluate_accelerance_frf_model_array Module Procedures private pure function evaluate_accelerance_frf_model_scalar(mdl, w) result(rst) Evaluates the specified accelerance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64) The resulting frequency response function. private pure function evaluate_accelerance_frf_model_array(mdl, w) result(rst) Evaluates the specified accelerance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in), dimension(:) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64), allocatable, dimension(:) The resulting frequency response function.","tags":"","loc":"interface\\evaluate_accelerance_frf_model.html"},{"title":"evaluate_receptance_frf_model – DYNAMICS","text":"public interface evaluate_receptance_frf_model Contents Module Procedures evaluate_receptance_frf_model_scalar evaluate_receptance_frf_model_array Module Procedures private pure function evaluate_receptance_frf_model_scalar(mdl, w) result(rst) Evaluates the specified receptance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64) The resulting frequency response function. private pure function evaluate_receptance_frf_model_array(mdl, w) result(rst) Evaluates the specified receptance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in), dimension(:) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64), allocatable, dimension(:) The resulting frequency response function.","tags":"","loc":"interface\\evaluate_receptance_frf_model.html"},{"title":"frequency_response – DYNAMICS","text":"public interface frequency_response Computes the frequency response functions for a system of ODE's. Contents Module Procedures frf_modal_prop_damp frf_modal_prop_damp_2 siso_freqres mimo_freqres Module Procedures private  function frf_modal_prop_damp(mass, stiff, alpha, beta, freq, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . real(kind=real64), intent(in), dimension(:) :: freq An M-element array of frequency values at which to evaluate the\nfrequency response functions, in units of rad/s. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp_2(mass, stiff, alpha, beta, nfreq, freq1, freq2, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency, in units of rad/s. real(kind=real64), intent(in) :: freq2 The ending frequency, in units of rad/s. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function siso_freqres(x, y, fs, win, method, err) result(rst) Estimates the frequency response of a single-input, single-output (SISO)\nsystem. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the excitation signal. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the response signal. real(kind=real64), intent(in) :: fs The sampling frequency, in Hz. class(window), intent(in), optional, target :: win The window to apply to the data.  If nothing is supplied, no window\nis applied. integer(kind=int32), intent(in), optional :: method Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an\nH2 estimator.  The default is an H1 estimator. An H1 estimator is defined as the cross-spectrum of the input and\nresponse signals divided by the energy spectral density of the input.\nAn H2 estimator is defined as the energy spectral density of the\nresponse divided by the cross-spectrum of the input and response\nsignals. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_ARRAY_SIZE_ERROR: Occurs if x and y are not the same size. Return Value type( frf ) The resulting frequency response function. private  function mimo_freqres(x, y, fs, win, method, err) result(rst) Estimates the frequency responses of a multiple-input, multiple-output\n(MIMO) system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x An N-by-P array containing the P inputs to the system. real(kind=real64), intent(in), dimension(:,:) :: y An N-by-M array containing the M outputs from the system. real(kind=real64), intent(in) :: fs The sampling frequency, in Hz. class(window), intent(in), optional, target :: win The window to apply to the data.  If nothing is supplied, no window\nis applied. integer(kind=int32), intent(in), optional :: method Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an\nH2 estimator.  The default is an H1 estimator. An H1 estimator is defined as the cross-spectrum of the input and\nresponse signals divided by the energy spectral density of the input.\nAn H2 estimator is defined as the energy spectral density of the\nresponse divided by the cross-spectrum of the input and response\nsignals. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_ARRAY_SIZE_ERROR: Occurs if x and y do not have the same number\n  of rows. Return Value type( mimo_frf ) The resulting frequency response functions.","tags":"","loc":"interface\\frequency_response.html"},{"title":"frequency_sweep – DYNAMICS","text":"public interface frequency_sweep Contents Module Procedures frf_sweep_1 frf_sweep_2 Module Procedures private  function frf_sweep_1(fcn, freq, iv, solver, ncycles, ntransient, points, args, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name procedure( harmonic_ode ), intent(in), pointer :: fcn A pointer to the routine containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: freq An M-element array containing the frequency points at which the \nsolution should be computed.  Notice, whatever units are utilized\nfor this array are also the units of the excitation_frequency\nproperty in @p sys.  It is recommended that the units be set to \nHz.  Additionally, this array cannot contain any zero-valued \nelements as the ODE solution time for each frequency is \ndetermined by the period of oscillation and number of cycles. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(*), intent(inout), optional :: args An optional argument allowing for passing of data in/out of the\nfcn subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses. private  function frf_sweep_2(fcn, nfreq, freq1, freq2, iv, solver, ncycles, ntransient, points, args, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name procedure( harmonic_ode ), intent(in), pointer :: fcn A pointer to the routine containing the ODE's to integrate. integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency.  It is recommended that the units be set\nto Hz. real(kind=real64), intent(in) :: freq2 The ending frequency.  It is recommended that the units be set to\nHz. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(*), intent(inout), optional :: args An optional argument allowing for passing of data in/out of the\nfcn subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses.","tags":"","loc":"interface\\frequency_sweep.html"},{"title":"harmonic_ode – DYNAMICS","text":"interface public pure subroutine harmonic_ode(freq, t, x, dxdt, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency. real(kind=real64), intent(in) :: t The current time step value. real(kind=real64), intent(in), dimension(:) :: x The value of the solution estimate at time t. real(kind=real64), intent(out), dimension(:) :: dxdt The derivatives as computed by this routine. class(*), intent(inout), optional :: args An optional argument allowing the passing of data in/out of\nthis routine. Description Defines a system of ODE's exposed to harmonic excitation.","tags":"","loc":"interface\\harmonic_ode.html"},{"title":"modal_excite – DYNAMICS","text":"interface public  subroutine modal_excite(freq, frc) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency.  When used as a part of a frequency\nresponse calculation, this value will have the same units as\nthe frequency values provided to the frequency response\nroutine. complex(kind=real64), intent(out), dimension(:) :: frc An N-element array where the forcing function should be\nwritten. Description Defines the interface to a routine for defining the forcing\nfunction for a modal frequency analysis.","tags":"","loc":"interface\\modal_excite.html"},{"title":"ode_excite – DYNAMICS","text":"interface public  function ode_excite(t) result(rst) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate\nthe excitation function. Return Value real(kind=real64) The result. Description Defines the interface for a ODE excitation function.","tags":"","loc":"interface\\ode_excite.html"},{"title":"cross_product – DYNAMICS","text":"public pure function cross_product(x, y) result(rst) Computes the cross-product of a vector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) The left-hand-side argument. real(kind=real64), intent(in) :: y (3) The right-hand-side argument Return Value real(kind=real64), (3) The resulting vector. Contents","tags":"","loc":"proc\\cross_product.html"},{"title":"to_skew_symmetric – DYNAMICS","text":"public pure function to_skew_symmetric(x) result(rst) Converts a 3-element vector to a 3-by-3 skew-symmetric matrix.  A \nskew-symmetric matrix is defined as follows. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) The vector. Return Value real(kind=real64), (3,3) The resulting skew-symmetric matrix. Contents","tags":"","loc":"proc\\to_skew_symmetric.html"},{"title":"dh_matrix – DYNAMICS","text":"public pure function dh_matrix(alpha, a, theta, d) result(rst) Computes the Denavit-Hartenberg transformation matrix for the \nspecified DH parameters. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The link twist angle, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in) :: a The link length as measured along the link's x-axis. real(kind=real64), intent(in) :: theta The joint angle, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in) :: d The joint offset distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. Return Value real(kind=real64), (4,4) The resulting 4-by-4 transformation matrix. Contents","tags":"","loc":"proc\\dh_matrix.html"},{"title":"dh_rotate_x – DYNAMICS","text":"public pure function dh_rotate_x(alpha) result(rst) Computes the Denavit-Hartenberg matrix for a local x-axis rotation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The rotation angle, in radians. Return Value real(kind=real64), (4,4) The matrix. Contents","tags":"","loc":"proc\\dh_rotate_x.html"},{"title":"dh_rotate_z – DYNAMICS","text":"public pure function dh_rotate_z(theta) result(rst) Computes the Denavit-Hartenberg matrix for a local z-axis rotation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta The rotation angle, in radians. Return Value real(kind=real64), (4,4) The matrix. Contents","tags":"","loc":"proc\\dh_rotate_z.html"},{"title":"dh_translate_x – DYNAMICS","text":"public pure function dh_translate_x(a) result(rst) Computes the Denavit-Hartenberg matrix for a local x-axis \ntranslation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The translation. Return Value real(kind=real64), (4,4) The matrix. Contents","tags":"","loc":"proc\\dh_translate_x.html"},{"title":"dh_translate_z – DYNAMICS","text":"public pure function dh_translate_z(d) result(rst) Computes the Denavit-Hartenberg matrix for a local z-axis \ntranslation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: d The translation. Return Value real(kind=real64), (4,4) The matrix. Contents","tags":"","loc":"proc\\dh_translate_z.html"},{"title":"identity_4 – DYNAMICS","text":"public pure function identity_4() result(rst) Computes a 4-by-4 identity matrix. Arguments None Return Value real(kind=real64), (4,4) The resulting identity matrix. Contents None","tags":"","loc":"proc\\identity_4.html"},{"title":"jacobian_generating_vector – DYNAMICS","text":"public pure function jacobian_generating_vector(d, k, R, jtype) result(rst) Computes a single Jacobian generating vector given the position vector\nof the link origin, , and the joint axis unit vector, . For a revolute joint: For a prismatic joint: The Jacobian matrix is then constructed from the Jacobian generating\nvectors as follows. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: d (3) The position vector of the end-effector, , relative to the\nlink coordinate frame given in the base coordinate frame.  An easy\nway to compute this vector is to extract the first 3 elements of the\n4th column of the transformation matrix: . real(kind=real64), intent(in) :: k (3) The unit vector defining the joint axis, , given in the\nbase coordinate frame.  This vector can be computed most easily by\nusing the transformation matrix: and\nthen computing . real(kind=real64), intent(in) :: R (3,3) The rotation matrix defining the orientation of the link coordinate\nframe relative to the base coordinate frame. integer(kind=int32), intent(in) :: jtype The joint type.  Must be either REVOLUTE_JOINT or PRISMATIC_JOINT.\nIf incorrectly specified, the code defaults to a REVOLUTE_JOINT type. Return Value real(kind=real64), (6) The resulting 6-element Jacobian generating vector. Contents","tags":"","loc":"proc\\jacobian_generating_vector.html"},{"title":"solve_inverse_kinematics – DYNAMICS","text":"public  function solve_inverse_kinematics(mdl, qo, constraints, df, slvr, ib, err) result(rst) Solves the inverse kinematics problem for a linkage.  An iterative\nsolution procedure is utilized. Arguments Type Intent Optional Attributes Name procedure(vecfcn), intent(in), pointer :: mdl A routine used to compute the error in the kinematics \nequations based upon the current solution estimate. real(kind=real64), intent(in), dimension(:) :: qo An M-element array containing an initial estimate of the M joint\nvariables. real(kind=real64), intent(in), target, dimension(:) :: constraints An N-element array containing the target values (constraints) for\neach of the N kinematic equations in the model.  N must be at \nleast equal to M (the number of joint variables). real(kind=real64), intent(out), optional, target, dimension(:) :: df An optional N-element array that, if supplied, can be used to \nretrieve the residuals of each of the N kinematic equations. class(least_squares_solver), intent(inout), optional, target :: slvr An optional solver that can be used in place of the default\nLevenberg-Marquardt solver. type(iteration_behavior), intent(out), optional :: ib An optional output that can be used to gather information on the\nsolver. class(errors), intent(inout), optional, target :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Return Value real(kind=real64), allocatable, dimension(:) An M-element array containing the computed joint variables. Contents","tags":"","loc":"proc\\solve_inverse_kinematics.html"},{"title":"dh_forward_kinematics – DYNAMICS","text":"public interface dh_forward_kinematics Contents Module Procedures dh_forward_kinematics_2 dh_forward_kinematics_3 dh_forward_kinematics_4 dh_forward_kinematics_5 dh_forward_kinematics_6 dh_forward_kinematics_7 dh_forward_kinematics_8 dh_forward_kinematics_array Module Procedures private pure function dh_forward_kinematics_2(T1, T2) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_3(T1, T2, T3) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_4(T1, T2, T3, T4) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_5(T1, T2, T3, T4, T5) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_6(T1, T2, T3, T4, T5, T6) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_7(T1, T2, T3, T4, T5, T6, T7) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. real(kind=real64), intent(in) :: T7 (4,4) The transformation matrix for the seventh link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_8(T1, T2, T3, T4, T5, T6, T7, T8) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. real(kind=real64), intent(in) :: T7 (4,4) The transformation matrix for the seventh link in the linkage. real(kind=real64), intent(in) :: T8 (4,4) The transformation matrix for the eigth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_array(alpha, a, theta, d) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism.  The first entry must\nbe from the first link nearest ground. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: alpha The link twist angles, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: a The link lengths as measured along the link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: theta The joint angles, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: d The joint offsets distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. Return Value real(kind=real64), (4,4) The resulting 4-by-4 transformation matrix.","tags":"","loc":"interface\\dh_forward_kinematics.html"},{"title":"dh_jacobian – DYNAMICS","text":"public interface dh_jacobian Contents Module Procedures dh_build_jacobian Module Procedures private  function dh_build_jacobian(alpha, a, theta, d, jtypes) result(rst) Builds the Jacobian matrix for a linkage given the Denavit-Hartenberg\nparameters.  The first entry in each array must be from the first link\nnearest ground.  The Jacobian matrix relates the joint velocities to the end-effector velocity by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: alpha The link twist angles, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: a The link lengths as measured along the link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: theta The joint angles, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: d The joint offsets distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. integer(kind=int32), intent(in), dimension(size(alpha)) :: jtypes The types of each joint.  Must be either REVOLUTE_JOINT or\nPRISMATIC_JOINT.  The code defaults to REVOLUTE_JOINT. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting 6-by-N Jacobian matrix where N is the number of joint\nvariables (i.e. the length of the input arrays).","tags":"","loc":"interface\\dh_jacobian.html"},{"title":"acceleration_transform – DYNAMICS","text":"public pure function acceleration_transform(alpha, omega, a, x) result(rst) Computes the acceleration transformation matrix relating the\nposition of a point expressed in a rotating and translating body\nrelative to its parent frame. The transformation matrix takes the following form. where, and, Given a vector describing the location on a moving body, , the matrix is used to report its acceleration . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha (3) The angular acceleration vector. real(kind=real64), intent(in) :: omega (3) The angular velocity vector. real(kind=real64), intent(in) :: a (3) The translational acceleration vector describing the acceleration\nof the body in its parent coordinate frame. real(kind=real64), intent(in) :: x (3) The position vector of the body in its parent coordinate frame. Return Value real(kind=real64), (4,4) The 4-by-4 transformation matrix. Contents","tags":"","loc":"proc\\acceleration_transform.html"},{"title":"rotate_x – DYNAMICS","text":"public pure function rotate_x(angle) result(rst) Constructs the rotation matrix describing a rotation about an\nx-axis such that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_x.html"},{"title":"rotate_y – DYNAMICS","text":"public pure function rotate_y(angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_y.html"},{"title":"rotate_z – DYNAMICS","text":"public pure function rotate_z(angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Contents","tags":"","loc":"proc\\rotate_z.html"},{"title":"velocity_transform – DYNAMICS","text":"public pure function velocity_transform(omega, v, x) result(rst) Computes the velocity transformation matrix relating the position\nof a point expressed in a rotating and translating body relative to\nits parent frame. The transformation matrix takes the following form. where, Given a vector describing the location on a moving body, , the matrix is used to report its velocity . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: omega (3) The angular velocity vector. real(kind=real64), intent(in) :: v (3) The translation velocity vector describing the velocity of the\nbody in its parent coordinate frame. real(kind=real64), intent(in) :: x (3) The position vector of the body in its parent coordinate frame. Return Value real(kind=real64), (4,4) The 4-by-4 transformation matrix. Contents","tags":"","loc":"proc\\velocity_transform.html"},{"title":"rotate – DYNAMICS","text":"public interface rotate Contents Module Procedures rotate_general_1 rotate_general_2 Module Procedures private pure function rotate_general_1(i, j, k, Ip, Jp, Kp) result(rst) Constructs a rotation matrix when the orientation of the coordinate\nframe of interest is known relative to the parent coordinate frame. The matrix is of the following form. This routine does not check for orthogonallity or unit vector length;\ntherefore, to ensure correct results it is the callers responsibility\nto ensure each vector is of unit length and that the unit vectors\nare properly orthogonal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: i (3) The rotated coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: j (3) The rotated coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: k (3) The rotated coordinate frame z-axis unit vector. real(kind=real64), intent(in) :: Ip (3) The parent coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: Jp (3) The parent coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: Kp (3) The parent coordinate frame z-axis unit vector. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. private pure function rotate_general_2(i, j, k) result(rst) Constructs a rotation matrix when the orientation of the coordinate\nframe of interest is known relative to the parent coordinate frame. The matrix is of the following form. The parent coordinate frame is assumed to be as follows. This routine does not check for orthogonallity or unit vector length;\ntherefore, to ensure correct results it is the callers responsibility\nto ensure each vector is of unit length and that the unit vectors\nare properly orthogonal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: i (3) The rotated coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: j (3) The rotated coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: k (3) The rotated coordinate frame z-axis unit vector. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix.","tags":"","loc":"interface\\rotate.html"},{"title":"determine_local_stability – DYNAMICS","text":"public  function determine_local_stability(a, ev, err) result(rst) Determines the nature of stability/unstability near the point at which\nthe dynamics matrix was computed. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a An N-by-N matrix containing the 'A' matrix, also known as the\ndynamics matrix. complex(kind=real64), intent(out), optional, dimension(:) :: ev An optional N-element array that, if supplied, will be filled with \nthe eigenvalues of the matrix A. class(errors), intent(inout), optional, target :: err An error handler object. Return Value integer(kind=int32) Describe the output constants Contents","tags":"","loc":"proc\\determine_local_stability.html"},{"title":"create_connectivity_matrix – DYNAMICS","text":"public  function create_connectivity_matrix(gdof, e, nodes, err) result(rst) Creates a connectivity matrix for the element. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: gdof The number of global degrees of freedom. class( element ), intent(in) :: e The element. class( node ), intent(in), dimension(:) :: nodes The global node list. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. Contents","tags":"","loc":"proc\\create_connectivity_matrix.html"},{"title":"restore_constrained_values – DYNAMICS","text":"public  function restore_constrained_values(gdof, x, err) result(rst) Restores the constrained degrees-of-freedom from the boundary conditions\napplied by apply_boundary_conditions. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:) :: x The constrained vector. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:) The altered vector. Contents","tags":"","loc":"proc\\restore_constrained_values.html"},{"title":"shape_function_derivative – DYNAMICS","text":"public pure function shape_function_derivative(index, elem, s, i) result(rst) Computes the derivative of the shape function with respect to the natural\ncoordinate specified. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: index The index of the shape function to evaluate. class( element ), intent(in) :: elem The element object. real(kind=real64), intent(in), dimension(:) :: s The natural coordinate at which to evaluate the derivative. integer(kind=int32), intent(in) :: i The index of the natural coordinate to with which the derivative is\nto be computed. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\shape_function_derivative.html"},{"title":"shape_function_second_derivative – DYNAMICS","text":"public pure function shape_function_second_derivative(index, elem, s, i) result(rst) Computes the second derivative of the shape function with respect to the\nnatural coordinate specified. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: index The index of the shape function to evaluate. class( element ), intent(in) :: elem The element object. real(kind=real64), intent(in), dimension(:) :: s The natural coordinate at which to evaluate the derivative. integer(kind=int32), intent(in) :: i The index of the natural coordinate to with which the derivative is\nto be computed. Return Value real(kind=real64) The result. Contents","tags":"","loc":"proc\\shape_function_second_derivative.html"},{"title":"apply_displacement_constraint – DYNAMICS","text":"public  subroutine apply_displacement_constraint(dof, val, k, f) Applies a displacement constraint to the specified degree of freedom. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dof The global degree-of-freedom to which the constraint should be\napplied. real(kind=real64), intent(in) :: val The value of the displacement constraint. real(kind=real64), intent(inout), dimension(:,:) :: k The stiffness matrix to which the constraint should be applied. real(kind=real64), intent(inout), dimension(:) :: f The external force vector to which the constraint should be applied. Contents","tags":"","loc":"proc\\apply_displacement_constraint.html"},{"title":"apply_boundary_conditions – DYNAMICS","text":"public interface apply_boundary_conditions Contents Module Procedures apply_boundary_conditions_mtx apply_boundary_conditions_vec Module Procedures private  function apply_boundary_conditions_mtx(gdof, x, err) result(rst) Applies boundary conditions to a matrix by removal of the appropriate\nrows and columns. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:,:) :: x The matrix to constrain. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The altered matrix. private  function apply_boundary_conditions_vec(gdof, x, err) result(rst) Applies boundary conditions to a vector by removal of the appropriate\nitems. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:) :: x The vector to constrain. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:) The altered vector.","tags":"","loc":"interface\\apply_boundary_conditions.html"},{"title":"constraint_equations – DYNAMICS","text":"interface public  subroutine constraint_equations(xg, fg, xc, p, fc, args) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xg An N-element array containing the N independent variable\nvalues for the N differential equation solution points. real(kind=real64), intent(in), dimension(:) :: fg An N-element array containing the N differential equation\nsolution points. real(kind=real64), intent(in), dimension(:) :: xc An M-element array containing the M independent variable\nvalues for the M constraint equations. real(kind=real64), intent(in), dimension(:) :: p An array containing the model parameters. real(kind=real64), intent(out), dimension(:) :: fc An M-element array where the values of the constraint \nequations should be written. class(*), intent(inout), optional :: args An optional argument that can be used to pass data in/out\nof this routine. Description An interface to a set of routines for defining constraint \nequations to the fitting process.","tags":"","loc":"interface\\constraint_equations.html"},{"title":"siso_model_fit_least_squares – DYNAMICS","text":"public interface siso_model_fit_least_squares Contents Module Procedures siso_model_fit_least_squares_1 siso_model_fit_least_squares_2 Module Procedures private  subroutine siso_model_fit_least_squares_1(fcn, x, ic, p, integrator, ind, maxp, minp, stats, alpha, controls, settings, info, status, cov, xc, yc, constraints, weights, args, err) Attempts to fit a model of a single-intput, single-output (SISO) dynamic \nsystem by means of an iterative least-squares solver.  The algorithm\ncomputes the solution to the differential equations numerically, and\ncompares the output to the known solution via a Levenberg-Marquardt\nleast-squares solver. Arguments Type Intent Optional Attributes Name procedure(ode), intent(in), pointer :: fcn The routine containing the ODE's being fit.  To communicate \nmodel parameters and other relevant information, an instance of the\n[[model_information]] type is passed to the optional argument of this\nroutine.  Use the \"select type\" construct to access this information. class( dynamic_system_measurement ), intent(in), dimension(:) :: x An M-element array of arrays with each array containing the measured\ninput and output of the system being identified. real(kind=real64), intent(in), dimension(:) :: ic The initial condition vector for the equations in fcn. real(kind=real64), intent(inout), dimension(:) :: p An N-element array containing an initial guess at the parameters. On output, the computed model parameters. class(ode_integrator), intent(inout), optional, target :: integrator The integrator to use when solving the system equations.  If not\nsupplied, the default integrator will be used.  The default \nintegrator is a Runge-Kutta integrator (Dormand-Prince). integer(kind=int32), intent(in), optional :: ind The index of the ODE in fcn providing the output to fit.  If\nno value is supplied, a value of 1 will be utilized. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional N-element array that can be used as upper limits on the \nparameter values. If no upper limit is requested for a particular \nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional N-element array that can be used as lower limits on the \nparameter values. If no lower limit is requested for a particalar \nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional N-element array that, if supplied, will be used to \nreturn statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals. The default value is 0.05 such that a 95% confidence \ninterval is calculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. procedure(iteration_update), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract \niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return \nthe covariance matrix. real(kind=real64), intent(in), optional, dimension(:) :: xc An optional NC-element array containing the values of the independent \nvariable at which the constraint equations are defined. real(kind=real64), intent(in), optional, dimension(:) :: yc An optional NC-element array containing the constraint function \nvalues at xc. procedure( constraint_equations ), optional, pointer :: constraints An optional input, that must be utilized with the xc and yc inputs,\nbut allows for the implementation of additional constraints on the\nsolution outside of the differential equations being fitted.  An\nexample usage would be an additional set of quasi-static tests that\ncould help identify a stiffness term, for instance.  Other uses of\ncourse can be imagined. real(kind=real64), intent(in), optional, dimension(:) :: weights An optional array containing weighting factors for every equation. class(*), intent(inout), optional, target :: args User-defined information to pass along to fcn.  These arguments,\nif supplied, will be passed through to fcn by means of the\n[[model_information]] type. class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine siso_model_fit_least_squares_2(fcn, x, ic, p, integrator, ind, maxp, minp, stats, alpha, controls, settings, info, status, cov, xc, yc, constraints, weights, args, err) Attempts to fit a model of a single-intput, single-output (SISO) dynamic \nsystem by means of an iterative least-squares solver.  The algorithm\ncomputes the solution to the differential equations numerically, and\ncompares the output to the known solution via a Levenberg-Marquardt\nleast-squares solver. Arguments Type Intent Optional Attributes Name procedure(ode), intent(in), pointer :: fcn The routine containing the ODE's being fit.  To communicate \nmodel parameters and other relevant information, an instance of the\n[[model_information]] type is passed to the optional argument of this\nroutine.  Use the \"select type\" construct to access this information. class( dynamic_system_measurement ), intent(in), dimension(:) :: x An M-element array of arrays with each array containing the measured\ninput and output of the system being identified. real(kind=real64), intent(in), dimension(:,:) :: ic An M-by-NEQN matrix of initial condition vectors for the NEQN \nequations in fcn, one set for each of the M sets of data in x. real(kind=real64), intent(inout), dimension(:) :: p An N-element array containing an initial guess at the parameters. On output, the computed model parameters. class(ode_integrator), intent(inout), optional, target :: integrator The integrator to use when solving the system equations.  If not\nsupplied, the default integrator will be used.  The default \nintegrator is a Runge-Kutta integrator (Dormand-Prince). integer(kind=int32), intent(in), optional :: ind The index of the ODE in fcn providing the output to fit.  If\nno value is supplied, a value of 1 will be utilized. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional N-element array that can be used as upper limits on the \nparameter values. If no upper limit is requested for a particular \nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional N-element array that can be used as lower limits on the \nparameter values. If no lower limit is requested for a particalar \nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional N-element array that, if supplied, will be used to \nreturn statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals. The default value is 0.05 such that a 95% confidence \ninterval is calculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. procedure(iteration_update), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract \niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return \nthe covariance matrix. real(kind=real64), intent(in), optional, dimension(:) :: xc An optional NC-element array containing the values of the independent \nvariable at which the constraint equations are defined. real(kind=real64), intent(in), optional, dimension(:) :: yc An optional NC-element array containing the constraint function \nvalues at xc. procedure( constraint_equations ), optional, pointer :: constraints An optional input, that must be utilized with the xc and yc inputs,\nbut allows for the implementation of additional constraints on the\nsolution outside of the differential equations being fitted.  An\nexample usage would be an additional set of quasi-static tests that\ncould help identify a stiffness term, for instance.  Other uses of\ncourse can be imagined. real(kind=real64), intent(in), optional, dimension(:) :: weights An optional array containing weighting factors for every equation. class(*), intent(inout), optional, target :: args User-defined information to pass along to fcn.  These arguments,\nif supplied, will be passed through to fcn by means of the\n[[model_information]] type. class(errors), intent(inout), optional, target :: err An error handling object.","tags":"","loc":"interface\\siso_model_fit_least_squares.html"},{"title":"damping_from_fractional_overshoot – DYNAMICS","text":"public pure function damping_from_fractional_overshoot(x) result(rst) Employs the method of fractional overshoot to estimate the damping ratio\nfrom the response of a system to a step input.  This method is useful\nfor cases where the damping ratio is between approximately 0.5 to 0.8.\nIn such range, the logarithmic decrement approach becomes less precise. The fractional overshoot method locates the amplitude of the first\npeak of oscillation ( ) and the settling amplitude ( ), and\nthe estimates the damping ratio as follows. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The step response of the system. Return Value real(kind=real64) The estimated damping ratio. Contents","tags":"","loc":"proc\\damping_from_fractional_overshoot.html"},{"title":"damping_from_log_decrement – DYNAMICS","text":"public pure elemental function damping_from_log_decrement(delta) result(rst) Computes the damping ratio from the logarithmic decrement .\nThe damping ratio is related to the logarithmic decrement by the \nfollowing relationship. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: delta The logarithmic decrement. Return Value real(kind=real64) The damping ratio. Contents","tags":"","loc":"proc\\damping_from_log_decrement.html"},{"title":"estimate_bandwidth – DYNAMICS","text":"public pure elemental function estimate_bandwidth(fn, zeta) result(rst) Estimates the bandwidth of the resonant mode of a vibratory system.\nThe bandwidth is the width of the range of frequencies for which the\nenergy is at least half its peak value and is computed as . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: fn The resonant frequency.  The units are not important; however, \nthe units of the output will be the same as the units of this\nparameter. real(kind=real64), intent(in) :: zeta The damping ratio. Return Value real(kind=real64) The bandwidth. Contents","tags":"","loc":"proc\\estimate_bandwidth.html"},{"title":"evaluate_step_response – DYNAMICS","text":"public pure elemental function evaluate_step_response(wn, zeta, xs, t) result(rst) Evaluates the response of an underdamped single-degree-of-freedom, \nlinear system to a step function of amplitude . The step function response of an underdamped linear SDOF system is given\nas follows. where, and Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: wn The resonant frequency, in rad/s. real(kind=real64), intent(in) :: zeta The damping ratio. real(kind=real64), intent(in) :: xs The amplitude of the step input. real(kind=real64), intent(in) :: t The point in time at which to evaluate the response (units = s). Return Value real(kind=real64) The step response. Contents","tags":"","loc":"proc\\evaluate_step_response.html"},{"title":"find_settling_amplitude – DYNAMICS","text":"public pure function find_settling_amplitude(x) result(rst) Uses fftpack Estimates the settling amplitude for a step response. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The step response of the system. Return Value real(kind=real64) The settling amplitude of the step response. Contents","tags":"","loc":"proc\\find_settling_amplitude.html"},{"title":"logarithmic_decrement – DYNAMICS","text":"public pure elemental function logarithmic_decrement(x1, x2, n) result(rst) Computes the logarithmic decrement given the value of two  successive\npeaks in the time history of the free vibratory response of the system.\nThe logarithmic decrement is calculated as follows. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 The amplitude of the first peak. real(kind=real64), intent(in) :: x2 The amplitude of the second peak that occurs N periods after the\nfirst. integer(kind=int32), intent(in) :: n The number of periods of oscillation seperating the two peaks. Return Value real(kind=real64) The logarithmic decrement . Contents","tags":"","loc":"proc\\logarithmic_decrement.html"},{"title":"q_factor – DYNAMICS","text":"public pure elemental function q_factor(zeta) result(rst) Estimates the Q-factor for a vibratory system.  The Q-factor is computed . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: zeta The damping ratio. Return Value real(kind=real64) The Q-factor. Contents","tags":"","loc":"proc\\q_factor.html"},{"title":"rise_time – DYNAMICS","text":"public pure elemental function rise_time(wn, zeta) result(rst) Computes the rise time for an underdamped, second-order system.  The\nrise time is the time it takes for the system response to go from 0%\nto 100% of its final value and is given by the following relationship. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: wn The resonant frequency of the system, in rad/s. real(kind=real64), intent(in) :: zeta The damping ratio of the system.  This value must be less than 1\nas this relationship is only valid for an underdamped system. Return Value real(kind=real64) The rise time, in units of seconds. Contents","tags":"","loc":"proc\\rise_time.html"},{"title":"find_free_response_properties – DYNAMICS","text":"public  subroutine find_free_response_properties(t, x, delta, fn, x1, x2, t1, t2, s, n) Given a free-response time history, this routine attempts to find the \nlogarithmic decrement and resonant frequency of a vibratory system. The\nlogarithmic decrement is estimated by finding successive peaks by\nmeans of peak detection. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: t An N-element array containing the values in time real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the response sampled at the time points\ngiven in t. real(kind=real64), intent(out) :: delta The logarithmic decrement estimate.  If sufficient peaks cannot be\nlocated, the routine returns NaN. real(kind=real64), intent(out) :: fn The damped resonant frequency in units of Hz, assuming that the\ntime values are in seconds.  If the time units are not in seconds,\nthe units will be cycle/unit time with unit time being the units\nin which t is supplied.  If sufficient peaks cannot be located, the \nroutine returns NaN. real(kind=real64), intent(out), optional :: x1 An optional parameter that, if provided, allows for the routine to\nreturn the amplitude of the first peak.  If sufficient peaks cannot \nbe located, the routine returns NaN. real(kind=real64), intent(out), optional :: x2 An optional parameter that, if provided, allows for the routine to\nreturn the amplitude of the second peak.  If sufficient peaks cannot \nbe located, the routine returns NaN. real(kind=real64), intent(out), optional :: t1 An optional parameter that, if provided, allows for the routine to\nreturn the time at which the first peak was located.  If sufficient\npeaks cannot be located, the routine returns NaN. real(kind=real64), intent(out), optional :: t2 An optional parameter that, if provided, allows for the routine to\nreturn the time at which the second peak was located.  If sufficient\npeaks cannot be located, the routine returns NaN. real(kind=real64), intent(in), optional :: s An optional input that, if provided, allows for control of the \nsensitivity of the peak detection algorithm.  The default is 0.1%\nof the peak-peak amplitude of the signal. integer(kind=int32), intent(in), optional :: n An optional input that, if provided, determines the number of \nperiods to allow between peak selection for the logarithmic \ndecrement calculation.  The default is 1. Contents","tags":"","loc":"proc\\find_free_response_properties.html"},{"title":"dynamics – DYNAMICS","text":"Uses dynamics_kinematics dynamics_structural dynamics_stability dynamics_vibrations dynamics_controls dynamics_rotation dynamics_helper dynamics_frequency_response dynamics_system_id Contents None","tags":"","loc":"module\\dynamics.html"},{"title":"dynamics_controls – DYNAMICS","text":"Uses ferror iso_fortran_env ieee_arithmetic nonlin_polynomials diffeq dynamics_error_handling Contents Interfaces operator(*) ss_excitation Derived Types state_space transfer_function Functions lti_solve Interfaces public        interface operator(*) private  function tf_tf_mult(x, y) result(rst) Multiplies two transfer functions. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function poly_tf_mult(x, y) result(rst) Multiplies a polynomial and a transfer function to result in a new\ntransfer function. Arguments Type Intent Optional Attributes Name class(polynomial), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function tf_poly_mult(x, y) result(rst) Multiplies a transfer function and a polynomial to result in a new\ntransfer function. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. class(polynomial), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function tf_scalar_mult(x, y) result(rst) Multiplies a transfer function by a scalar value. Arguments Type Intent Optional Attributes Name class( transfer_function ), intent(in) :: x The left-hand-side argument. real(kind=real64), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. private  function scalar_tf_mult(x, y) result(rst) Multiplies a transfer function by a scalar value. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x The left-hand-side argument. class( transfer_function ), intent(in) :: y The right-hand-side argument. Return Value type( transfer_function ) The resulting transfer function. interface public  subroutine ss_excitation(t, u, args) A routine for computing the excitation vector for a state-space\nmodel. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The time value at which to compute the excitation. real(kind=real64), intent(out), dimension(:) :: u The excitation vector. class(*), intent(inout), optional :: args An optional argument used to pass objects in and out of the\nroutine. Derived Types type, public :: state_space Defines a state-space representation of a dynamic system.  This\nimplementation takes the form: Read more… Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:,:) :: A The N-by-N dynamics matrix, where N is the number of state\nvariables. real(kind=real64), public, allocatable, dimension(:,:) :: B The N-by-M input matrix, where M is the number of inputs. real(kind=real64), public, allocatable, dimension(:,:) :: C The P-by-N output matrix, where P is the number of outputs. real(kind=real64), public, allocatable, dimension(:,:) :: D The P-by-M feedthrough matrix. type, public :: transfer_function Defines a transfer function for a continuous system of the form . Components Type Visibility Attributes Name Initial type(polynomial), public :: X The denominator polynomial in .  The polynomial coefficients\nare stored in acending order such that . type(polynomial), public :: Y The numerator polynomial in .  The polynomial coefficients\nare stored in acending order such that . Type-Bound Procedures generic,\n                  public\n                  :: evaluate =>\n                    tf_eval_omega, tf_eval_s generic,\n                  public\n                  :: initialize =>\n                    tf_init_poly, tf_init_array procedure\n                    ,                  public\n                  :: poles =>\n                    tf_poles Function procedure\n                    ,                  public\n                  :: to_ccf_state_space =>\n                    tf_to_ccf_statespace Function procedure\n                    ,                  public\n                  :: to_ocf_state_space =>\n                    tf_to_ocf_statespace Function procedure\n                    ,                  public\n                  :: zeros =>\n                    tf_zeros Function Functions public  function lti_solve (mdl, u, t, ic, solver, args, err) result(rst) Solves the LTI system given by the specified state space model. Arguments Type Intent Optional Attributes Name class( state_space ), intent(in) :: mdl The state_space model to solve. procedure( ss_excitation ), intent(in), pointer :: u The routine used to compute the excitation vector. real(kind=real64), intent(in), dimension(:) :: t The time points at which to compute the solution.  The array must\nhave at least 2 values; however, more may be specified.  If only\n2 values are specified, the integrator will compute the solution at\nthose points, but it will also return any intermediate integration\nsteps that may be required.  However, if more than 2 points are\ngiven, the integrator will return the solution values only at the\nspecified time points. real(kind=real64), intent(in), dimension(:) :: ic The initial condition vector.  This array must be the same size as\nthe number of state variables. class(ode_integrator), intent(in), optional, target :: solver The ODE solver to utilize.  If not specified, the default solver\nis a 4th/5th order Runge-Kutta integrator. class(*), intent(inout), optional :: args An optional container for arguments to pass to the excitation\nroutine. class(errors), intent(inout), optional, target :: err An error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The solution.  The time points at which the solution was evaluated\nare stored in the first column and the output(s) are stored in the\nremaining column(s).","tags":"","loc":"module\\dynamics_controls.html"},{"title":"dynamics_error_handling – DYNAMICS","text":"Uses fstats_errors diffeq_errors iso_fortran_env ferror Contents Variables DYN_ARRAY_SIZE_ERROR DYN_CONSTRAINT_ERROR DYN_INDEX_OUT_OF_RANGE DYN_INVALID_INPUT_ERROR DYN_MATRIX_SIZE_ERROR DYN_MEMORY_ERROR DYN_NONMONOTONIC_ARRAY_ERROR DYN_NULL_POINTER_ERROR DYN_TOLERANCE_TOO_SMALL_ERROR DYN_TOO_FEW_ITERATIONS_ERROR DYN_UNDERDEFINED_PROBLEM_EROR DYN_ZERO_VALUED_FREQUENCY_ERROR Subroutines report_array_index_out_of_bounds_error report_array_size_error report_constraint_count_error report_generic_counting_error report_matrix_size_error report_matrix_size_mismatch_error report_memory_error report_nonmonotonic_array_error report_nonsquare_mass_matrix_error report_nonsquare_matrix_error report_nonsquare_stiffness_matrix_error report_null_forcing_routine_error report_overconstraint_error report_zero_difference_error report_zero_valued_frequency_error Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DYN_ARRAY_SIZE_ERROR = 100105 Defines an error for an improperly sized array. integer(kind=int32), public, parameter :: DYN_CONSTRAINT_ERROR = 100102 Defines a constraint-related error. integer(kind=int32), public, parameter :: DYN_INDEX_OUT_OF_RANGE = 100103 Defines an index out of range error. integer(kind=int32), public, parameter :: DYN_INVALID_INPUT_ERROR = DIFFEQ_INVALID_INPUT_ERROR Defines an error associated with an invalid input. integer(kind=int32), public, parameter :: DYN_MATRIX_SIZE_ERROR = 100100 Defines an error associated with an incorrectly sized matrix. integer(kind=int32), public, parameter :: DYN_MEMORY_ERROR = DIFFEQ_MEMORY_ALLOCATION_ERROR Defines an error associated with memory allocations. integer(kind=int32), public, parameter :: DYN_NONMONOTONIC_ARRAY_ERROR = 100104 Defines an error related to an array being nonmonotonic. integer(kind=int32), public, parameter :: DYN_NULL_POINTER_ERROR = DIFFEQ_NULL_POINTER_ERROR Defines an error associated with a null pointer. integer(kind=int32), public, parameter :: DYN_TOLERANCE_TOO_SMALL_ERROR = FS_TOLERANCE_TOO_SMALL_ERROR Defines an error related to the request of a too small tolerance \nvalue. integer(kind=int32), public, parameter :: DYN_TOO_FEW_ITERATIONS_ERROR = FS_TOO_FEW_ITERATION_ERROR Defines an error when too few iterations were allowed. integer(kind=int32), public, parameter :: DYN_UNDERDEFINED_PROBLEM_EROR = FS_UNDERDEFINED_PROBLEM_ERROR Defines an error for an underdefined problem. integer(kind=int32), public, parameter :: DYN_ZERO_VALUED_FREQUENCY_ERROR = 100101 Defines an error associated with a zero-valued frequency. Subroutines public  subroutine report_array_index_out_of_bounds_error (name, var, ind, sz, err) Reports an array index-out-of-bounds error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: ind The offending index. integer(kind=int32), intent(in) :: sz The array size. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_array_size_error (name, var, expected, actual, err) Reports an array size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: expected The expected array size. integer(kind=int32), intent(in) :: actual The actual array size. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_constraint_count_error (name, expected, actual, err) Reports an error associated with an incorrect number of constraints. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: expected The expected number of constraints. integer(kind=int32), intent(in) :: actual The actual number of constraints. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_generic_counting_error (name, str1, val, str2, flag, err) A generic error reporting routine. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: str1 The first string. integer(kind=int32), intent(in) :: val The integer value. character(len=*), intent(in) :: str2 The second string. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_matrix_size_error (name, var, expect_rows, expect_cols, actual_rows, actual_cols, err) Reports a matrix size error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: expect_rows The expected number of rows. integer(kind=int32), intent(in) :: expect_cols The expected number of columns. integer(kind=int32), intent(in) :: actual_rows The actual number of rows. integer(kind=int32), intent(in) :: actual_cols The actual number of columns. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_matrix_size_mismatch_error (name, mtx1, mtx2, m1, n1, m2, n2, err) Reports a mismatch in matrix sizes. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: mtx1 The name of the first matrix. character(len=*), intent(in) :: mtx2 The name of the second matrix. integer(kind=int32), intent(in) :: m1 The number of rows in the first matrix. integer(kind=int32), intent(in) :: n1 The number of columns in the first matrix. integer(kind=int32), intent(in) :: m2 The number of rows in the second matrix. integer(kind=int32), intent(in) :: n2 The number of columns in the second matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_memory_error (name, flag, err) Reports a memory allocation error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: flag The flag returned from the allocate statement. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonmonotonic_array_error (name, var, ind, err) Reports a nonmonotonic array error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: ind The index of the occurrence of nonmonotonicity. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonsquare_mass_matrix_error (name, m, n, err) Reports an error relating to a non-square mass matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the mass matrix. integer(kind=int32), intent(in) :: n The number of columns found in the mass matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonsquare_matrix_error (name, var, m, n, err) Reports an error relating to a non-square matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var The name of the offending variable. integer(kind=int32), intent(in) :: m The number of rows found in the matrix. integer(kind=int32), intent(in) :: n The number of columns found in the matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_nonsquare_stiffness_matrix_error (name, m, n, err) Reports an error relating to a non-square stiffness matrix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: m The number of rows found in the stiffness matrix. integer(kind=int32), intent(in) :: n The number of columns found in the stiffness matrix. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_null_forcing_routine_error (name, err) Reports a null forcing routine pointer error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_overconstraint_error (name, err) Reports an overconstraint error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_zero_difference_error (name, var1, val1, var2, val2, flag, err) Reports a zero-difference between two variables where a non-zero\ndifference was expected. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. character(len=*), intent(in) :: var1 The name of the first variable. real(kind=real64), intent(in) :: val1 The value of the first variable. character(len=*), intent(in) :: var2 The name of the second variable. real(kind=real64), intent(in) :: val2 The value of the second variable. integer(kind=int32), intent(in) :: flag The error flag. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. public  subroutine report_zero_valued_frequency_error (name, index, err) Reports an error associated with a zero-valued frequency value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name The name of the routine in which the error was found. integer(kind=int32), intent(in) :: index The array index at which the zero-valued frequency was found. class(errors), intent(inout) :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution.","tags":"","loc":"module\\dynamics_error_handling.html"},{"title":"dynamics_frequency_response – DYNAMICS","text":"Uses fstats ferror iso_fortran_env diffeq dynamics_error_handling spectrum Contents Variables FRF_ACCELERANCE_MODEL FRF_RECEPTANCE_MODEL Interfaces evaluate_accelerance_frf_model evaluate_receptance_frf_model frequency_response frequency_sweep harmonic_ode modal_excite ode_excite Derived Types frf mimo_frf Functions chirp compute_modal_damping fit_frf Subroutines modal_response normalize_mode_shapes Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: FRF_ACCELERANCE_MODEL = 1 Defines an accelerance frequency response model. integer(kind=int32), public, parameter :: FRF_RECEPTANCE_MODEL = 2 Defines a receptance frequency response model. Interfaces public        interface evaluate_accelerance_frf_model private pure function evaluate_accelerance_frf_model_scalar(mdl, w) result(rst) Evaluates the specified accelerance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64) The resulting frequency response function. private pure function evaluate_accelerance_frf_model_array(mdl, w) result(rst) Evaluates the specified accelerance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in), dimension(:) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64), allocatable, dimension(:) The resulting frequency response function. public        interface evaluate_receptance_frf_model private pure function evaluate_receptance_frf_model_scalar(mdl, w) result(rst) Evaluates the specified receptance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64) The resulting frequency response function. private pure function evaluate_receptance_frf_model_array(mdl, w) result(rst) Evaluates the specified receptance FRF model.  The model is of\nthe following form. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: mdl The model parameter array.  The elements of the array are stored\nas . real(kind=real64), intent(in), dimension(:) :: w The frequency value, in rad/s, at which to evaluate the model. Return Value complex(kind=real64), allocatable, dimension(:) The resulting frequency response function. public        interface frequency_response Computes the frequency response functions for a system of ODE's. private  function frf_modal_prop_damp(mass, stiff, alpha, beta, freq, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . real(kind=real64), intent(in), dimension(:) :: freq An M-element array of frequency values at which to evaluate the\nfrequency response functions, in units of rad/s. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function frf_modal_prop_damp_2(mass, stiff, alpha, beta, nfreq, freq1, freq2, frc, modes, modeshapes, err) result(rst) Computes the frequency response functions for a \nmulti-degree-of-freedom system that uses proportional damping such\nthat the damping matrix is related to the stiffness an mass\nmatrices by proportional damping coefficients and by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency, in units of rad/s. real(kind=real64), intent(in) :: freq2 The ending frequency, in units of rad/s. procedure( modal_excite ), intent(in), pointer :: frc A pointer to a routine used to compute the modal forcing \nfunction. real(kind=real64), intent(out), optional, allocatable, dimension(:) :: modes An optional N-element allocatable array that, if supplied, will\nbe used to retrieve the modal frequencies, in units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional N-by-N allocatable matrix that, if supplied, will be\nused to retrieve the N mode shapes with each vector occupying\nits own column. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices\n     are not square, or if the mass and stiffness matrices are\n     different sized. DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer\n     is undefined. Return Value type( frf ) The resulting frequency responses. private  function siso_freqres(x, y, fs, win, method, err) result(rst) Estimates the frequency response of a single-input, single-output (SISO)\nsystem. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the excitation signal. real(kind=real64), intent(in), dimension(:) :: y An N-element array containing the response signal. real(kind=real64), intent(in) :: fs The sampling frequency, in Hz. class(window), intent(in), optional, target :: win The window to apply to the data.  If nothing is supplied, no window\nis applied. integer(kind=int32), intent(in), optional :: method Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an\nH2 estimator.  The default is an H1 estimator. An H1 estimator is defined as the cross-spectrum of the input and\nresponse signals divided by the energy spectral density of the input.\nAn H2 estimator is defined as the energy spectral density of the\nresponse divided by the cross-spectrum of the input and response\nsignals. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_ARRAY_SIZE_ERROR: Occurs if x and y are not the same size. Return Value type( frf ) The resulting frequency response function. private  function mimo_freqres(x, y, fs, win, method, err) result(rst) Estimates the frequency responses of a multiple-input, multiple-output\n(MIMO) system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x An N-by-P array containing the P inputs to the system. real(kind=real64), intent(in), dimension(:,:) :: y An N-by-M array containing the M outputs from the system. real(kind=real64), intent(in) :: fs The sampling frequency, in Hz. class(window), intent(in), optional, target :: win The window to apply to the data.  If nothing is supplied, no window\nis applied. integer(kind=int32), intent(in), optional :: method Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an\nH2 estimator.  The default is an H1 estimator. An H1 estimator is defined as the cross-spectrum of the input and\nresponse signals divided by the energy spectral density of the input.\nAn H2 estimator is defined as the energy spectral density of the\nresponse divided by the cross-spectrum of the input and response\nsignals. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_ARRAY_SIZE_ERROR: Occurs if x and y do not have the same number\n  of rows. Return Value type( mimo_frf ) The resulting frequency response functions. public        interface frequency_sweep private  function frf_sweep_1(fcn, freq, iv, solver, ncycles, ntransient, points, args, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name procedure( harmonic_ode ), intent(in), pointer :: fcn A pointer to the routine containing the ODE's to integrate. real(kind=real64), intent(in), dimension(:) :: freq An M-element array containing the frequency points at which the \nsolution should be computed.  Notice, whatever units are utilized\nfor this array are also the units of the excitation_frequency\nproperty in @p sys.  It is recommended that the units be set to \nHz.  Additionally, this array cannot contain any zero-valued \nelements as the ODE solution time for each frequency is \ndetermined by the period of oscillation and number of cycles. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(*), intent(inout), optional :: args An optional argument allowing for passing of data in/out of the\nfcn subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses. private  function frf_sweep_2(fcn, nfreq, freq1, freq2, iv, solver, ncycles, ntransient, points, args, err) result(rst) Computes the frequency response of each equation of a system of\nharmonically excited ODE's by sweeping through frequency. Arguments Type Intent Optional Attributes Name procedure( harmonic_ode ), intent(in), pointer :: fcn A pointer to the routine containing the ODE's to integrate. integer(kind=int32), intent(in) :: nfreq The number of frequency values to analyze.  This value must be\nat least 2. real(kind=real64), intent(in) :: freq1 The starting frequency.  It is recommended that the units be set\nto Hz. real(kind=real64), intent(in) :: freq2 The ending frequency.  It is recommended that the units be set to\nHz. real(kind=real64), intent(in), dimension(:) :: iv An N-element array containing the initial conditions for each of \nthe N ODEs. class(ode_integrator), intent(inout), optional, target :: solver An optional differential equation solver.  The default solver\nis the Dormand-Prince Runge-Kutta integrator from the DIFFEQ\nlibrary. integer(kind=int32), intent(in), optional :: ncycles An optional parameter controlling the number of cycles to \nanalyze when determining the amplitude and phase of the response.\nThe default is 20. integer(kind=int32), intent(in), optional :: ntransient An optional parameter controlling how many of the initial \n\"transient\" cycles to ignore.  The default is 200. integer(kind=int32), intent(in), optional :: points An optional parameter controlling how many evenly spaced \nsolution points should be considered per cycle.  The default is \n1000.  Notice, there must be at least 2 points per cycle for the\nanalysis to be effective.  The algorithm utilizes a discrete \nFourier transform to determine the phase and amplitude, and in \norder to satisfy Nyquist conditions, the value must be at least \n2. class(*), intent(inout), optional :: args An optional argument allowing for passing of data in/out of the\nfcn subroutine. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter\n     is given. DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued \n     frequency was supplied. Return Value type( frf ) The resulting frequency responses. interface public pure subroutine harmonic_ode(freq, t, x, dxdt, args) Defines a system of ODE's exposed to harmonic excitation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency. real(kind=real64), intent(in) :: t The current time step value. real(kind=real64), intent(in), dimension(:) :: x The value of the solution estimate at time t. real(kind=real64), intent(out), dimension(:) :: dxdt The derivatives as computed by this routine. class(*), intent(inout), optional :: args An optional argument allowing the passing of data in/out of\nthis routine. interface public  subroutine modal_excite(freq, frc) Defines the interface to a routine for defining the forcing\nfunction for a modal frequency analysis. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: freq The excitation frequency.  When used as a part of a frequency\nresponse calculation, this value will have the same units as\nthe frequency values provided to the frequency response\nroutine. complex(kind=real64), intent(out), dimension(:) :: frc An N-element array where the forcing function should be\nwritten. interface public  function ode_excite(t) result(rst) Defines the interface for a ODE excitation function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate\nthe excitation function. Return Value real(kind=real64) The result. Derived Types type, public :: frf A container for a frequency response function, or series of frequency\nresponse functions. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency An N-element array containing the frequency values at which the \nFRF is provided.  The units of this array are the same as the\nunits of the frequency values passed to the routine used to \ncompute the frequency response. complex(kind=real64), public, allocatable, dimension(:,:) :: responses An N-by-M matrix containing the M frequency response functions\nevaluated at each of the N frequency points. type, public :: mimo_frf A container for the frequency responses of a system of multiple \ninputs and multiple outputs (MIMO). Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: frequency An N-element array containing the frequency values at which the \nFRF is provided.  The units of this array are the same as the\nunits of the frequency values passed to the routine used to \ncompute the frequency response. complex(kind=real64), public, allocatable, dimension(:,:,:) :: responses An N-by-M-by-P array containing the frequency response functions\nfor each of the M outputs corresponding to each of the P inputs. Functions public pure elemental function chirp (t, amp, span, f1Hz, f2Hz) result(rst) Evaluates a linear chirp function. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: t The value of the independent variable at which to evaluate the \nchirp. real(kind=real64), intent(in) :: amp The amplitude. real(kind=real64), intent(in) :: span The duration of the time it takes to sweep from the start \nfrequency to the end frequency. real(kind=real64), intent(in) :: f1Hz The lower excitation frequency, in Hz. real(kind=real64), intent(in) :: f2Hz The upper excitation frequency, in Hz. Return Value real(kind=real64) The value of the function at t. public pure elemental function compute_modal_damping (lambda, alpha, beta) result(rst) Computes the modal damping factors given the\nproportional damping terms and where , , and is the eigenvalue of the system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: lambda The square of the modal frequency - the eigen value. real(kind=real64), intent(in) :: alpha The mass damping factor, . real(kind=real64), intent(in) :: beta The stiffness damping factor, . Return Value real(kind=real64) The modal damping parameter. public  function fit_frf (mt, n, freq, rsp, maxp, minp, init, stats, alpha, controls, settings, info, err) result(rst) Fits an experimentally obtained frequency response by model for either a\nreceptance model: Read more… Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: mt The excitation method.  The options are as follows. Read more… integer(kind=int32), intent(in) :: n The model order (# of resonant modes). real(kind=real64), intent(in), dimension(:) :: freq An M-element array containing the excitation frequency values in \nunits of rad/s. complex(kind=real64), intent(in), dimension(:) :: rsp An M-element array containing the frequency response to fit. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional 3*N-element array that can be used as upper limits on \nthe parameter values. If no upper limit is requested for a particular\nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional 3*N-element array that can be used as lower limits on \nthe parameter values. If no lower limit is requested for a particalar\nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: init An optional 3 N-element array that, if supplied, provides an initial\nguess for each of the 3 N model parameters for the iterative solver.\nIf supplied, this array replaces the peak finding algorithm for\nestimating an initial guess. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional 3*N-element array that, if supplied, will be used to\nreturn statistics about the fit for each model parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence intervals.\nThe default value is 0.05 such that a 95% confidence interval is \ncalculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. class(errors), intent(inout), optional, target :: err An optional errors-based object that if provided \ncan be used to retrieve information relating to any errors \nencountered during execution. If not provided, a default \nimplementation of the errors class is used internally to provide \nerror handling. Possible errors and warning messages that may be \nencountered are as follows. Read more… Return Value real(kind=real64), allocatable, dimension(:) An array containing the model parameters stored as . Subroutines public  subroutine modal_response (mass, stiff, freqs, modeshapes, err) Computes the modal frequencies and modes shapes for \nmulti-degree-of-freedom system. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: mass The N-by-N mass matrix for the system.  This matrix must be\nsymmetric. real(kind=real64), intent(in), dimension(:,:) :: stiff The N-by-N stiffness matrix for the system.  This matrix must\nbe symmetric. real(kind=real64), intent(out), allocatable, dimension(:) :: freqs An allocatable N-element array where the modal frequencies will\nbe returned in ascending order with units of rad/s. real(kind=real64), intent(out), optional, allocatable, dimension(:,:) :: modeshapes An optional, allocatable N-by-N matrix where the N mode shapes\nfor the system will be returned.  The mode shapes are stored in\ncolumns. class(errors), intent(inout), optional, target :: err public  subroutine normalize_mode_shapes (x) Normalizes mode shape vectors such that the largest magnitude\nvalue in the vector is one. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(inout), dimension(:,:) :: x The matrix of mode shape vectors with one vector per column.","tags":"","loc":"module\\dynamics_frequency_response.html"},{"title":"dynamics_helper – DYNAMICS","text":"Uses iso_fortran_env Contents Functions cross_product to_skew_symmetric Functions public pure function cross_product (x, y) result(rst) Computes the cross-product of a vector. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) The left-hand-side argument. real(kind=real64), intent(in) :: y (3) The right-hand-side argument Return Value real(kind=real64), (3) The resulting vector. public pure function to_skew_symmetric (x) result(rst) Converts a 3-element vector to a 3-by-3 skew-symmetric matrix.  A \nskew-symmetric matrix is defined as follows. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x (3) The vector. Return Value real(kind=real64), (3,3) The resulting skew-symmetric matrix.","tags":"","loc":"module\\dynamics_helper.html"},{"title":"dynamics_kinematics – DYNAMICS","text":"Uses nonlin_core ferror nonlin_least_squares iso_fortran_env dynamics_helper dynamics_error_handling Contents Variables PRISMATIC_JOINT REVOLUTE_JOINT Interfaces dh_forward_kinematics dh_jacobian Functions dh_matrix dh_rotate_x dh_rotate_z dh_translate_x dh_translate_z identity_4 jacobian_generating_vector solve_inverse_kinematics Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: PRISMATIC_JOINT = 1 Defines a prismatic joint. integer(kind=int32), public, parameter :: REVOLUTE_JOINT = 0 Defines a revolute joint. Interfaces public        interface dh_forward_kinematics private pure function dh_forward_kinematics_2(T1, T2) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_3(T1, T2, T3) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_4(T1, T2, T3, T4) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_5(T1, T2, T3, T4, T5) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_6(T1, T2, T3, T4, T5, T6) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_7(T1, T2, T3, T4, T5, T6, T7) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. real(kind=real64), intent(in) :: T7 (4,4) The transformation matrix for the seventh link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_8(T1, T2, T3, T4, T5, T6, T7, T8) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: T1 (4,4) The transformation matrix for the first link nearest ground in\nthe linkage. real(kind=real64), intent(in) :: T2 (4,4) The transformation matrix for the second link in the linkage. real(kind=real64), intent(in) :: T3 (4,4) The transformation matrix for the third link in the linkage. real(kind=real64), intent(in) :: T4 (4,4) The transformation matrix for the fourth link in the linkage. real(kind=real64), intent(in) :: T5 (4,4) The transformation matrix for the fifth link in the linkage. real(kind=real64), intent(in) :: T6 (4,4) The transformation matrix for the sixth link in the linkage. real(kind=real64), intent(in) :: T7 (4,4) The transformation matrix for the seventh link in the linkage. real(kind=real64), intent(in) :: T8 (4,4) The transformation matrix for the eigth link in the linkage. Return Value real(kind=real64), (4,4) The resulting transformation matrix. private pure function dh_forward_kinematics_array(alpha, a, theta, d) result(rst) Assembles all of the individual link transformation matrices into a \nsingle transformation matrix locating the end-effector in the parent\ncoordinate system for the overall mechanism.  The first entry must\nbe from the first link nearest ground. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: alpha The link twist angles, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: a The link lengths as measured along the link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: theta The joint angles, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: d The joint offsets distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. Return Value real(kind=real64), (4,4) The resulting 4-by-4 transformation matrix. public        interface dh_jacobian private  function dh_build_jacobian(alpha, a, theta, d, jtypes) result(rst) Builds the Jacobian matrix for a linkage given the Denavit-Hartenberg\nparameters.  The first entry in each array must be from the first link\nnearest ground.  The Jacobian matrix relates the joint velocities to the end-effector velocity by . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: alpha The link twist angles, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: a The link lengths as measured along the link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: theta The joint angles, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in), dimension(size(alpha)) :: d The joint offsets distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. integer(kind=int32), intent(in), dimension(size(alpha)) :: jtypes The types of each joint.  Must be either REVOLUTE_JOINT or\nPRISMATIC_JOINT.  The code defaults to REVOLUTE_JOINT. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting 6-by-N Jacobian matrix where N is the number of joint\nvariables (i.e. the length of the input arrays). Functions public pure function dh_matrix (alpha, a, theta, d) result(rst) Computes the Denavit-Hartenberg transformation matrix for the \nspecified DH parameters. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The link twist angle, in radians.  This angle is the required\nrotation of the z(i-1) axis about the link's x-axis to become\nparallel with the link's z-axis. real(kind=real64), intent(in) :: a The link length as measured along the link's x-axis. real(kind=real64), intent(in) :: theta The joint angle, in radians.  This angle is the required rotation\nof the z(i-1) axis about the z(i-1) axis to become parallel with\nthe link's x-axis. real(kind=real64), intent(in) :: d The joint offset distance measured as the distance between the\nx(i-1) axis and the link's x-axis along the z(i-1) axis. Return Value real(kind=real64), (4,4) The resulting 4-by-4 transformation matrix. public pure function dh_rotate_x (alpha) result(rst) Computes the Denavit-Hartenberg matrix for a local x-axis rotation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha The rotation angle, in radians. Return Value real(kind=real64), (4,4) The matrix. public pure function dh_rotate_z (theta) result(rst) Computes the Denavit-Hartenberg matrix for a local z-axis rotation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: theta The rotation angle, in radians. Return Value real(kind=real64), (4,4) The matrix. public pure function dh_translate_x (a) result(rst) Computes the Denavit-Hartenberg matrix for a local x-axis \ntranslation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: a The translation. Return Value real(kind=real64), (4,4) The matrix. public pure function dh_translate_z (d) result(rst) Computes the Denavit-Hartenberg matrix for a local z-axis \ntranslation. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: d The translation. Return Value real(kind=real64), (4,4) The matrix. public pure function identity_4 () result(rst) Computes a 4-by-4 identity matrix. Arguments None Return Value real(kind=real64), (4,4) The resulting identity matrix. public pure function jacobian_generating_vector (d, k, R, jtype) result(rst) Computes a single Jacobian generating vector given the position vector\nof the link origin, , and the joint axis unit vector, . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: d (3) The position vector of the end-effector, , relative to the\nlink coordinate frame given in the base coordinate frame.  An easy\nway to compute this vector is to extract the first 3 elements of the\n4th column of the transformation matrix: . real(kind=real64), intent(in) :: k (3) The unit vector defining the joint axis, , given in the\nbase coordinate frame.  This vector can be computed most easily by\nusing the transformation matrix: and\nthen computing . real(kind=real64), intent(in) :: R (3,3) The rotation matrix defining the orientation of the link coordinate\nframe relative to the base coordinate frame. integer(kind=int32), intent(in) :: jtype The joint type.  Must be either REVOLUTE_JOINT or PRISMATIC_JOINT.\nIf incorrectly specified, the code defaults to a REVOLUTE_JOINT type. Return Value real(kind=real64), (6) The resulting 6-element Jacobian generating vector. public  function solve_inverse_kinematics (mdl, qo, constraints, df, slvr, ib, err) result(rst) Solves the inverse kinematics problem for a linkage.  An iterative\nsolution procedure is utilized. Arguments Type Intent Optional Attributes Name procedure(vecfcn), intent(in), pointer :: mdl A routine used to compute the error in the kinematics \nequations based upon the current solution estimate. real(kind=real64), intent(in), dimension(:) :: qo An M-element array containing an initial estimate of the M joint\nvariables. real(kind=real64), intent(in), target, dimension(:) :: constraints An N-element array containing the target values (constraints) for\neach of the N kinematic equations in the model.  N must be at \nleast equal to M (the number of joint variables). real(kind=real64), intent(out), optional, target, dimension(:) :: df An optional N-element array that, if supplied, can be used to \nretrieve the residuals of each of the N kinematic equations. class(least_squares_solver), intent(inout), optional, target :: slvr An optional solver that can be used in place of the default\nLevenberg-Marquardt solver. type(iteration_behavior), intent(out), optional :: ib An optional output that can be used to gather information on the\nsolver. class(errors), intent(inout), optional, target :: err An errors-based object that if provided can be used to retrieve \ninformation relating to any errors encountered during execution. Return Value real(kind=real64), allocatable, dimension(:) An M-element array containing the computed joint variables.","tags":"","loc":"module\\dynamics_kinematics.html"},{"title":"dynamics_rotation – DYNAMICS","text":"Uses dynamics_helper iso_fortran_env Contents Interfaces rotate Functions acceleration_transform rotate_x rotate_y rotate_z velocity_transform Interfaces public        interface rotate private pure function rotate_general_1(i, j, k, Ip, Jp, Kp) result(rst) Constructs a rotation matrix when the orientation of the coordinate\nframe of interest is known relative to the parent coordinate frame. The matrix is of the following form. This routine does not check for orthogonallity or unit vector length;\ntherefore, to ensure correct results it is the callers responsibility\nto ensure each vector is of unit length and that the unit vectors\nare properly orthogonal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: i (3) The rotated coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: j (3) The rotated coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: k (3) The rotated coordinate frame z-axis unit vector. real(kind=real64), intent(in) :: Ip (3) The parent coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: Jp (3) The parent coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: Kp (3) The parent coordinate frame z-axis unit vector. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. private pure function rotate_general_2(i, j, k) result(rst) Constructs a rotation matrix when the orientation of the coordinate\nframe of interest is known relative to the parent coordinate frame. The matrix is of the following form. The parent coordinate frame is assumed to be as follows. This routine does not check for orthogonallity or unit vector length;\ntherefore, to ensure correct results it is the callers responsibility\nto ensure each vector is of unit length and that the unit vectors\nare properly orthogonal. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: i (3) The rotated coordinate frame x-axis unit vector. real(kind=real64), intent(in) :: j (3) The rotated coordinate frame y-axis unit vector. real(kind=real64), intent(in) :: k (3) The rotated coordinate frame z-axis unit vector. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. Functions public pure function acceleration_transform (alpha, omega, a, x) result(rst) Computes the acceleration transformation matrix relating the\nposition of a point expressed in a rotating and translating body\nrelative to its parent frame. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: alpha (3) The angular acceleration vector. real(kind=real64), intent(in) :: omega (3) The angular velocity vector. real(kind=real64), intent(in) :: a (3) The translational acceleration vector describing the acceleration\nof the body in its parent coordinate frame. real(kind=real64), intent(in) :: x (3) The position vector of the body in its parent coordinate frame. Return Value real(kind=real64), (4,4) The 4-by-4 transformation matrix. public pure function rotate_x (angle) result(rst) Constructs the rotation matrix describing a rotation about an\nx-axis such that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. public pure function rotate_y (angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. public pure function rotate_z (angle) result(rst) Constructs the rotation matrix describing a rotation about a y-axis\nsuch that . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: angle The rotation angle, in radians. Return Value real(kind=real64), (3,3) The resulting 3-by-3 matrix. public pure function velocity_transform (omega, v, x) result(rst) Computes the velocity transformation matrix relating the position\nof a point expressed in a rotating and translating body relative to\nits parent frame. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: omega (3) The angular velocity vector. real(kind=real64), intent(in) :: v (3) The translation velocity vector describing the velocity of the\nbody in its parent coordinate frame. real(kind=real64), intent(in) :: x (3) The position vector of the body in its parent coordinate frame. Return Value real(kind=real64), (4,4) The 4-by-4 transformation matrix.","tags":"","loc":"module\\dynamics_rotation.html"},{"title":"dynamics_stability – DYNAMICS","text":"Uses linalg dynamics_error_handling iso_fortran_env ferror Contents Variables HYPERBOLIC_FIXED_POINT_SADDLE HYPERBOLIC_FIXED_POINT_SINK HYPERBOLIC_FIXED_POINT_SOURCE NONHYPERBOLIC_FIXED_POINT_CENTER NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE NONHYPERBOLIC_FIXED_POINT_UNSTABLE Functions determine_local_stability Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: HYPERBOLIC_FIXED_POINT_SADDLE = 102 Describes a hyperbolic fixed point where all of the eigenvalues of\nthe dynamics matrix have a nonzero real part but one or more of the\neigenvalues has a positive-valued real part. integer(kind=int32), public, parameter :: HYPERBOLIC_FIXED_POINT_SINK = 100 Describes a hyperbolic fixed point where all of the eigenvalues of\nthe dynamics matrix have a nonzero real part and all real parts are\nnegative-valued.  This point is considered stable. integer(kind=int32), public, parameter :: HYPERBOLIC_FIXED_POINT_SOURCE = 101 Describes a hyperbolic fixed point where all of the eigenvalues of\nthe dynamics matrix have a nonzero real part and the real\npart is positive-valued for each.  This point is considered unstable. integer(kind=int32), public, parameter :: NONHYPERBOLIC_FIXED_POINT_CENTER = 105 Describes a nonhyperbolic fixed point where all of the eigenvalues\nof the dynamics matrix are purely imaginary and nonzero.  This point\nis considered stable. integer(kind=int32), public, parameter :: NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE = 104 Describes a nonhyperbolic fixed point where some of the eigenvalues \nof the dynamics matrix have negative real parts and the remaining\neigenvalues all have zero-valued real parts. integer(kind=int32), public, parameter :: NONHYPERBOLIC_FIXED_POINT_UNSTABLE = 103 Describes a nonhyperbolic fixed point where one or more of the \neigenvalues of the dynamics matrix have a positive-valued real part. Functions public  function determine_local_stability (a, ev, err) result(rst) Determines the nature of stability/unstability near the point at which\nthe dynamics matrix was computed. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: a An N-by-N matrix containing the 'A' matrix, also known as the\ndynamics matrix. complex(kind=real64), intent(out), optional, dimension(:) :: ev An optional N-element array that, if supplied, will be filled with \nthe eigenvalues of the matrix A. class(errors), intent(inout), optional, target :: err An error handler object. Return Value integer(kind=int32) Describe the output constants","tags":"","loc":"module\\dynamics_stability.html"},{"title":"dynamics_structural – DYNAMICS","text":"Uses ferror iso_fortran_env dynamics_rotation linalg dynamics_error_handling Contents Variables DYN_FOUR_POINT_INTEGRATION_RULE DYN_ONE_POINT_INTEGRATION_RULE DYN_THREE_POINT_INTEGRATION_RULE DYN_TWO_POINT_INTEGRATION_RULE Interfaces apply_boundary_conditions Derived Types beam_element_2d beam_element_3d element line_element material node point Functions create_connectivity_matrix restore_constrained_values shape_function_derivative shape_function_second_derivative Subroutines apply_displacement_constraint Variables Type Visibility Attributes Name Initial integer(kind=int32), public, parameter :: DYN_FOUR_POINT_INTEGRATION_RULE = 4 Defines a four-point integration rule. integer(kind=int32), public, parameter :: DYN_ONE_POINT_INTEGRATION_RULE = 1 Defines a single-point integration rule. integer(kind=int32), public, parameter :: DYN_THREE_POINT_INTEGRATION_RULE = 3 Defines a three-point integration rule. integer(kind=int32), public, parameter :: DYN_TWO_POINT_INTEGRATION_RULE = 2 Defines a two-point integration rule. Interfaces public        interface apply_boundary_conditions private  function apply_boundary_conditions_mtx(gdof, x, err) result(rst) Applies boundary conditions to a matrix by removal of the appropriate\nrows and columns. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:,:) :: x The matrix to constrain. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The altered matrix. private  function apply_boundary_conditions_vec(gdof, x, err) result(rst) Applies boundary conditions to a vector by removal of the appropriate\nitems. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:) :: x The vector to constrain. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:) The altered vector. Derived Types type, public, extends( line_element ) :: beam_element_2d Defines a two-dimensional Bernoulli-Euler beam element. Components Type Visibility Attributes Name Initial real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. real(kind=real64), public :: moment_of_inertia The beam moment of inertia (second moment of area). type( node ), public :: node_1 The first node of the element (s = -1). type( node ), public :: node_2 The second node of the element (s = 1). Type-Bound Procedures procedure\n                    ,                  public\n                  :: constitutive_matrix =>\n                    b2d_constitutive_matrix Function procedure\n                    ,                  public\n                  :: evaluate_shape_function =>\n                    b2d_shape_function Function procedure\n                    ,                  public\n                  :: external_force_vector =>\n                    le_ext_force_vector Function procedure\n                    ,                  public\n                  :: get_dimensionality =>\n                    b2d_dimensionality Function procedure\n                    ,                  public\n                  :: get_dof_per_node =>\n                    b2d_dof_per_node Function procedure\n                    ,                  public\n                  :: get_node =>\n                    b2d_get_node Function procedure\n                    ,                  public\n                  :: get_node_count =>\n                    b2d_get_node_count Function procedure\n                    ,                  public\n                  :: get_terminal_nodes =>\n                    b2d_terminal_nodes Subroutine procedure\n                    ,                  public\n                  :: jacobian =>\n                    b2d_jacobian Function procedure\n                    ,                  public\n                  :: length =>\n                    le_length Function procedure\n                    ,                  public\n                  :: mass_matrix =>\n                    b2d_mass_matrix Function procedure\n                    ,                  public\n                  :: rotation_matrix =>\n                    b2d_rotation_matrix Function procedure\n                    ,                  public\n                  :: shape_function_matrix =>\n                    b2d_shape_function_matrix_2d Function procedure\n                    ,                  public\n                  :: stiffness_matrix =>\n                    b2d_stiffness_matrix Function procedure\n                    ,                  public\n                  :: strain_displacement_matrix =>\n                    b2d_strain_disp_matrix_2d Function type, public, extends( line_element ) :: beam_element_3d Defines a three-dimensional Bernoulli-Euler beam element. Components Type Visibility Attributes Name Initial real(kind=real64), public :: Ixx The beam moment of inertia about the element x-axis. real(kind=real64), public :: Iyy The beam moment of inertia about the element y-axis. real(kind=real64), public :: Izz The beam moment of inertia about the element z-axis. real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. type( node ), public :: node_1 The first node of the element (s = -1). type( node ), public :: node_2 The second node of the element (s = 1). type( point ), public :: orientation_point A point used to determine the orientation of the beam in 3D\nspace.  The orientation point is measured relative to the first\nnode in the element.  Specifically, the element z axis is assumed\nto be defined by the location of this point relative to the\nlocation of node 1. Type-Bound Procedures procedure\n                    ,                  public\n                  :: constitutive_matrix =>\n                    b3d_constitutive_matrix Function procedure\n                    ,                  public\n                  :: evaluate_shape_function =>\n                    b3d_shape_function Function procedure\n                    ,                  public\n                  :: external_force_vector =>\n                    le_ext_force_vector Function procedure\n                    ,                  public\n                  :: get_dimensionality =>\n                    b3d_dimensionality Function procedure\n                    ,                  public\n                  :: get_dof_per_node =>\n                    b3d_dof_per_node Function procedure\n                    ,                  public\n                  :: get_node =>\n                    b3d_get_node Function procedure\n                    ,                  public\n                  :: get_node_count =>\n                    b3d_get_node_count Function procedure\n                    ,                  public\n                  :: get_terminal_nodes =>\n                    b3d_terminal_nodes Subroutine procedure\n                    ,                  public\n                  :: jacobian =>\n                    b3d_jacobian Function procedure\n                    ,                  public\n                  :: length =>\n                    le_length Function procedure\n                    ,                  public\n                  :: mass_matrix =>\n                    b3d_mass_matrix Function procedure\n                    ,                  public\n                  :: rotation_matrix =>\n                    b3d_rotation_matrix Function procedure\n                    ,                  public\n                  :: shape_function_matrix =>\n                    b3d_shape_function_matrix_3d Function procedure\n                    ,                  public\n                  :: stiffness_matrix =>\n                    b3d_stiffness_matrix Function procedure\n                    ,                  public\n                  :: strain_displacement_matrix =>\n                    b3d_strain_disp_matrix_3d Function type, public :: element Defines an element. Components Type Visibility Attributes Name Initial type( material ), public :: material The material. Type-Bound Procedures procedure\n(element_const_matrix_function)                    ,                  public\n, pass                  :: constitutive_matrix procedure\n(element_shape_function)                    ,                  public\n, pass                  :: evaluate_shape_function procedure\n                    ,                  public\n                  :: external_force_vector =>\n                    e_ext_force_vector Function procedure\n(element_query)                    ,                  public\n, pass                  :: get_dimensionality procedure\n(element_query)                    ,                  public\n, pass                  :: get_dof_per_node procedure\n(element_get_node)                    ,                  public\n, pass                  :: get_node procedure\n(element_query)                    ,                  public\n, pass                  :: get_node_count procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: jacobian procedure\n                    ,                  public\n                  :: mass_matrix =>\n                    e_mass_matrix Function procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: shape_function_matrix procedure\n                    ,                  public\n                  :: stiffness_matrix =>\n                    e_stiffness_matrix Function procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: strain_displacement_matrix type, public, extends( element ) :: line_element Defines a line element type. Components Type Visibility Attributes Name Initial real(kind=real64), public :: area The element cross-sectional area. type( material ), public :: material The material. Type-Bound Procedures procedure\n(element_const_matrix_function)                    ,                  public\n, pass                  :: constitutive_matrix procedure\n(element_shape_function)                    ,                  public\n, pass                  :: evaluate_shape_function procedure\n                    ,                  public\n                  :: external_force_vector =>\n                    le_ext_force_vector Function procedure\n(element_query)                    ,                  public\n, pass                  :: get_dimensionality procedure\n(element_query)                    ,                  public\n, pass                  :: get_dof_per_node procedure\n(element_get_node)                    ,                  public\n, pass                  :: get_node procedure\n(element_query)                    ,                  public\n, pass                  :: get_node_count procedure\n(line_element_get_terminal)                    ,                  public\n, pass                  :: get_terminal_nodes procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: jacobian procedure\n                    ,                  public\n                  :: length =>\n                    le_length Function procedure\n                    ,                  public\n                  :: mass_matrix =>\n                    le_mass_matrix Function procedure\n(line_element_const_matrix_function)                    ,                  public\n, pass                  :: rotation_matrix procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: shape_function_matrix procedure\n                    ,                  public\n                  :: stiffness_matrix =>\n                    le_stiffness_matrix Function procedure\n(element_matrix_function)                    ,                  public\n, pass                  :: strain_displacement_matrix type, public :: material Defines a linear-elastic-isotropic material. Components Type Visibility Attributes Name Initial real(kind=real64), public :: density The density of the material. real(kind=real64), public :: modulus The modulus of elasticity of the material. real(kind=real64), public :: poissons_ratio The Poisson's ratio of the material. type, public, extends( point ) :: node Defines a node. Components Type Visibility Attributes Name Initial integer(kind=int32), public :: dof The number of degrees of freeedom associated with this node. integer(kind=int32), public :: index The global index of the node. real(kind=real64), public :: x The x-coordinate. real(kind=real64), public :: y The y-coordinate. real(kind=real64), public :: z The z-coordinate. type, public :: point Defines a point in 3D, Cartesian space. Components Type Visibility Attributes Name Initial real(kind=real64), public :: x The x-coordinate. real(kind=real64), public :: y The y-coordinate. real(kind=real64), public :: z The z-coordinate. Functions public  function create_connectivity_matrix (gdof, e, nodes, err) result(rst) Creates a connectivity matrix for the element. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: gdof The number of global degrees of freedom. class( element ), intent(in) :: e The element. class( node ), intent(in), dimension(:) :: nodes The global node list. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:,:) The resulting matrix. public  function restore_constrained_values (gdof, x, err) result(rst) Restores the constrained degrees-of-freedom from the boundary conditions\napplied by apply_boundary_conditions. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: gdof An array of the global degrees of freedom to restrain.  The array\nis sorted into ascending order on output. real(kind=real64), intent(in), dimension(:) :: x The constrained vector. class(errors), intent(inout), optional, target :: err An optional error handling object. Return Value real(kind=real64), allocatable, dimension(:) The altered vector. public pure function shape_function_derivative (index, elem, s, i) result(rst) Computes the derivative of the shape function with respect to the natural\ncoordinate specified. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: index The index of the shape function to evaluate. class( element ), intent(in) :: elem The element object. real(kind=real64), intent(in), dimension(:) :: s The natural coordinate at which to evaluate the derivative. integer(kind=int32), intent(in) :: i The index of the natural coordinate to with which the derivative is\nto be computed. Return Value real(kind=real64) The result. public pure function shape_function_second_derivative (index, elem, s, i) result(rst) Computes the second derivative of the shape function with respect to the\nnatural coordinate specified. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: index The index of the shape function to evaluate. class( element ), intent(in) :: elem The element object. real(kind=real64), intent(in), dimension(:) :: s The natural coordinate at which to evaluate the derivative. integer(kind=int32), intent(in) :: i The index of the natural coordinate to with which the derivative is\nto be computed. Return Value real(kind=real64) The result. Subroutines public  subroutine apply_displacement_constraint (dof, val, k, f) Applies a displacement constraint to the specified degree of freedom. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: dof The global degree-of-freedom to which the constraint should be\napplied. real(kind=real64), intent(in) :: val The value of the displacement constraint. real(kind=real64), intent(inout), dimension(:,:) :: k The stiffness matrix to which the constraint should be applied. real(kind=real64), intent(inout), dimension(:) :: f The external force vector to which the constraint should be applied.","tags":"","loc":"module\\dynamics_structural.html"},{"title":"dynamics_system_id – DYNAMICS","text":"Uses fstats ferror iso_fortran_env diffeq dynamics_error_handling Contents Interfaces constraint_equations siso_model_fit_least_squares Derived Types dynamic_system_measurement model_information Interfaces interface public  subroutine constraint_equations(xg, fg, xc, p, fc, args) An interface to a set of routines for defining constraint \nequations to the fitting process. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: xg An N-element array containing the N independent variable\nvalues for the N differential equation solution points. real(kind=real64), intent(in), dimension(:) :: fg An N-element array containing the N differential equation\nsolution points. real(kind=real64), intent(in), dimension(:) :: xc An M-element array containing the M independent variable\nvalues for the M constraint equations. real(kind=real64), intent(in), dimension(:) :: p An array containing the model parameters. real(kind=real64), intent(out), dimension(:) :: fc An M-element array where the values of the constraint \nequations should be written. class(*), intent(inout), optional :: args An optional argument that can be used to pass data in/out\nof this routine. public        interface siso_model_fit_least_squares private  subroutine siso_model_fit_least_squares_1(fcn, x, ic, p, integrator, ind, maxp, minp, stats, alpha, controls, settings, info, status, cov, xc, yc, constraints, weights, args, err) Attempts to fit a model of a single-intput, single-output (SISO) dynamic \nsystem by means of an iterative least-squares solver.  The algorithm\ncomputes the solution to the differential equations numerically, and\ncompares the output to the known solution via a Levenberg-Marquardt\nleast-squares solver. Arguments Type Intent Optional Attributes Name procedure(ode), intent(in), pointer :: fcn The routine containing the ODE's being fit.  To communicate \nmodel parameters and other relevant information, an instance of the\n[[model_information]] type is passed to the optional argument of this\nroutine.  Use the \"select type\" construct to access this information. class( dynamic_system_measurement ), intent(in), dimension(:) :: x An M-element array of arrays with each array containing the measured\ninput and output of the system being identified. real(kind=real64), intent(in), dimension(:) :: ic The initial condition vector for the equations in fcn. real(kind=real64), intent(inout), dimension(:) :: p An N-element array containing an initial guess at the parameters. On output, the computed model parameters. class(ode_integrator), intent(inout), optional, target :: integrator The integrator to use when solving the system equations.  If not\nsupplied, the default integrator will be used.  The default \nintegrator is a Runge-Kutta integrator (Dormand-Prince). integer(kind=int32), intent(in), optional :: ind The index of the ODE in fcn providing the output to fit.  If\nno value is supplied, a value of 1 will be utilized. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional N-element array that can be used as upper limits on the \nparameter values. If no upper limit is requested for a particular \nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional N-element array that can be used as lower limits on the \nparameter values. If no lower limit is requested for a particalar \nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional N-element array that, if supplied, will be used to \nreturn statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals. The default value is 0.05 such that a 95% confidence \ninterval is calculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. procedure(iteration_update), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract \niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return \nthe covariance matrix. real(kind=real64), intent(in), optional, dimension(:) :: xc An optional NC-element array containing the values of the independent \nvariable at which the constraint equations are defined. real(kind=real64), intent(in), optional, dimension(:) :: yc An optional NC-element array containing the constraint function \nvalues at xc. procedure( constraint_equations ), optional, pointer :: constraints An optional input, that must be utilized with the xc and yc inputs,\nbut allows for the implementation of additional constraints on the\nsolution outside of the differential equations being fitted.  An\nexample usage would be an additional set of quasi-static tests that\ncould help identify a stiffness term, for instance.  Other uses of\ncourse can be imagined. real(kind=real64), intent(in), optional, dimension(:) :: weights An optional array containing weighting factors for every equation. class(*), intent(inout), optional, target :: args User-defined information to pass along to fcn.  These arguments,\nif supplied, will be passed through to fcn by means of the\n[[model_information]] type. class(errors), intent(inout), optional, target :: err An error handling object. private  subroutine siso_model_fit_least_squares_2(fcn, x, ic, p, integrator, ind, maxp, minp, stats, alpha, controls, settings, info, status, cov, xc, yc, constraints, weights, args, err) Attempts to fit a model of a single-intput, single-output (SISO) dynamic \nsystem by means of an iterative least-squares solver.  The algorithm\ncomputes the solution to the differential equations numerically, and\ncompares the output to the known solution via a Levenberg-Marquardt\nleast-squares solver. Arguments Type Intent Optional Attributes Name procedure(ode), intent(in), pointer :: fcn The routine containing the ODE's being fit.  To communicate \nmodel parameters and other relevant information, an instance of the\n[[model_information]] type is passed to the optional argument of this\nroutine.  Use the \"select type\" construct to access this information. class( dynamic_system_measurement ), intent(in), dimension(:) :: x An M-element array of arrays with each array containing the measured\ninput and output of the system being identified. real(kind=real64), intent(in), dimension(:,:) :: ic An M-by-NEQN matrix of initial condition vectors for the NEQN \nequations in fcn, one set for each of the M sets of data in x. real(kind=real64), intent(inout), dimension(:) :: p An N-element array containing an initial guess at the parameters. On output, the computed model parameters. class(ode_integrator), intent(inout), optional, target :: integrator The integrator to use when solving the system equations.  If not\nsupplied, the default integrator will be used.  The default \nintegrator is a Runge-Kutta integrator (Dormand-Prince). integer(kind=int32), intent(in), optional :: ind The index of the ODE in fcn providing the output to fit.  If\nno value is supplied, a value of 1 will be utilized. real(kind=real64), intent(in), optional, dimension(:) :: maxp An optional N-element array that can be used as upper limits on the \nparameter values. If no upper limit is requested for a particular \nparameter, utilize a very large value. The internal default is to \nutilize huge() as a value. real(kind=real64), intent(in), optional, dimension(:) :: minp An optional N-element array that can be used as lower limits on the \nparameter values. If no lower limit is requested for a particalar \nparameter, utilize a very large magnitude, but negative, value. The \ninternal default is to utilize -huge() as a value. type(regression_statistics), intent(out), optional, dimension(:) :: stats An optional N-element array that, if supplied, will be used to \nreturn statistics about the fit for each parameter. real(kind=real64), intent(in), optional :: alpha The significance level at which to evaluate the confidence \nintervals. The default value is 0.05 such that a 95% confidence \ninterval is calculated. type(iteration_controls), intent(in), optional :: controls An optional input providing custom iteration controls. type(lm_solver_options), intent(in), optional :: settings An optional input providing custom settings for the solver. type(convergence_info), intent(out), optional :: info An optional output that can be used to gain information about the \niterative solution and the nature of the convergence. procedure(iteration_update), intent(in), optional, pointer :: status An optional pointer to a routine that can be used to extract \niteration information. real(kind=real64), intent(out), optional, dimension(:,:) :: cov An optional N-by-N matrix that, if supplied, will be used to return \nthe covariance matrix. real(kind=real64), intent(in), optional, dimension(:) :: xc An optional NC-element array containing the values of the independent \nvariable at which the constraint equations are defined. real(kind=real64), intent(in), optional, dimension(:) :: yc An optional NC-element array containing the constraint function \nvalues at xc. procedure( constraint_equations ), optional, pointer :: constraints An optional input, that must be utilized with the xc and yc inputs,\nbut allows for the implementation of additional constraints on the\nsolution outside of the differential equations being fitted.  An\nexample usage would be an additional set of quasi-static tests that\ncould help identify a stiffness term, for instance.  Other uses of\ncourse can be imagined. real(kind=real64), intent(in), optional, dimension(:) :: weights An optional array containing weighting factors for every equation. class(*), intent(inout), optional, target :: args User-defined information to pass along to fcn.  These arguments,\nif supplied, will be passed through to fcn by means of the\n[[model_information]] type. class(errors), intent(inout), optional, target :: err An error handling object. Derived Types type, public :: dynamic_system_measurement A container of a single measurement data set. Components Type Visibility Attributes Name Initial real(kind=real64), public, allocatable, dimension(:) :: input The input data. real(kind=real64), public, allocatable, dimension(:) :: output The output data. real(kind=real64), public, allocatable, dimension(:) :: t The time points at which the measurements were taken. type, public :: model_information A container for model information. Components Type Visibility Attributes Name Initial class(base_interpolator), public, pointer :: excitation An interpolation object allowing sampling of the excitation \nfunction. real(kind=real64), public, allocatable, dimension(:) :: model An array containing the model parameters. class(*), public, pointer :: user_info Information the user has passed along.","tags":"","loc":"module\\dynamics_system_id.html"},{"title":"dynamics_vibrations – DYNAMICS","text":"Uses ieee_arithmetic peaks iso_fortran_env Contents Functions damping_from_fractional_overshoot damping_from_log_decrement estimate_bandwidth evaluate_step_response find_settling_amplitude logarithmic_decrement q_factor rise_time Subroutines find_free_response_properties Functions public pure function damping_from_fractional_overshoot (x) result(rst) Employs the method of fractional overshoot to estimate the damping ratio\nfrom the response of a system to a step input.  This method is useful\nfor cases where the damping ratio is between approximately 0.5 to 0.8.\nIn such range, the logarithmic decrement approach becomes less precise. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The step response of the system. Return Value real(kind=real64) The estimated damping ratio. public pure elemental function damping_from_log_decrement (delta) result(rst) Computes the damping ratio from the logarithmic decrement .\nThe damping ratio is related to the logarithmic decrement by the \nfollowing relationship. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: delta The logarithmic decrement. Return Value real(kind=real64) The damping ratio. public pure elemental function estimate_bandwidth (fn, zeta) result(rst) Estimates the bandwidth of the resonant mode of a vibratory system.\nThe bandwidth is the width of the range of frequencies for which the\nenergy is at least half its peak value and is computed as . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: fn The resonant frequency.  The units are not important; however, \nthe units of the output will be the same as the units of this\nparameter. real(kind=real64), intent(in) :: zeta The damping ratio. Return Value real(kind=real64) The bandwidth. public pure elemental function evaluate_step_response (wn, zeta, xs, t) result(rst) Evaluates the response of an underdamped single-degree-of-freedom, \nlinear system to a step function of amplitude . Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: wn The resonant frequency, in rad/s. real(kind=real64), intent(in) :: zeta The damping ratio. real(kind=real64), intent(in) :: xs The amplitude of the step input. real(kind=real64), intent(in) :: t The point in time at which to evaluate the response (units = s). Return Value real(kind=real64) The step response. public pure function find_settling_amplitude (x) result(rst) Estimates the settling amplitude for a step response. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x The step response of the system. Return Value real(kind=real64) The settling amplitude of the step response. public pure elemental function logarithmic_decrement (x1, x2, n) result(rst) Computes the logarithmic decrement given the value of two  successive\npeaks in the time history of the free vibratory response of the system.\nThe logarithmic decrement is calculated as follows. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x1 The amplitude of the first peak. real(kind=real64), intent(in) :: x2 The amplitude of the second peak that occurs N periods after the\nfirst. integer(kind=int32), intent(in) :: n The number of periods of oscillation seperating the two peaks. Return Value real(kind=real64) The logarithmic decrement . public pure elemental function q_factor (zeta) result(rst) Estimates the Q-factor for a vibratory system.  The Q-factor is computed . Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: zeta The damping ratio. Return Value real(kind=real64) The Q-factor. public pure elemental function rise_time (wn, zeta) result(rst) Computes the rise time for an underdamped, second-order system.  The\nrise time is the time it takes for the system response to go from 0%\nto 100% of its final value and is given by the following relationship. Read more… Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: wn The resonant frequency of the system, in rad/s. real(kind=real64), intent(in) :: zeta The damping ratio of the system.  This value must be less than 1\nas this relationship is only valid for an underdamped system. Return Value real(kind=real64) The rise time, in units of seconds. Subroutines public  subroutine find_free_response_properties (t, x, delta, fn, x1, x2, t1, t2, s, n) Given a free-response time history, this routine attempts to find the \nlogarithmic decrement and resonant frequency of a vibratory system. The\nlogarithmic decrement is estimated by finding successive peaks by\nmeans of peak detection. Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: t An N-element array containing the values in time real(kind=real64), intent(in), dimension(:) :: x An N-element array containing the response sampled at the time points\ngiven in t. real(kind=real64), intent(out) :: delta The logarithmic decrement estimate.  If sufficient peaks cannot be\nlocated, the routine returns NaN. real(kind=real64), intent(out) :: fn The damped resonant frequency in units of Hz, assuming that the\ntime values are in seconds.  If the time units are not in seconds,\nthe units will be cycle/unit time with unit time being the units\nin which t is supplied.  If sufficient peaks cannot be located, the \nroutine returns NaN. real(kind=real64), intent(out), optional :: x1 An optional parameter that, if provided, allows for the routine to\nreturn the amplitude of the first peak.  If sufficient peaks cannot \nbe located, the routine returns NaN. real(kind=real64), intent(out), optional :: x2 An optional parameter that, if provided, allows for the routine to\nreturn the amplitude of the second peak.  If sufficient peaks cannot \nbe located, the routine returns NaN. real(kind=real64), intent(out), optional :: t1 An optional parameter that, if provided, allows for the routine to\nreturn the time at which the first peak was located.  If sufficient\npeaks cannot be located, the routine returns NaN. real(kind=real64), intent(out), optional :: t2 An optional parameter that, if provided, allows for the routine to\nreturn the time at which the second peak was located.  If sufficient\npeaks cannot be located, the routine returns NaN. real(kind=real64), intent(in), optional :: s An optional input that, if provided, allows for control of the \nsensitivity of the peak detection algorithm.  The default is 0.1%\nof the peak-peak amplitude of the signal. integer(kind=int32), intent(in), optional :: n An optional input that, if provided, determines the number of \nperiods to allow between peak selection for the logarithmic \ndecrement calculation.  The default is 1.","tags":"","loc":"module\\dynamics_vibrations.html"},{"title":"dynamics.f90 – DYNAMICS","text":"Contents Modules dynamics Source Code dynamics.f90 Source Code module dynamics use dynamics_frequency_response use dynamics_rotation use dynamics_structural use dynamics_kinematics use dynamics_vibrations use dynamics_helper use dynamics_stability use dynamics_controls use dynamics_system_id implicit none private ! DYNAMICS_FREQUENCY_RESPONSE public :: ode_excite public :: modal_excite public :: harmonic_ode public :: frf public :: mimo_frf public :: chirp public :: frequency_response public :: frequency_sweep public :: compute_modal_damping public :: modal_response public :: normalize_mode_shapes public :: evaluate_accelerance_frf_model public :: evaluate_receptance_frf_model public :: fit_frf public :: FRF_ACCELERANCE_MODEL public :: FRF_RECEPTANCE_MODEL public :: regression_statistics public :: iteration_controls public :: lm_solver_options public :: convergence_info ! DYNAMICS_ROTATION public :: rotate_x public :: rotate_y public :: rotate_z public :: rotate public :: acceleration_transform public :: velocity_transform ! DYNAMICS_STRUCTURAL public :: DYN_ONE_POINT_INTEGRATION_RULE public :: DYN_TWO_POINT_INTEGRATION_RULE public :: DYN_THREE_POINT_INTEGRATION_RULE public :: DYN_FOUR_POINT_INTEGRATION_RULE public :: node public :: material public :: element public :: line_element public :: beam_element_2d public :: shape_function_derivative public :: shape_function_second_derivative public :: create_connectivity_matrix public :: apply_boundary_conditions public :: apply_displacement_constraint public :: restore_constrained_values public :: point public :: beam_element_3d ! DYNAMICS_KINEMATICS public :: identity_4 public :: dh_rotate_x public :: dh_rotate_z public :: dh_translate_x public :: dh_translate_z public :: dh_matrix public :: dh_forward_kinematics public :: solve_inverse_kinematics public :: vecfcn public :: least_squares_solver public :: iteration_behavior public :: jacobian_generating_vector public :: dh_jacobian public :: REVOLUTE_JOINT public :: PRISMATIC_JOINT ! DYNAMICS_VIBRATIONS public :: q_factor public :: estimate_bandwidth public :: logarithmic_decrement public :: damping_from_log_decrement public :: find_free_response_properties public :: rise_time public :: find_settling_amplitude public :: damping_from_fractional_overshoot public :: evaluate_step_response ! DYNAMICS_HELPER public :: cross_product public :: to_skew_symmetric ! DYNAMICS_STABILITY public :: HYPERBOLIC_FIXED_POINT_SINK public :: HYPERBOLIC_FIXED_POINT_SOURCE public :: HYPERBOLIC_FIXED_POINT_SADDLE public :: NONHYPERBOLIC_FIXED_POINT_UNSTABLE public :: NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE public :: NONHYPERBOLIC_FIXED_POINT_CENTER public :: determine_local_stability ! DYNAMICS_CONTROLS public :: polynomial public :: state_space public :: transfer_function public :: operator ( * ) public :: lti_solve public :: ss_excitation public :: ode_integrator ! DYNAMICS_SYSTEM_ID public :: dynamic_system_measurement public :: model_information public :: siso_model_fit_least_squares public :: constraint_equations end module","tags":"","loc":"sourcefile\\dynamics.f90.html"},{"title":"dynamics_controls.f90 – DYNAMICS","text":"Contents Modules dynamics_controls Source Code dynamics_controls.f90 Source Code module dynamics_controls use iso_fortran_env use nonlin_polynomials use ferror use ieee_arithmetic use dynamics_error_handling use diffeq implicit none private public :: polynomial public :: state_space public :: transfer_function public :: operator ( * ) public :: lti_solve public :: ss_excitation public :: ode_integrator ! ------------------------------------------------------------------------------ type state_space !! Defines a state-space representation of a dynamic system.  This !! implementation takes the form: !! !!  \\dot{x}(t) = A(t) x(t) + B(t) u(t)  !!  y(t) = C(t) x(t) + D(t) u(t)  !! !! Where: !! !! -  t  denotes time. !! !! -  x(t)  is the state vector. !! !! -  u(t)  is the input vector. !! !! -  y(t)  is the output vector. real ( real64 ), allocatable , dimension (:,:) :: A !! The N-by-N dynamics matrix, where N is the number of state !! variables. real ( real64 ), allocatable , dimension (:,:) :: B !! The N-by-M input matrix, where M is the number of inputs. real ( real64 ), allocatable , dimension (:,:) :: C !! The P-by-N output matrix, where P is the number of outputs. real ( real64 ), allocatable , dimension (:,:) :: D !! The P-by-M feedthrough matrix. end type ! ------------------------------------------------------------------------------ type transfer_function !! Defines a transfer function for a continuous system of the form !!  H(s) = \\frac{Y(s)}{X(s)} . type ( polynomial ) :: Y !! The numerator polynomial Y(s) in !!  H(s) = \\frac{Y(s)}{X(s)} .  The polynomial coefficients !! are stored in acending order such that !!  y_1 + y_2 s + y_3 s&#94;2 ... . type ( polynomial ) :: X !! The denominator polynomial X(s) in !!  H(s) = \\frac{Y(s)}{X(s)} .  The polynomial coefficients !! are stored in acending order such that !!  x_1 + x_2 s + x_3 s&#94;2 ... . contains procedure , private :: tf_init_poly procedure , private :: tf_init_array generic , public :: initialize => tf_init_poly , tf_init_array procedure , private :: tf_eval_s procedure , private :: tf_eval_omega generic , public :: evaluate => tf_eval_omega , tf_eval_s procedure , public :: poles => tf_poles procedure , public :: zeros => tf_zeros procedure , public :: to_ccf_state_space => tf_to_ccf_statespace procedure , public :: to_ocf_state_space => tf_to_ocf_statespace end type ! ------------------------------------------------------------------------------ interface operator ( * ) module procedure :: tf_tf_mult module procedure :: poly_tf_mult module procedure :: tf_poly_mult module procedure :: tf_scalar_mult module procedure :: scalar_tf_mult end interface ! ------------------------------------------------------------------------------ interface subroutine ss_excitation ( t , u , args ) !! A routine for computing the excitation vector for a state-space !! model. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: t !! The time value at which to compute the excitation. real ( real64 ), intent ( out ), dimension (:) :: u !! The excitation vector. class ( * ), intent ( inout ), optional :: args !! An optional argument used to pass objects in and out of the !! routine. end subroutine end interface ! ------------------------------------------------------------------------------ ! PRIVATE TYPES ! ------------------------------------------------------------------------------ type argument_container procedure ( ss_excitation ), pointer , nopass :: excitation class ( * ), allocatable :: user_args logical :: has_user_args type ( state_space ) :: model end type contains ! ****************************************************************************** ! TRANSFER_FUNCTION ! ------------------------------------------------------------------------------ subroutine tf_init_poly ( this , y , x ) !! Initializes a new transfer function. class ( transfer_function ), intent ( inout ) :: this !! The transfer_function object. class ( polynomial ), intent ( in ) :: y !! The numerator polynomial Y(s) in !!  H(s) = \\frac{Y(s)}{X(s)} . class ( polynomial ), intent ( in ) :: x !! The denominator polynomial X(s) in !!  H(s) = \\frac{Y(s)}{X(s)} . ! Process call this % Y % initialize ( y % get_all ()) call this % X % initialize ( x % get_all ()) end subroutine ! ------------------------------------------------------------------------------ subroutine tf_init_array ( this , y , x ) !! Initializes a new transfer function. class ( transfer_function ), intent ( inout ) :: this !! The transfer_function object. real ( real64 ), intent ( in ), dimension (:) :: y !! The numerator polynomial Y(s) in !!  H(s) = \\frac{Y(s)}{X(s)} .  The polynomial coefficients !! are stored in acending order such that !!  y_1 + y_2 s + y_3 s&#94;2 ... . real ( real64 ), intent ( in ), dimension (:) :: x !! The denominator polynomial X(s) in !!  H(s) = \\frac{Y(s)}{X(s)} .  The polynomial coefficients !! are stored in acending order such that !!  x_1 + x_2 s + x_3 s&#94;2 ... . ! Process call this % Y % initialize ( y ) call this % X % initialize ( x ) end subroutine ! ------------------------------------------------------------------------------ pure elemental function tf_eval_s ( this , s ) result ( rst ) !! Evaluates the transfer function at the specified value of the !! Laplace variable s. class ( transfer_function ), intent ( in ) :: this !! The transfer_function object. complex ( real64 ), intent ( in ) :: s !! The Laplace variable at which to evaluate the transfer function. complex ( real64 ) :: rst !! The value of the transfer function. ! Process rst = this % Y % evaluate ( s ) / this % X % evaluate ( s ) end function ! ------------------------------------------------------------------------------ pure elemental function tf_eval_omega ( this , omega ) result ( rst ) !! Evaluates the transfer function at the specified value of the !! Laplace variable s. class ( transfer_function ), intent ( in ) :: this !! The transfer_function object. real ( real64 ), intent ( in ) :: omega !! The frequency, in rad/s, at which to evaluate the transfer !! function. complex ( real64 ) :: rst !! The value of the transfer function. ! Parameters complex ( real64 ), parameter :: j = ( 0.0d0 , 1.0d0 ) ! Local Variables complex ( real64 ) :: s ! Process s = j * omega rst = this % tf_eval_s ( s ) end function ! ------------------------------------------------------------------------------ function tf_poles ( this , err ) result ( rst ) !! Computes the poles of the transfer function. class ( transfer_function ), intent ( in ) :: this !! The transfer_function object. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. complex ( real64 ), allocatable , dimension (:) :: rst !! The poles of the transfer function. ! Process rst = this % X % roots ( err = err ) end function ! ------------------------------------------------------------------------------ function tf_zeros ( this , err ) result ( rst ) !! Computes the zeros of the transfer function. class ( transfer_function ), intent ( in ) :: this !! The transfer function object. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. complex ( real64 ), allocatable , dimension (:) :: rst !! The zeros of the transfer function. ! Process rst = this % Y % roots ( err = err ) end function ! ------------------------------------------------------------------------------ function tf_to_ccf_statespace ( this ) result ( rst ) !! Converts a transfer_function type into a controllable canonical form !! state_space type.  See !! [this](https://en.wikipedia.org/wiki/State-space_representation) article !! for a description of this form. class ( transfer_function ), intent ( in ) :: this !! The transfer_function to convert. type ( state_space ) :: rst !! The resulting state-space object. ! Local Variables integer ( int32 ) :: i , order , n , norder real ( real64 ) :: a ! Process order = this % X % order () n = order + 1 allocate ( rst % A ( order , order ), rst % B ( order , 1 ), rst % C ( 1 , order ), & rst % D ( 1 , 1 ), source = 0.0d0 ) a = this % X % get ( n ) do i = 1 , order rst % A ( order , i ) = - this % X % get ( i ) / a end do do i = 1 , order - 1 rst % A ( i , i + 1 ) = 1.0d0 end do rst % B ( order , 1 ) = 1.0d0 norder = this % Y % order () do i = 1 , min ( norder + 1 , order ) rst % C ( 1 , i ) = this % Y % get ( i ) / a end do end function ! ------------------------------------------------------------------------------ function tf_to_ocf_statespace ( this ) result ( rst ) !! Converts a transfer_function type into an observable canonical form !! state_space type.  See !! [this](https://en.wikipedia.org/wiki/State-space_representation) article !! for a description of this form. class ( transfer_function ), intent ( in ) :: this !! The transfer_function to convert. type ( state_space ) :: rst !! The resulting state-space object. ! Local Variables integer ( int32 ) :: i , order , n , norder real ( real64 ) :: a ! Process order = this % X % order () n = order + 1 allocate ( rst % A ( order , order ), rst % B ( order , 1 ), rst % C ( 1 , order ), & rst % D ( 1 , 1 ), source = 0.0d0 ) a = this % X % get ( n ) do i = 1 , order rst % A ( i , order ) = - this % X % get ( i ) / a end do do i = 1 , order - 1 rst % A ( i + 1 , i ) = 1.0d0 end do norder = this % Y % order () do i = 1 , min ( norder + 1 , order ) rst % B ( i , 1 ) = this % Y % get ( i ) / a end do rst % C ( 1 , order ) = 1.0d0 end function ! ****************************************************************************** ! OPERATORS ! ------------------------------------------------------------------------------ function tf_tf_mult ( x , y ) result ( rst ) !! Multiplies two transfer functions. class ( transfer_function ), intent ( in ) :: x !! The left-hand-side argument. class ( transfer_function ), intent ( in ) :: y !! The right-hand-side argument. type ( transfer_function ) :: rst !! The resulting transfer function. ! Process rst % Y = x % Y * y % Y rst % X = x % X * y % X end function ! ------------------------------------------------------------------------------ function poly_tf_mult ( x , y ) result ( rst ) !! Multiplies a polynomial and a transfer function to result in a new !! transfer function. class ( polynomial ), intent ( in ) :: x !! The left-hand-side argument. class ( transfer_function ), intent ( in ) :: y !! The right-hand-side argument. type ( transfer_function ) :: rst !! The resulting transfer function. ! Process rst % Y = x * y % Y rst % X = y % X end function ! ------------------------------------------------------------------------------ function tf_poly_mult ( x , y ) result ( rst ) !! Multiplies a transfer function and a polynomial to result in a new !! transfer function. class ( transfer_function ), intent ( in ) :: x !! The left-hand-side argument. class ( polynomial ), intent ( in ) :: y !! The right-hand-side argument. type ( transfer_function ) :: rst !! The resulting transfer function. ! Process rst % Y = x % Y * y rst % X = x % X end function ! ------------------------------------------------------------------------------ function tf_scalar_mult ( x , y ) result ( rst ) !! Multiplies a transfer function by a scalar value. class ( transfer_function ), intent ( in ) :: x !! The left-hand-side argument. real ( real64 ), intent ( in ) :: y !! The right-hand-side argument. type ( transfer_function ) :: rst !! The resulting transfer function. ! Process rst % Y = y * x % Y rst % X = x % X end function ! ------------------------------------------------------------------------------ function scalar_tf_mult ( x , y ) result ( rst ) !! Multiplies a transfer function by a scalar value. real ( real64 ), intent ( in ) :: x !! The left-hand-side argument. class ( transfer_function ), intent ( in ) :: y !! The right-hand-side argument. type ( transfer_function ) :: rst !! The resulting transfer function. ! Process rst % Y = x * y % Y rst % X = y % X end function ! ****************************************************************************** ! LTI SOLVERS ! ------------------------------------------------------------------------------ function lti_solve ( mdl , u , t , ic , solver , args , err ) result ( rst ) !! Solves the LTI system given by the specified state space model. class ( state_space ), intent ( in ) :: mdl !! The state_space model to solve. procedure ( ss_excitation ), pointer , intent ( in ) :: u !! The routine used to compute the excitation vector. real ( real64 ), intent ( in ), dimension (:) :: t !! The time points at which to compute the solution.  The array must !! have at least 2 values; however, more may be specified.  If only !! 2 values are specified, the integrator will compute the solution at !! those points, but it will also return any intermediate integration !! steps that may be required.  However, if more than 2 points are !! given, the integrator will return the solution values only at the !! specified time points. real ( real64 ), intent ( in ), dimension (:) :: ic !! The initial condition vector.  This array must be the same size as !! the number of state variables. class ( ode_integrator ), intent ( in ), optional , target :: solver !! The ODE solver to utilize.  If not specified, the default solver !! is a 4th/5th order Runge-Kutta integrator. class ( * ), intent ( inout ), optional :: args !! An optional container for arguments to pass to the excitation !! routine. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The solution.  The time points at which the solution was evaluated !! are stored in the first column and the output(s) are stored in the !! remaining column(s). ! Local Variables integer ( int32 ) :: i , n , npts , flag , nInputs , nOutputs real ( real64 ), allocatable , dimension (:) :: uv real ( real64 ), allocatable , dimension (:,:) :: sol type ( argument_container ) :: container class ( errors ), pointer :: errmgr type ( errors ), target :: deferr class ( ode_integrator ), pointer :: integrator type ( runge_kutta_45 ), target :: defaultIntegrator type ( ode_container ) :: odeMdl ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if container % excitation => u container % model = mdl container % has_user_args = present ( args ) if ( present ( args )) allocate ( container % user_args , source = args ) n = size ( mdl % A , 1 ) nInputs = size ( mdl % B , 2 ) nOutputs = size ( mdl % C , 1 ) ! Input Checking if ( size ( ic ) /= n ) then call report_array_size_error ( \"lti_solve_statespace\" , \"ic\" , n , & size ( ic ), errmgr ) return end if ! Set up the integrator if ( present ( solver )) then integrator => solver else integrator => defaultIntegrator end if odeMdl % fcn => ode_solver_routine ! Call the solver call integrator % solve ( odeMdl , t , ic , args = container , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Get the output from the solver sol = integrator % get_solution () npts = size ( sol , 1 ) allocate ( rst ( npts , nOutputs + 1 ), uv ( nInputs ), stat = flag , source = 0.0d0 ) if ( flag /= 0 ) then call report_memory_error ( \"lti_solve_statespace\" , flag , errmgr ) return end if ! Compute: C * x + D * u do i = 1 , npts call u ( sol ( i , 1 ), uv , args ) rst ( i , 1 ) = sol ( i , 1 ) rst ( i , 2 :) = matmul ( mdl % C , sol ( i , 2 :)) + matmul ( mdl % D , uv ) end do end function ! ---------- subroutine ode_solver_routine ( t , x , dxdt , args ) ! The routine called by the LTI solver real ( real64 ), intent ( in ) :: t , x (:) real ( real64 ), intent ( out ) :: dxdt (:) class ( * ), intent ( inout ), optional :: args ! Local Variables integer ( int32 ) :: n , p real ( real64 ) :: nan real ( real64 ), allocatable , dimension (:) :: u ! Initialization nan = ieee_value ( nan , IEEE_QUIET_NAN ) ! Process select type ( args ) class is ( argument_container ) ! Evaluate the excitation vector at t n = size ( args % model % B , 2 ) allocate ( u ( n ), source = 0.0d0 ) if ( args % has_user_args ) then call args % excitation ( t , u , args = args % user_args ) else call args % excitation ( t , u ) end if ! Evaluate the model dxdt = matmul ( args % model % A , x ) + matmul ( args % model % B , u ) class default dxdt = nan end select end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_controls.f90.html"},{"title":"dynamics_error_handling.f90 – DYNAMICS","text":"Contents Modules dynamics_error_handling Source Code dynamics_error_handling.f90 Source Code module dynamics_error_handling use ferror use iso_fortran_env use diffeq_errors , only : DIFFEQ_INVALID_INPUT_ERROR , & DIFFEQ_MEMORY_ALLOCATION_ERROR , DIFFEQ_NULL_POINTER_ERROR use fstats_errors , only : FS_UNDERDEFINED_PROBLEM_ERROR , & FS_TOLERANCE_TOO_SMALL_ERROR , FS_TOO_FEW_ITERATION_ERROR implicit none integer ( int32 ), parameter :: DYN_MEMORY_ERROR = DIFFEQ_MEMORY_ALLOCATION_ERROR !! Defines an error associated with memory allocations. integer ( int32 ), parameter :: DYN_NULL_POINTER_ERROR = DIFFEQ_NULL_POINTER_ERROR !! Defines an error associated with a null pointer. integer ( int32 ), parameter :: DYN_INVALID_INPUT_ERROR = DIFFEQ_INVALID_INPUT_ERROR !! Defines an error associated with an invalid input. integer ( int32 ), parameter :: DYN_MATRIX_SIZE_ERROR = 100100 !! Defines an error associated with an incorrectly sized matrix. integer ( int32 ), parameter :: DYN_ZERO_VALUED_FREQUENCY_ERROR = 100101 !! Defines an error associated with a zero-valued frequency. integer ( int32 ), parameter :: DYN_CONSTRAINT_ERROR = 100102 !! Defines a constraint-related error. integer ( int32 ), parameter :: DYN_INDEX_OUT_OF_RANGE = 100103 !! Defines an index out of range error. integer ( int32 ), parameter :: DYN_NONMONOTONIC_ARRAY_ERROR = 100104 !! Defines an error related to an array being nonmonotonic. integer ( int32 ), parameter :: DYN_ARRAY_SIZE_ERROR = 100105 !! Defines an error for an improperly sized array. integer ( int32 ), parameter :: DYN_UNDERDEFINED_PROBLEM_EROR = FS_UNDERDEFINED_PROBLEM_ERROR !! Defines an error for an underdefined problem. integer ( int32 ), parameter :: DYN_TOLERANCE_TOO_SMALL_ERROR = FS_TOLERANCE_TOO_SMALL_ERROR !! Defines an error related to the request of a too small tolerance !! value. integer ( int32 ), parameter :: DYN_TOO_FEW_ITERATIONS_ERROR = FS_TOO_FEW_ITERATION_ERROR !! Defines an error when too few iterations were allowed. contains ! ------------------------------------------------------------------------------ subroutine report_null_forcing_routine_error ( name , err ) !! Reports a null forcing routine pointer error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Report the error call err % report_error ( name , & \"No forcing function routine was supplied.\" , & DYN_NULL_POINTER_ERROR ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_memory_error ( name , flag , err ) !! Reports a memory allocation error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: flag !! The flag returned from the allocate statement. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Memory allocation error flag \" , flag , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MEMORY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonsquare_mass_matrix_error ( name , m , n , err ) !! Reports an error relating to a non-square mass matrix. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: m !! The number of rows found in the mass matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns found in the mass matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The mass matrix is not square.  \" // & \"It was found to be \" , m , \"-by-\" , n , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonsquare_stiffness_matrix_error ( name , m , n , err ) !! Reports an error relating to a non-square stiffness matrix. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: m !! The number of rows found in the stiffness matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns found in the stiffness matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The stiffness matrix is not square.  \" // & \"It was found to be \" , m , \"-by-\" , n , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonsquare_matrix_error ( name , var , m , n , err ) !! Reports an error relating to a non-square matrix. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var !! The name of the offending variable. integer ( int32 ), intent ( in ) :: m !! The number of rows found in the matrix. integer ( int32 ), intent ( in ) :: n !! The number of columns found in the matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Matrix \" // var // \" is not square.  \" // & \"It was found to be \" , m , \"-by-\" , n , \".\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_mismatch_error ( name , mtx1 , mtx2 , m1 , n1 , & m2 , n2 , err ) !! Reports a mismatch in matrix sizes. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: mtx1 !! The name of the first matrix. character ( len = * ), intent ( in ) :: mtx2 !! The name of the second matrix. integer ( int32 ), intent ( in ) :: m1 !! The number of rows in the first matrix. integer ( int32 ), intent ( in ) :: n1 !! The number of columns in the first matrix. integer ( int32 ), intent ( in ) :: m2 !! The number of rows in the second matrix. integer ( int32 ), intent ( in ) :: n2 !! The number of columns in the second matrix. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"The size of the \" // mtx1 // \" matrix (\" , m1 , & \"-by-\" , n1 , \") does not match the size of the \" // mtx2 , & \" matrix (\" , m2 , \"-by-\" , n2 , \").\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_zero_valued_frequency_error ( name , index , err ) !! Reports an error associated with a zero-valued frequency value. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: index !! The array index at which the zero-valued frequency was found. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"A zero-valued frequency was found at index \" , & index , \".\" call err % report_error ( name , trim ( errmsg ), & DYN_ZERO_VALUED_FREQUENCY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_generic_counting_error ( name , str1 , val , str2 , flag , err ) !! A generic error reporting routine. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: str1 !! The first string. integer ( int32 ), intent ( in ) :: val !! The integer value. character ( len = * ), intent ( in ) :: str2 !! The second string. integer ( int32 ), intent ( in ) :: flag !! The error flag. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 512 ) :: errmsg ! Report the error write ( errmsg , 100 ) str1 , val , str2 call err % report_error ( name , trim ( errmsg ), flag ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_zero_difference_error ( name , var1 , val1 , var2 , val2 , & flag , err ) !! Reports a zero-difference between two variables where a non-zero !! difference was expected. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var1 !! The name of the first variable. real ( real64 ), intent ( in ) :: val1 !! The value of the first variable. character ( len = * ), intent ( in ) :: var2 !! The name of the second variable. real ( real64 ), intent ( in ) :: val2 !! The value of the second variable. integer ( int32 ), intent ( in ) :: flag !! The error flag. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"A non-zero difference between \" // var1 // & \" (\" , val1 , \"), and \" // var2 // \" (\" , val2 , \") was expected.\" call err % report_error ( name , trim ( errmsg ), flag ) ! Formatting 100 format ( A , F0 . 4 , A , F0 . 4 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_overconstraint_error ( name , err ) !! Reports an overconstraint error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Report the error call err % report_error ( name , \"The model is overconstrained.\" , & DYN_CONSTRAINT_ERROR ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_array_index_out_of_bounds_error ( name , var , ind , sz , err ) !! Reports an array index-out-of-bounds error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var !! The name of the offending variable. integer ( int32 ), intent ( in ) :: ind !! The offending index. integer ( int32 ), intent ( in ) :: sz !! The array size. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) & \"Index \" , ind , \" is outside the bounds of array \" // var // & \", which is of size \" , sz , \".\" call err % report_error ( name , trim ( errmsg ), DYN_INDEX_OUT_OF_RANGE ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_nonmonotonic_array_error ( name , var , ind , err ) !! Reports a nonmonotonic array error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var !! The name of the offending variable. integer ( int32 ), intent ( in ) :: ind !! The index of the occurrence of nonmonotonicity. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Array \" // var // & \" was found to be nonmonotonic at index \" , ind , \".\" call err % report_error ( name , trim ( errmsg ), DYN_NONMONOTONIC_ARRAY_ERROR ) ! Formatting 100 format ( A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_constraint_count_error ( name , expected , actual , err ) !! Reports an error associated with an incorrect number of constraints. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. integer ( int32 ), intent ( in ) :: expected !! The expected number of constraints. integer ( int32 ), intent ( in ) :: actual !! The actual number of constraints. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Expected to find \" , expected , & \" constraints, but found \" , actual , \" constraints instead.\" call err % report_error ( name , trim ( errmsg ), DYN_CONSTRAINT_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_array_size_error ( name , var , expected , actual , err ) !! Reports an array size error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var !! The name of the offending variable. integer ( int32 ), intent ( in ) :: expected !! The expected array size. integer ( int32 ), intent ( in ) :: actual !! The actual array size. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 256 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Expected array \" // var // \" to be of size \" , & expected , \", but found it to be of size \" , actual , \".\" call err % report_error ( name , trim ( errmsg ), DYN_ARRAY_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ subroutine report_matrix_size_error ( name , var , expect_rows , expect_cols , & actual_rows , actual_cols , err ) !! Reports a matrix size error. character ( len = * ), intent ( in ) :: name !! The name of the routine in which the error was found. character ( len = * ), intent ( in ) :: var !! The name of the offending variable. integer ( int32 ), intent ( in ) :: expect_rows !! The expected number of rows. integer ( int32 ), intent ( in ) :: expect_cols !! The expected number of columns. integer ( int32 ), intent ( in ) :: actual_rows !! The actual number of rows. integer ( int32 ), intent ( in ) :: actual_cols !! The actual number of columns. class ( errors ), intent ( inout ) :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. ! Local Variables character ( len = 512 ) :: errmsg ! Report the error write ( errmsg , 100 ) \"Expected matrix \" // var // \" to be of size (\" , & expect_rows , \"-by-\" , expect_cols , & \"), but found it to be of size (\" , actual_rows , \"-by-\" , & actual_cols , \").\" call err % report_error ( name , trim ( errmsg ), DYN_MATRIX_SIZE_ERROR ) ! Formatting 100 format ( A , I0 , A , I0 , A , I0 , A , I0 , A ) end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_error_handling.f90.html"},{"title":"dynamics_frequency_response.f90 – DYNAMICS","text":"Contents Modules dynamics_frequency_response Source Code dynamics_frequency_response.f90 Source Code module dynamics_frequency_response use iso_fortran_env use ferror use diffeq , only : ode_container , ode_integrator use dynamics_error_handling use spectrum use fstats implicit none private public :: ode_excite public :: modal_excite public :: harmonic_ode public :: frf public :: mimo_frf public :: chirp public :: frequency_response public :: frequency_sweep public :: compute_modal_damping public :: modal_response public :: normalize_mode_shapes public :: evaluate_accelerance_frf_model public :: evaluate_receptance_frf_model public :: fit_frf public :: FRF_ACCELERANCE_MODEL public :: FRF_RECEPTANCE_MODEL public :: regression_statistics public :: iteration_controls public :: lm_solver_options public :: convergence_info public :: ode_integrator interface function ode_excite ( t ) result ( rst ) !! Defines the interface for a ODE excitation function. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: t !! The value of the independent variable at which to evaluate !! the excitation function. real ( real64 ) :: rst !! The result. end function subroutine modal_excite ( freq , frc ) !! Defines the interface to a routine for defining the forcing !! function for a modal frequency analysis. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: freq !! The excitation frequency.  When used as a part of a frequency !! response calculation, this value will have the same units as !! the frequency values provided to the frequency response !! routine. complex ( real64 ), intent ( out ), dimension (:) :: frc !! An N-element array where the forcing function should be !! written. end subroutine pure subroutine harmonic_ode ( freq , t , x , dxdt , args ) !! Defines a system of ODE's exposed to harmonic excitation. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ) :: freq !! The excitation frequency. real ( real64 ), intent ( in ) :: t !! The current time step value. real ( real64 ), intent ( in ), dimension (:) :: x !! The value of the solution estimate at time t. real ( real64 ), intent ( out ), dimension (:) :: dxdt !! The derivatives as computed by this routine. class ( * ), intent ( inout ), optional :: args !! An optional argument allowing the passing of data in/out of !! this routine. end subroutine end interface type frf !! A container for a frequency response function, or series of frequency !! response functions. real ( real64 ), allocatable , dimension (:) :: frequency !! An N-element array containing the frequency values at which the !! FRF is provided.  The units of this array are the same as the !! units of the frequency values passed to the routine used to !! compute the frequency response. complex ( real64 ), allocatable , dimension (:,:) :: responses !! An N-by-M matrix containing the M frequency response functions !! evaluated at each of the N frequency points. end type type mimo_frf !! A container for the frequency responses of a system of multiple !! inputs and multiple outputs (MIMO). real ( real64 ), allocatable , dimension (:) :: frequency !! An N-element array containing the frequency values at which the !! FRF is provided.  The units of this array are the same as the !! units of the frequency values passed to the routine used to !! compute the frequency response. complex ( real64 ), allocatable , dimension (:,:,:) :: responses !! An N-by-M-by-P array containing the frequency response functions !! for each of the M outputs corresponding to each of the P inputs. end type interface frequency_response !! Computes the frequency response functions for a system of ODE's. module procedure :: frf_modal_prop_damp module procedure :: frf_modal_prop_damp_2 module procedure :: siso_freqres module procedure :: mimo_freqres end interface interface frequency_sweep module procedure :: frf_sweep_1 module procedure :: frf_sweep_2 end interface interface evaluate_accelerance_frf_model module procedure :: evaluate_accelerance_frf_model_scalar module procedure :: evaluate_accelerance_frf_model_array end interface interface evaluate_receptance_frf_model module procedure :: evaluate_receptance_frf_model_scalar module procedure :: evaluate_receptance_frf_model_array end interface ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: FRF_ACCELERANCE_MODEL = 1 !! Defines an accelerance frequency response model. integer ( int32 ), parameter :: FRF_RECEPTANCE_MODEL = 2 !! Defines a receptance frequency response model. ! ------------------------------------------------------------------------------ type frf_arg_container procedure ( harmonic_ode ), pointer , nopass :: fcn real ( real64 ) :: frequency logical :: uses_optional_args class ( * ), allocatable :: optional_args end type contains ! ------------------------------------------------------------------------------ pure elemental function chirp ( t , amp , span , f1Hz , f2Hz ) result ( rst ) !! Evaluates a linear chirp function. real ( real64 ), intent ( in ) :: t !! The value of the independent variable at which to evaluate the !! chirp. real ( real64 ), intent ( in ) :: amp !! The amplitude. real ( real64 ), intent ( in ) :: span !! The duration of the time it takes to sweep from the start !! frequency to the end frequency. real ( real64 ), intent ( in ) :: f1Hz !! The lower excitation frequency, in Hz. real ( real64 ), intent ( in ) :: f2Hz !! The upper excitation frequency, in Hz. real ( real64 ) :: rst !! The value of the function at t. real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) real ( real64 ) :: c c = ( f2Hz - f1Hz ) / span rst = amp * sin ( 2.0d0 * pi * t * ( 0.5d0 * c * t + f1Hz )) end function ! ------------------------------------------------------------------------------ function frf_modal_prop_damp ( mass , stiff , alpha , beta , freq , frc , & modes , modeshapes , err ) result ( rst ) !! Computes the frequency response functions for a !! multi-degree-of-freedom system that uses proportional damping such !! that the damping matrix  C  is related to the stiffness an mass !! matrices by proportional damping coefficients  \\alpha  and !!  \\beta  by  C = \\alpha M + \\beta K . use linalg , only : eigen , sort , mtx_mult , LA_NO_OPERATION , LA_TRANSPOSE use dynamics_error_handling real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . real ( real64 ), intent ( in ), dimension (:) :: freq !! An M-element array of frequency values at which to evaluate the !! frequency response functions, in units of rad/s. procedure ( modal_excite ), pointer , intent ( in ) :: frc !! A pointer to a routine used to compute the modal forcing !! function. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:) :: modes !! An optional N-element allocatable array that, if supplied, will !! be used to retrieve the modal frequencies, in units of rad/s. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:,:) :: modeshapes !! An optional N-by-N allocatable matrix that, if supplied, will be !! used to retrieve the N mode shapes with each vector occupying !! its own column. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices !!      are not square, or if the mass and stiffness matrices are !!      different sized. !! - DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer !!      is undefined. type ( frf ) :: rst !! The resulting frequency responses. ! Parameters complex ( real64 ), parameter :: j = ( 0.0d0 , 1.0d0 ) complex ( real64 ), parameter :: zero = ( 0.0d0 , 0.0d0 ) complex ( real64 ), parameter :: one = ( 1.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , m , n , flag complex ( real64 ) :: s real ( real64 ), allocatable , dimension (:) :: lambda , zeta real ( real64 ), allocatable , dimension (:,:) :: mmtx , kmtx complex ( real64 ), allocatable , dimension (:) :: vals , q , f , u complex ( real64 ), allocatable , dimension (:,:) :: vecs class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( freq ) n = size ( mass , 1 ) ! Input Checking if ( size ( mass , 2 ) /= n ) go to 20 if ( size ( stiff , 1 ) /= size ( stiff , 2 )) go to 30 if ( size ( stiff , 1 ) /= n . or . size ( stiff , 2 ) /= n ) go to 40 if (. not . associated ( frc )) go to 50 ! TO DO: Check for symmetry ! Memory allocations allocate ( mmtx ( n , n ), source = mass , stat = flag ) if ( flag == 0 ) allocate ( kmtx ( n , n ), source = stiff , stat = flag ) if ( flag == 0 ) allocate ( zeta ( n ), stat = flag ) if ( flag == 0 ) allocate ( q ( n ), stat = flag ) if ( flag == 0 ) allocate ( vals ( n ), stat = flag ) if ( flag == 0 ) allocate ( f ( n ), stat = flag , source = zero ) if ( flag == 0 ) allocate ( u ( n ), stat = flag ) if ( flag == 0 ) allocate ( vecs ( n , n ), stat = flag ) if ( flag == 0 ) allocate ( rst % responses ( m , n ), stat = flag ) if ( flag == 0 ) allocate ( rst % frequency ( m ), source = freq , stat = flag ) if ( flag /= 0 ) go to 10 ! Compute the eigenvalues and eigenvectors call eigen ( kmtx , mmtx , vals , vecs = vecs , err = errmgr ) if ( errmgr % has_error_occurred ()) return allocate ( lambda ( n ), source = real ( vals ), stat = flag ) if ( flag /= 0 ) go to 10 ! Compute the damping terms zeta = compute_modal_damping ( lambda , alpha , beta ) ! Compute each transfer function do i = 1 , m call frc ( freq ( i ), f ) call mtx_mult ( LA_TRANSPOSE , one , vecs , f , zero , u ) s = j * freq ( i ) q = u / ( s ** 2 + 2.0d0 * zeta * sqrt ( lambda ) * s + lambda ) call mtx_mult ( LA_NO_OPERATION , one , vecs , q , zero , rst % responses ( i ,:)) end do ! If needed, return the modal frequencies and mode shapes if ( present ( modes ) . or . present ( modeshapes )) then ! Sort the modal information call sort ( vals , vecs ) end if if ( present ( modes )) then allocate ( modes ( n ), source = sqrt ( real ( vals )), & stat = flag ) if ( flag /= 0 ) go to 10 end if if ( present ( modeshapes )) then allocate ( modeshapes ( n , n ), source = real ( vecs ), stat = flag ) if ( flag /= 0 ) go to 10 end if ! End return ! Memory error 10 continue call report_memory_error ( \"frf_modal_prop_damp\" , flag , errmgr ) return ! Error: Mass matrix is not square 20 continue call report_nonsquare_mass_matrix_error ( \"frf_modal_prop_damp\" , & size ( mass , 1 ), size ( mass , 2 ), errmgr ) return ! Error: Stiffness matrix is not square 30 continue call report_nonsquare_stiffness_matrix_error ( \"frf_modal_prop_damp\" , & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Error: Stiffness matrix is not sized correctly 40 continue call report_matrix_size_mismatch_error ( \"frf_modal_prop_damp\" , & \"mass\" , \"stiffness\" , size ( mass , 1 ), size ( mass , 2 ), & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Null forcing term pointer 50 continue call report_null_forcing_routine_error ( \"frf_modal_prop_damp\" , & errmgr ) return end function ! ------------------------------------------------------------------------------ function frf_modal_prop_damp_2 ( mass , stiff , alpha , beta , nfreq , freq1 , & freq2 , frc , modes , modeshapes , err ) result ( rst ) !! Computes the frequency response functions for a !! multi-degree-of-freedom system that uses proportional damping such !! that the damping matrix  C  is related to the stiffness an mass !! matrices by proportional damping coefficients  \\alpha  and !!  \\beta  by  C = \\alpha M + \\beta K . use linalg , only : eigen , sort , mtx_mult , LA_NO_OPERATION , LA_TRANSPOSE use dynamics_error_handling real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . integer ( int32 ), intent ( in ) :: nfreq !! The number of frequency values to analyze.  This value must be !! at least 2. real ( real64 ), intent ( in ) :: freq1 !! The starting frequency, in units of rad/s. real ( real64 ), intent ( in ) :: freq2 !! The ending frequency, in units of rad/s. procedure ( modal_excite ), pointer , intent ( in ) :: frc !! A pointer to a routine used to compute the modal forcing !! function. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:) :: modes !! An optional N-element allocatable array that, if supplied, will !! be used to retrieve the modal frequencies, in units of rad/s. real ( real64 ), intent ( out ), allocatable , optional , & dimension (:,:) :: modeshapes !! An optional N-by-N allocatable matrix that, if supplied, will be !! used to retrieve the N mode shapes with each vector occupying !! its own column. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_MATRIX_SIZE_ERROR: Occurs if the mass or stiffness matrices !!      are not square, or if the mass and stiffness matrices are !!      different sized. !! - DYN_NULL_POINTER_ERROR: Occurs if the forcing function pointer !!      is undefined. type ( frf ) :: rst !! The resulting frequency responses. ! Local Variables integer ( int32 ) :: i , flag real ( real64 ) :: df real ( real64 ), allocatable , dimension (:) :: freq class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( abs ( freq1 - freq2 ) < sqrt ( epsilon ( freq1 ))) then call report_zero_difference_error ( \"frf_modal_prop_damp_2\" , & \"freq1\" , freq1 , \"freq2\" , freq2 , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if if ( nfreq < 2 ) then call report_generic_counting_error ( \"frf_modal_prop_damp_2\" , & \"The number of frequency points must be at least 2, \" // & \"but was found to be \" , nfreq , \".\" , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if ! Process df = ( freq2 - freq1 ) / ( nfreq - 1.0d0 ) allocate ( freq ( nfreq ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"frf_modal_prop_damp_2\" , flag , errmgr ) return end if freq = ( / ( df * i + freq1 , i = 0 , nfreq - 1 ) / ) rst = frequency_response ( mass , stiff , alpha , beta , freq , frc , modes , & modeshapes , err ) end function ! ------------------------------------------------------------------------------ pure elemental function compute_modal_damping ( lambda , alpha , beta ) & result ( rst ) !! Computes the modal damping factors  \\zeta_i  given the !! proportional damping terms  \\alpha  and  \\beta  where !!  \\alpha + \\beta \\omega_{i}&#94;2 = 2 \\zeta_{i} \\omega_{i} , !!  \\lambda_{i} = \\omega_{i}&#94;2 , and  \\lambda_i  is the !!  i&#94;{th}  eigenvalue of the system. real ( real64 ), intent ( in ) :: lambda !! The square of the modal frequency - the eigen value. real ( real64 ), intent ( in ) :: alpha !! The mass damping factor,  \\alpha . real ( real64 ), intent ( in ) :: beta !! The stiffness damping factor,  \\beta . real ( real64 ) rst !! The modal damping parameter. ! Local Variables integer ( int32 ) :: n ! Process rst = ( alpha + beta * lambda ) / ( 2.0d0 * sqrt ( lambda )) end function ! ------------------------------------------------------------------------------ subroutine modal_response ( mass , stiff , freqs , modeshapes , err ) !! Computes the modal frequencies and modes shapes for !! multi-degree-of-freedom system. use dynamics_error_handling use linalg , only : eigen , sort real ( real64 ), intent ( in ), dimension (:,:) :: mass !! The N-by-N mass matrix for the system.  This matrix must be !! symmetric. real ( real64 ), intent ( in ), dimension (:,:) :: stiff !! The N-by-N stiffness matrix for the system.  This matrix must !! be symmetric. real ( real64 ), intent ( out ), allocatable , dimension (:) :: freqs !! An allocatable N-element array where the modal frequencies will !! be returned in ascending order with units of rad/s. real ( real64 ), intent ( out ), allocatable , optional , dimension (:,:) :: & modeshapes !! An optional, allocatable N-by-N matrix where the N mode shapes !! for the system will be returned.  The mode shapes are stored in !! columns. class ( errors ), intent ( inout ), optional , target :: err ! Local Variables integer ( int32 ) :: n , flag real ( real64 ), allocatable , dimension (:,:) :: mmtx , kmtx complex ( real64 ), allocatable , dimension (:) :: vals complex ( real64 ), allocatable , dimension (:,:) :: vecs class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( mass , 1 ) ! Input Checking if ( size ( mass , 2 ) /= n ) go to 10 if ( size ( stiff , 1 ) /= size ( stiff , 2 )) go to 20 if ( size ( stiff , 1 ) /= n . or . size ( stiff , 2 ) /= n ) go to 30 ! TO DO: Check for symmetry ! Memory allocations allocate ( mmtx ( n , n ), source = mass , stat = flag ) if ( flag == 0 ) allocate ( kmtx ( n , n ), source = stiff , stat = flag ) if ( flag == 0 ) allocate ( vals ( n ), stat = flag ) if ( flag == 0 . and . present ( modeshapes )) & allocate ( vecs ( n , n ), stat = flag ) if ( flag /= 0 ) go to 40 ! Solve the eigen problem if ( present ( modeshapes )) then call eigen ( kmtx , mmtx , vals , vecs = vecs , err = errmgr ) if ( errmgr % has_error_occurred ()) return call sort ( vals , vecs ) allocate ( modeshapes ( n , n ), source = real ( vecs ), stat = flag ) if ( flag /= 0 ) go to 40 else call eigen ( kmtx , mmtx , vals , err = errmgr ) if ( errmgr % has_error_occurred ()) return call sort ( vals ) end if ! Convert the eigenvalues to frequency values allocate ( freqs ( n ), source = sqrt ( abs ( real ( vals ))), & stat = flag ) if ( flag /= 0 ) go to 40 ! End return ! Non-square mass matrix error handler 10 continue call report_nonsquare_mass_matrix_error ( \"modal_response\" , & size ( mass , 1 ), size ( mass , 2 ), errmgr ) return ! Non-square stiffness matrix error handler 20 continue call report_nonsquare_stiffness_matrix_error ( \"modal_response\" , & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Stiffness and mass matrix size mismatch error handler 30 continue call report_matrix_size_mismatch_error ( \"modal_response\" , & \"mass\" , \"stiffness\" , size ( mass , 1 ), size ( mass , 2 ), & size ( stiff , 1 ), size ( stiff , 2 ), errmgr ) return ! Memory error handler 40 continue call report_memory_error ( \"modal_response\" , flag , errmgr ) return end subroutine ! ------------------------------------------------------------------------------ subroutine normalize_mode_shapes ( x ) !! Normalizes mode shape vectors such that the largest magnitude !! value in the vector is one. real ( real64 ), intent ( inout ), dimension (:,:) :: x !! The matrix of mode shape vectors with one vector per column. ! Local Variables integer ( int32 ) :: i , loc real ( real64 ) :: factor ! Process do i = 1 , size ( x , 2 ) loc = maxloc ( abs ( x (:, i )), 1 ) factor = x ( loc , i ) x (:, i ) = x (:, i ) / factor end do end subroutine ! ****************************************************************************** ! HARMONIC_ODE_CONTAINER ROUTINES ! ------------------------------------------------------------------------------ function frf_sweep_1 ( fcn , freq , iv , solver , ncycles , ntransient , & points , args , err ) result ( rst ) !! Computes the frequency response of each equation of a system of !! harmonically excited ODE's by sweeping through frequency. use spectrum , only : next_power_of_two use fftpack , only : zffti use diffeq , only : runge_kutta_45 use dynamics_error_handling procedure ( harmonic_ode ), pointer , intent ( in ) :: fcn !! A pointer to the routine containing the ODE's to integrate. real ( real64 ), intent ( in ), dimension (:) :: freq !! An M-element array containing the frequency points at which the !! solution should be computed.  Notice, whatever units are utilized !! for this array are also the units of the excitation_frequency !! property in @p sys.  It is recommended that the units be set to !! Hz.  Additionally, this array cannot contain any zero-valued !! elements as the ODE solution time for each frequency is !! determined by the period of oscillation and number of cycles. real ( real64 ), intent ( in ), dimension (:) :: iv !! An N-element array containing the initial conditions for each of !! the N ODEs. class ( ode_integrator ), intent ( inout ), optional , target :: solver !! An optional differential equation solver.  The default solver !! is the Dormand-Prince Runge-Kutta integrator from the DIFFEQ !! library. integer ( int32 ), intent ( in ), optional :: ncycles !! An optional parameter controlling the number of cycles to !! analyze when determining the amplitude and phase of the response. !! The default is 20. integer ( int32 ), intent ( in ), optional :: ntransient !! An optional parameter controlling how many of the initial !! \"transient\" cycles to ignore.  The default is 200. integer ( int32 ), intent ( in ), optional :: points !! An optional parameter controlling how many evenly spaced !! solution points should be considered per cycle.  The default is !! 1000.  Notice, there must be at least 2 points per cycle for the !! analysis to be effective.  The algorithm utilizes a discrete !! Fourier transform to determine the phase and amplitude, and in !! order to satisfy Nyquist conditions, the value must be at least !! 2. class ( * ), intent ( inout ), optional :: args !! An optional argument allowing for passing of data in/out of the !! fcn subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. !! - DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter !!      is given. !! - DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued !!      frequency was supplied. type ( frf ) :: rst !! The resulting frequency responses. ! Parameters real ( real64 ), parameter :: zerotol = sqrt ( epsilon ( 0.0d0 )) ! Local Variables integer ( int32 ) :: i , j , nfreq , neqn , nc , nt , ntotal , npts , ppc , flag , & nfft , i1 , ncpts , lsave real ( real64 ) :: dt , tare , phase , amp real ( real64 ), allocatable , dimension (:) :: ic , t , wsave real ( real64 ), allocatable , dimension (:,:) :: sol complex ( real64 ), allocatable , dimension (:) :: xpts type ( ode_container ) :: sys class ( ode_integrator ), pointer :: integrator type ( runge_kutta_45 ), target :: default_integrator class ( errors ), pointer :: errmgr type ( errors ), target :: deferr type ( frf_arg_container ) :: container ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( ncycles )) then nc = ncycles else nc = 20 end if if ( present ( ntransient )) then nt = ntransient else nt = 200 end if if ( present ( points )) then ppc = points else ppc = 1000 end if nfreq = size ( freq ) neqn = size ( iv ) ntotal = nt + nc npts = ntotal * ppc ncpts = nc * ppc i1 = npts - ncpts + 1 nfft = 2 ** next_power_of_two ( ppc * nc ) lsave = 4 * nfft + 15 sys % fcn => sweep_eom ! Set up the optional argument container container % fcn => fcn container % uses_optional_args = present ( args ) if ( present ( args )) then allocate ( container % optional_args , source = args ) end if ! Set up the integrator if ( present ( solver )) then integrator => solver else integrator => default_integrator end if ! Input Checking if ( nc < 1 ) go to 20 if ( nt < 1 ) go to 30 if ( ppc < 2 ) go to 40 do i = 1 , nfreq if ( abs ( freq ( i )) < zerotol ) go to 50 end do ! Local Memory Allocation allocate ( rst % responses ( nfreq , neqn ), stat = flag ) if ( flag == 0 ) allocate ( rst % frequency ( nfreq ), source = freq , & stat = flag ) if ( flag == 0 ) allocate ( ic ( neqn ), stat = flag , source = iv ) if ( flag == 0 ) allocate ( t ( npts ), stat = flag ) if ( flag == 0 ) allocate ( xpts ( nfft ), stat = flag , source = ( 0.0d0 , 0.0d0 )) if ( flag == 0 ) allocate ( wsave ( lsave ), stat = flag ) if ( flag /= 0 ) go to 10 ! Set up the FFT calculations for the get_magnitude_phase routine call zffti ( nfft , wsave ) ! Cycle over each frequency point do i = 1 , nfreq ! Define the time vector dt = ( 1.0d0 / freq ( i )) / ( ppc - 1.0d0 ) t = ( / ( dt * j , j = 0 , npts - 1 ) / ) ! Set the frequency container % frequency = freq ( i ) ! Compute the solution call integrator % solve ( sys , t , ic , args = container , err = errmgr ) if ( errmgr % has_error_occurred ()) return sol = integrator % get_solution () ! Reset the initial conditions to the last solution point ic = sol ( npts , 2 :) ! Determine the magnitude and phase for each equation do j = 1 , neqn rst % responses ( i , j ) = & get_magnitude_phase ( sol ( i1 : npts , j + 1 ), xpts , wsave ) end do ! Clear the solution buffer for the next time around call integrator % clear_buffer () end do ! End return ! Memory Error 10 continue call report_memory_error ( \"frf_sweep_1\" , flag , errmgr ) return ! Number of Cycles Error 20 continue call report_generic_counting_error ( \"frf_sweep_1\" , & \"The number of cycles to analyze must be at least 1; \" // & \"however, a value of \" , nc , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Number of Transient Cycles Error 30 continue call report_generic_counting_error ( \"frf_sweep_1\" , & \"The number of transient cycles must be at least 1; \" // & \"however, a value of \" , nt , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Points Per Cycle Error 40 continue call report_generic_counting_error ( \"frf_sweep_1\" , & \"The number of points per cycle must be at least 2; \" // & \"however, a value of \" , ppc , \" was found.\" , & DYN_INVALID_INPUT_ERROR , errmgr ) return ! Zero-Valued Frequency Error 50 continue call report_zero_valued_frequency_error ( \"frf_sweep_1\" , i , errmgr ) return end function ! ---------- pure subroutine sweep_eom ( x , y , dydx , args ) real ( real64 ), intent ( in ) :: x real ( real64 ), intent ( in ), dimension (:) :: y real ( real64 ), intent ( out ), dimension (:) :: dydx class ( * ), intent ( inout ), optional :: args select type ( args ) class is ( frf_arg_container ) if ( args % uses_optional_args ) then call args % fcn ( args % frequency , x , y , dydx , args % optional_args ) else call args % fcn ( args % frequency , x , y , dydx ) end if end select end subroutine ! ---------- function get_magnitude_phase ( x , xzeros , wsave ) result ( rst ) !! Returns the magnitude and phase of a signal. use fftpack , only : zfftf use spectrum , only : compute_transform_length ! Arguments real ( real64 ), intent ( in ), dimension (:) :: x !! The array containing the signal. complex ( real64 ), intent ( out ), dimension (:) :: xzeros !! A workspace array for the FFT operation. real ( real64 ), intent ( in ), dimension (:) :: wsave !! A workspace array for the FFT operation complex ( real64 ) :: rst !! The complex-valued result defining both magnitude and phase. ! Parameters complex ( real64 ), parameter :: czero = ( 0.0d0 , 0.0d0 ) ! Local Variables integer ( int32 ) :: i , ind , m , n , nx ! Initialization nx = size ( x ) n = size ( xzeros ) m = compute_transform_length ( n ) ! Zero pad the data xzeros (: nx ) = cmplx ( x , 0.0d0 , real64 ) xzeros ( nx + 1 :) = czero ! Compute the FFT to estimate the phase call zfftf ( n , xzeros , wsave ) ind = maxloc ( abs ( xzeros ( 2 : m )), 1 ) + 1 ! start at 2 to avoid any DC issues rst = 2.0d0 * xzeros ( ind ) / nx end function ! ------------------------------------------------------------------------------ function frf_sweep_2 ( fcn , nfreq , freq1 , freq2 , iv , solver , ncycles , & ntransient , points , args , err ) result ( rst ) !! Computes the frequency response of each equation of a system of !! harmonically excited ODE's by sweeping through frequency. use spectrum , only : next_power_of_two use diffeq , only : runge_kutta_45 use dynamics_error_handling procedure ( harmonic_ode ), pointer , intent ( in ) :: fcn !! A pointer to the routine containing the ODE's to integrate. integer ( int32 ), intent ( in ) :: nfreq !! The number of frequency values to analyze.  This value must be !! at least 2. real ( real64 ), intent ( in ) :: freq1 !! The starting frequency.  It is recommended that the units be set !! to Hz. real ( real64 ), intent ( in ) :: freq2 !! The ending frequency.  It is recommended that the units be set to !! Hz. real ( real64 ), intent ( in ), dimension (:) :: iv !! An N-element array containing the initial conditions for each of !! the N ODEs. class ( ode_integrator ), intent ( inout ), optional , target :: solver !! An optional differential equation solver.  The default solver !! is the Dormand-Prince Runge-Kutta integrator from the DIFFEQ !! library. integer ( int32 ), intent ( in ), optional :: ncycles !! An optional parameter controlling the number of cycles to !! analyze when determining the amplitude and phase of the response. !! The default is 20. integer ( int32 ), intent ( in ), optional :: ntransient !! An optional parameter controlling how many of the initial !! \"transient\" cycles to ignore.  The default is 200. integer ( int32 ), intent ( in ), optional :: points !! An optional parameter controlling how many evenly spaced !! solution points should be considered per cycle.  The default is !! 1000.  Notice, there must be at least 2 points per cycle for the !! analysis to be effective.  The algorithm utilizes a discrete !! Fourier transform to determine the phase and amplitude, and in !! order to satisfy Nyquist conditions, the value must be at least !! 2. class ( * ), intent ( inout ), optional :: args !! An optional argument allowing for passing of data in/out of the !! fcn subroutine. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! - DYN_NULL_POINTER_ERROR: Occurs if a null pointer is supplied. !! - DYN_INVALID_INPUT_ERROR: Occurs if an invalid parameter !!      is given. !! - DYN_ZERO_VALUED_FREQUENCY_ERROR: Occurs if a zero-valued !!      frequency was supplied. type ( frf ) :: rst !! The resulting frequency responses. ! Local Variables integer ( int32 ) :: i , flag real ( real64 ) :: df real ( real64 ), allocatable , dimension (:) :: freq class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if ! Input Checking if ( abs ( freq1 - freq2 ) < sqrt ( epsilon ( freq1 ))) then call report_zero_difference_error ( \"hoc_frf_sweep_2\" , & \"freq1\" , freq1 , \"freq2\" , freq2 , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if if ( nfreq < 2 ) then call report_generic_counting_error ( \"hoc_frf_sweep_2\" , & \"The number of frequency points must be at least 2, \" // & \"but was found to be \" , nfreq , \".\" , DYN_INVALID_INPUT_ERROR , & errmgr ) return end if ! Process df = ( freq2 - freq1 ) / ( nfreq - 1.0d0 ) allocate ( freq ( nfreq ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"hoc_frf_sweep_2\" , flag , errmgr ) return end if freq = ( / ( df * i + freq1 , i = 0 , nfreq - 1 ) / ) rst = frf_sweep_1 ( fcn , freq , iv , solver , ncycles , ntransient , & points , args = args , err = err ) end function ! ****************************************************************************** ! VERSION 1.0.5 ADDITIONS ! ------------------------------------------------------------------------------ function siso_freqres ( x , y , fs , win , method , err ) result ( rst ) !! Estimates the frequency response of a single-input, single-output (SISO) !! system. real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the excitation signal. real ( real64 ), intent ( in ), dimension (:) :: y !! An N-element array containing the response signal. real ( real64 ), intent ( in ) :: fs !! The sampling frequency, in Hz. class ( window ), intent ( in ), optional , target :: win !! The window to apply to the data.  If nothing is supplied, no window !! is applied. integer ( int32 ), intent ( in ), optional :: method !! Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an !! H2 estimator.  The default is an H1 estimator. !! !! An H1 estimator is defined as the cross-spectrum of the input and !! response signals divided by the energy spectral density of the input. !! An H2 estimator is defined as the energy spectral density of the !! response divided by the cross-spectrum of the input and response !! signals. !! !!  H_{1} = \\frac{P_{xy}}{P_{xx}}  !! !!  H_{2} = \\frac{P_{yy}}{P_{xy}}  class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! !! - DYN_ARRAY_SIZE_ERROR: Occurs if x and y are not the same size. type ( frf ) :: rst !! The resulting frequency response function. ! Local Variables integer ( int32 ) :: i , npts , nfreq , meth , flag real ( real64 ) :: df class ( window ), pointer :: wptr type ( rectangular_window ), target :: defwin class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x ) if ( present ( win )) then wptr => win else defwin % size = npts wptr => defwin end if if ( present ( method )) then if ( method == 2 ) then meth = SPCTRM_H2_ESTIMATOR else meth = SPCTRM_H1_ESTIMATOR end if else meth = SPCTRM_H1_ESTIMATOR end if nfreq = compute_transform_length ( wptr % size ) allocate ( rst % frequency ( nfreq ), stat = flag ) if ( flag == 0 ) allocate ( rst % responses ( nfreq , 1 ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"siso_freqres\" , flag , errmgr ) return end if ! Input Checking if ( size ( y ) /= npts ) then call report_array_size_error ( \"siso_freqres\" , \"y\" , npts , size ( y ), errmgr ) return end if ! Compute the transfer function rst % responses (:, 1 ) = siso_transfer_function ( wptr , x , y , etype = meth , & err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Compute the frequency vector df = frequency_bin_width ( fs , wptr % size ) rst % frequency = ( / ( df * i , i = 0 , nfreq - 1 ) / ) end function ! ------------------------------------------------------------------------------ function mimo_freqres ( x , y , fs , win , method , err ) result ( rst ) !! Estimates the frequency responses of a multiple-input, multiple-output !! (MIMO) system. real ( real64 ), intent ( in ), dimension (:,:) :: x !! An N-by-P array containing the P inputs to the system. real ( real64 ), intent ( in ), dimension (:,:) :: y !! An N-by-M array containing the M outputs from the system. real ( real64 ), intent ( in ) :: fs !! The sampling frequency, in Hz. class ( window ), intent ( in ), optional , target :: win !! The window to apply to the data.  If nothing is supplied, no window !! is applied. integer ( int32 ), intent ( in ), optional :: method !! Enter 1 to utilize an H1 estimator; else, enter 2 to utilize an !! H2 estimator.  The default is an H1 estimator. !! !! An H1 estimator is defined as the cross-spectrum of the input and !! response signals divided by the energy spectral density of the input. !! An H2 estimator is defined as the energy spectral density of the !! response divided by the cross-spectrum of the input and response !! signals. !! !!  H_{1} = \\frac{P_{xy}}{P_{xx}}  !! !!  H_{2} = \\frac{P_{yy}}{P_{xy}}  class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! !! - DYN_ARRAY_SIZE_ERROR: Occurs if x and y do not have the same number !!   of rows. type ( mimo_frf ) :: rst !! The resulting frequency response functions. ! Local Variables integer ( int32 ) :: i , j , npts , m , p , nfreq , meth , flag real ( real64 ) :: df class ( window ), pointer :: wptr type ( rectangular_window ), target :: defwin class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if npts = size ( x , 1 ) m = size ( y , 2 ) p = size ( x , 2 ) if ( present ( win )) then wptr => win else defwin % size = npts wptr => defwin end if if ( present ( method )) then if ( method == 2 ) then meth = SPCTRM_H2_ESTIMATOR else meth = SPCTRM_H1_ESTIMATOR end if else meth = SPCTRM_H1_ESTIMATOR end if nfreq = compute_transform_length ( wptr % size ) allocate ( rst % frequency ( nfreq ), stat = flag ) if ( flag == 0 ) allocate ( rst % responses ( nfreq , m , p )) if ( flag /= 0 ) then call report_memory_error ( \"mimo_freqres\" , flag , errmgr ) return end if ! Input Checking if ( size ( y , 1 ) /= npts ) then call report_matrix_size_error ( \"mimo_freqres\" , \"y\" , npts , size ( y , 2 ), & size ( y , 1 ), size ( y , 2 ), errmgr ) return end if ! Compute the transfer functions for each possible combination do j = 1 , p do i = 1 , m rst % responses (:, i , j ) = siso_transfer_function ( wptr , & x (:, j ), y (:, i ), etype = meth , err = errmgr ) if ( errmgr % has_error_occurred ()) return end do end do ! Compute the frequency vector df = frequency_bin_width ( fs , wptr % size ) rst % frequency = ( / ( df * i , i = 0 , nfreq - 1 ) / ) end function ! ****************************************************************************** ! V1.0.6 ADDITIONS ! ------------------------------------------------------------------------------ ! SEE: https://www.researchgate.net/publication/224619803_Reduction_of_structure-borne_noise_in_automobiles_by_multivariable_feedback subroutine frf_accel_fit_fcn ( xdata , mdl , rst , stop , args ) !! The FRF fitting function for an accelerance FRF (acceleration-excited). real ( real64 ), intent ( in ), dimension (:) :: xdata !! The independent variable data. real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameters. real ( real64 ), intent ( out ), dimension (:) :: rst !! The model results. logical , intent ( out ) :: stop !! Stop the simulation? class ( * ), intent ( inout ), optional :: args !! Optional arguments from the calling code. ! Local Variables integer ( int32 ) :: i , n complex ( real64 ) :: h ! Process: ! ! The amplitude portion of the response is stored in the first \"N\" locations ! in the output with the phase portion (in radians) is stored in the ! second \"N\" locations. n = size ( xdata ) / 2 do i = 1 , n h = evaluate_accelerance_frf_model ( mdl , xdata ( i )) rst ( i ) = abs ( h ) rst ( i + n ) = atan2 ( aimag ( h ), real ( h )) end do end subroutine ! ------------------------------------------------------------------------------ subroutine frf_force_fit_fcn ( xdata , mdl , rst , stop , args ) !! The FRF fitting function for an force-excited FRF. real ( real64 ), intent ( in ), dimension (:) :: xdata !! The independent variable data. real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameters. real ( real64 ), intent ( out ), dimension (:) :: rst !! The model results. logical , intent ( out ) :: stop !! Stop the simulation? class ( * ), intent ( inout ), optional :: args !! Optional arguments from the calling code. ! Local Variables integer ( int32 ) :: i , n complex ( real64 ) :: h ! Process: ! ! The amplitude portion of the response is stored in the first \"N\" locations ! in the output with the phase portion (in radians) is stored in the ! second \"N\" locations. n = size ( xdata ) / 2 do i = 1 , n h = evaluate_receptance_frf_model ( mdl , xdata ( i )) rst ( i ) = abs ( h ) rst ( i + n ) = atan2 ( aimag ( h ), real ( h )) end do end subroutine ! ------------------------------------------------------------------------------ function fit_frf ( mt , n , freq , rsp , maxp , minp , init , stats , alpha , controls , & settings , info , err ) result ( rst ) use peaks !! Fits an experimentally obtained frequency response by model for either a !! receptance model: !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{A_{i}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega}  !! !! or an accelerance model: !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{-A_{i} \\omega&#94;{2}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega} . !! !! Internally, the code uses a Levenberg-Marquardt solver to determine the !! parameters.  The initial guess for the solver is determined by a !! peak finding algorithm used to locate the resonant modes in frequency. !! from this result, estimates for both the amplitude and natural frequency !! values are obtained.  The damping parameters are assumed to be equal !! for all modes and set to a default value of 0.1. integer ( int32 ), intent ( in ) :: mt !! The excitation method.  The options are as follows. !! !! - FRF_ACCELERANCE_MODEL: Use an accelerance model. !! !! - FRF_RECEPTANCE_MODEL: Use a receptance model. integer ( int32 ), intent ( in ) :: n !! The model order (# of resonant modes). real ( real64 ), intent ( in ), dimension (:) :: freq !! An M-element array containing the excitation frequency values in !! units of rad/s. complex ( real64 ), intent ( in ), dimension (:) :: rsp !! An M-element array containing the frequency response to fit. real ( real64 ), intent ( in ), dimension (:), optional :: maxp !! An optional 3*N-element array that can be used as upper limits on !! the parameter values. If no upper limit is requested for a particular !! parameter, utilize a very large value. The internal default is to !! utilize huge() as a value. real ( real64 ), intent ( in ), dimension (:), optional :: minp !! An optional 3*N-element array that can be used as lower limits on !! the parameter values. If no lower limit is requested for a particalar !! parameter, utilize a very large magnitude, but negative, value. The !! internal default is to utilize -huge() as a value. real ( real64 ), intent ( in ), dimension (:), optional :: init !! An optional 3*N-element array that, if supplied, provides an initial !! guess for each of the 3*N model parameters for the iterative solver. !! If supplied, this array replaces the peak finding algorithm for !! estimating an initial guess. type ( regression_statistics ), intent ( out ), dimension (:), optional :: stats !! An optional 3*N-element array that, if supplied, will be used to !! return statistics about the fit for each model parameter. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence intervals. !! The default value is 0.05 such that a 95% confidence interval is !! calculated. type ( iteration_controls ), intent ( in ), optional :: controls !! An optional input providing custom iteration controls. type ( lm_solver_options ), intent ( in ), optional :: settings !! An optional input providing custom settings for the solver. type ( convergence_info ), intent ( out ), optional :: info !! An optional output that can be used to gain information about the !! iterative solution and the nature of the convergence. class ( errors ), intent ( inout ), optional , target :: err !! An optional errors-based object that if provided !! can be used to retrieve information relating to any errors !! encountered during execution. If not provided, a default !! implementation of the errors class is used internally to provide !! error handling. Possible errors and warning messages that may be !! encountered are as follows. !! !! - DYN_MEMORY_ERROR: Occurs if there are issues allocating memory. !! !! - DYN_ARRAY_SIZE_ERROR: Occurs if freq and rsp are not the same size. !! !! - DYN_UNDERDEFINED_PROBLEM_EROR: Occurs if the requested model !!      order is too high for the number of data points available. !! !! - DYN_TOLERANCE_TOO_SMALL_ERROR: Occurs if the requested solver !!      tolerance is too small to be practical for this problem. !! !! - DYN_TOO_FEW_ITERATIONS_ERROR: Occurs if convergence cannot be !!      achieved in the allowed number of solver iterations. real ( real64 ), allocatable , dimension (:) :: rst !! An array containing the model parameters stored as  \\left[ A_{1}, !! \\omega_{n1}, \\zeta_{1}, A_{2}, \\omega_{n2}, \\zeta_{2} ... \\right] . ! Parameters real ( real64 ), parameter :: zeta = 0.1d0 ! Local Variables class ( errors ), pointer :: errmgr type ( errors ), target :: deferr procedure ( regression_function ), pointer :: fcn integer ( int32 ) :: i , npts , nparam , flag integer ( int32 ), allocatable , dimension (:) :: maxinds , mininds real ( real64 ) :: maxamp , minamp , amprange , delta real ( real64 ), allocatable , dimension (:) :: x , y , maxvals , minvals , & ymod , resid ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if select case ( mt ) case ( FRF_ACCELERANCE_MODEL ) fcn => frf_accel_fit_fcn case ( FRF_RECEPTANCE_MODEL ) fcn => frf_force_fit_fcn case default call errmgr % report_error ( \"fit_frf\" , \"Invalid entry for the \" // & \"variable mt.  Must be either FRF_ACCELERANCE_MODEL or \" // & \"FRF_RECEPTANCE_MODEL.\" , DYN_INVALID_INPUT_ERROR ) return end select npts = size ( freq ) nparam = 3 * n ! Input Checking if ( size ( rsp ) /= npts ) then call report_array_size_error ( \"fit_frf\" , \"rsp\" , npts , size ( rsp ), errmgr ) return end if ! Memory Allocations allocate ( rst ( nparam ), stat = flag ) if ( flag == 0 ) allocate ( & x ( 2 * npts ), & y ( 2 * npts ), & ymod ( 2 * npts ), & resid ( 2 * npts ), & stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"fit_frf\" , flag , errmgr ) return end if ! Determine phase and amplitude terms, and store frequency values do i = 1 , npts ! Store frequency values x ( i ) = freq ( i ) x ( i + npts ) = freq ( i ) ! Store amplitude and phase values y ( i ) = abs ( rsp ( i )) y ( i + npts ) = atan2 ( aimag ( rsp ( i )), real ( rsp ( i ))) ! Determine max and min amplitudes if ( i == 1 ) then maxamp = y ( i ) minamp = y ( i ) else if ( y ( i ) > maxamp ) maxamp = y ( i ) if ( y ( i ) < minamp ) minamp = y ( i ) end if end do amprange = maxamp - minamp if ( present ( init )) then ! Check the array size if ( size ( init ) /= nparam ) then call report_array_size_error ( \"fit_frf\" , \"init\" , nparam , & size ( init ), errmgr ) return end if ! Copy init to rst rst = init else ! Perform the peak location to determine an initial guess at parameters delta = 0.005d0 * amprange call peak_detect ( y ( 1 : npts ), delta , maxinds , maxvals , mininds , minvals ) do i = 1 , min ( n , size ( maxvals )) rst ( 3 * i - 2 ) = maxvals ( i ) ! amplitude rst ( 3 * i - 1 ) = freq ( maxinds ( i )) ! frequency rst ( 3 * i ) = zeta ! damping end do if ( size ( maxvals ) < n ) then ! The peak detection did not find enough peaks. if ( size ( maxvals ) == 0 ) then ! No peaks found.  This is suspicious, but just use a random ! estimate to get started.  Maybe the solver will be able ! to sort it out. call random_number ( rst ) else ! Fill in the remaining parameters with the last set estimate do i = size ( maxvals ) + 1 , n rst ( 3 * i - 2 ) = rst ( 3 * ( i - 1 ) - 2 ) rst ( 3 * i - 1 ) = rst ( 3 * ( i - 1 ) - 1 ) rst ( 3 * i ) = rst ( 3 * ( i - 1 )) end do end if end if end if ! Fit the model call nonlinear_least_squares ( fcn , x , y , rst , ymod , resid , maxp = maxp , & minp = minp , stats = stats , alpha = alpha , controls = controls , & settings = settings , info = info , err = errmgr ) end function ! ------------------------------------------------------------------------------ pure function evaluate_accelerance_frf_model_scalar ( mdl , w ) result ( rst ) !! Evaluates the specified accelerance FRF model.  The model is of !! the following form. !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{-A_{i} \\omega&#94;{2}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega}   real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameter array.  The elements of the array are stored !! as  \\left[ A_{1}, \\omega_{n1}, \\zeta_{1}, A_{2}, \\omega_{n2}, !! \\zeta_{2} ... \\right] . real ( real64 ), intent ( in ) :: w !! The frequency value, in rad/s, at which to evaluate the model. complex ( real64 ) :: rst !! The resulting frequency response function. ! Local Variables integer ( int32 ) :: i , j , n ! Process j = 1 n = size ( mdl ) / 3 rst = ( 0.0d0 , 0.0d0 ) do i = 1 , n rst = rst + frf_accel_model_driver ( mdl ( j ), mdl ( j + 1 ), mdl ( j + 2 ), w ) j = j + 3 end do end function ! ---------- pure function evaluate_accelerance_frf_model_array ( mdl , w ) result ( rst ) !! Evaluates the specified accelerance FRF model.  The model is of !! the following form. !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{-A_{i} \\omega&#94;{2}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega}   real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameter array.  The elements of the array are stored !! as  \\left[ A_{1}, \\omega_{n1}, \\zeta_{1}, A_{2}, \\omega_{n2}, !! \\zeta_{2} ... \\right] . real ( real64 ), intent ( in ), dimension (:) :: w !! The frequency value, in rad/s, at which to evaluate the model. complex ( real64 ), allocatable , dimension (:) :: rst !! The resulting frequency response function. ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( w ) allocate ( rst ( n )) do i = 1 , n rst ( i ) = evaluate_accelerance_frf_model_scalar ( mdl , w ( i )) end do end function ! ---------- pure elemental function frf_accel_model_driver ( A , wn , zeta , w ) result ( rst ) !! Evaluates a single term of the accelerance FRF model. real ( real64 ), intent ( in ) :: A !! The amplitude term. real ( real64 ), intent ( in ) :: wn !! The natural frequency term. real ( real64 ), intent ( in ) :: zeta !! The damping ratio term. real ( real64 ), intent ( in ) :: w !! The excitation frequency. complex ( real64 ) :: rst !! The result. ! Parameters complex ( real64 ), parameter :: j = ( 0.0d0 , 1.0d0 ) ! Process rst = - A * w ** 2 / ( wn ** 2 - w ** 2 + 2.0d0 * j * zeta * wn * w ) end function ! ------------------------------------------------------------------------------ pure function evaluate_receptance_frf_model_scalar ( mdl , w ) result ( rst ) !! Evaluates the specified receptance FRF model.  The model is of !! the following form. !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{A_{i}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega}   real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameter array.  The elements of the array are stored !! as  \\left[ A_{1}, \\omega_{n1}, \\zeta_{1}, A_{2}, \\omega_{n2}, !! \\zeta_{2} ... \\right] . real ( real64 ), intent ( in ) :: w !! The frequency value, in rad/s, at which to evaluate the model. complex ( real64 ) :: rst !! The resulting frequency response function. ! Local Variables integer ( int32 ) :: i , j , n ! Process j = 1 n = size ( mdl ) / 3 rst = ( 0.0d0 , 0.0d0 ) do i = 1 , n rst = rst + frf_receptance_model_driver ( mdl ( j ), mdl ( j + 1 ), mdl ( j + 2 ), w ) j = j + 3 end do end function ! ---------- pure function evaluate_receptance_frf_model_array ( mdl , w ) result ( rst ) !! Evaluates the specified receptance FRF model.  The model is of !! the following form. !! !!  H(\\omega) = \\sum_{i=1}&#94;{n} \\frac{A_{i}}{\\omega_{ni}&#94;{2} - !! \\omega&#94;{2} + 2 j \\zeta_{i} \\omega_{ni} \\omega}   real ( real64 ), intent ( in ), dimension (:) :: mdl !! The model parameter array.  The elements of the array are stored !! as  \\left[ A_{1}, \\omega_{n1}, \\zeta_{1}, A_{2}, \\omega_{n2}, !! \\zeta_{2} ... \\right] . real ( real64 ), intent ( in ), dimension (:) :: w !! The frequency value, in rad/s, at which to evaluate the model. complex ( real64 ), allocatable , dimension (:) :: rst !! The resulting frequency response function. ! Local Variables integer ( int32 ) :: i , n ! Process n = size ( w ) allocate ( rst ( n )) do i = 1 , n rst ( i ) = evaluate_receptance_frf_model_scalar ( mdl , w ( i )) end do end function ! ---------- pure elemental function frf_receptance_model_driver ( A , wn , zeta , w ) result ( rst ) !! Evaluates a single term of the receptance FRF model. real ( real64 ), intent ( in ) :: A !! The amplitude term. real ( real64 ), intent ( in ) :: wn !! The natural frequency term. real ( real64 ), intent ( in ) :: zeta !! The damping ratio term. real ( real64 ), intent ( in ) :: w !! The excitation frequency. complex ( real64 ) :: rst !! The result. ! Parameters complex ( real64 ), parameter :: j = ( 0.0d0 , 1.0d0 ) ! Process rst = A / ( wn ** 2 - w ** 2 + 2.0d0 * j * zeta * wn * w ) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_frequency_response.f90.html"},{"title":"dynamics_helper.f90 – DYNAMICS","text":"Contents Modules dynamics_helper Source Code dynamics_helper.f90 Source Code module dynamics_helper use iso_fortran_env implicit none private public :: cross_product public :: to_skew_symmetric contains ! ------------------------------------------------------------------------------ pure function cross_product ( x , y ) result ( rst ) !! Computes the cross-product of a vector. real ( real64 ), intent ( in ) :: x ( 3 ) !! The left-hand-side argument. real ( real64 ), intent ( in ) :: y ( 3 ) !! The right-hand-side argument real ( real64 ) :: rst ( 3 ) !! The resulting vector. rst ( 1 ) = x ( 2 ) * y ( 3 ) - x ( 3 ) * y ( 2 ) rst ( 2 ) = x ( 3 ) * y ( 1 ) - x ( 1 ) * y ( 3 ) rst ( 3 ) = x ( 1 ) * y ( 2 ) - x ( 2 ) * y ( 1 ) end function ! ------------------------------------------------------------------------------ pure function to_skew_symmetric ( x ) result ( rst ) !! Converts a 3-element vector to a 3-by-3 skew-symmetric matrix.  A !! skew-symmetric matrix is defined as follows. !! !!  \\tilde{x} = \\left[ \\begin{matrix} 0 & -x_{3} & x_{2} \\\\ !! x_{3} & 0 & -x_{1} \\\\ -x_{2} & x_{1} & 0 \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: x ( 3 ) !! The vector. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting skew-symmetric matrix. ! Process rst = reshape ([ & 0.0d0 , x ( 3 ), - x ( 2 ), & - x ( 3 ), 0.0d0 , x ( 1 ), & x ( 2 ), - x ( 1 ), 0.0d0 & ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_helper.f90.html"},{"title":"dynamics_kinematics.f90 – DYNAMICS","text":"Contents Modules dynamics_kinematics Source Code dynamics_kinematics.f90 Source Code module dynamics_kinematics use iso_fortran_env use nonlin_core use nonlin_least_squares , only : least_squares_solver use ferror use dynamics_error_handling use dynamics_helper implicit none private public :: identity_4 public :: dh_rotate_x public :: dh_rotate_z public :: dh_translate_x public :: dh_translate_z public :: dh_matrix public :: dh_forward_kinematics public :: solve_inverse_kinematics public :: vecfcn public :: least_squares_solver public :: iteration_behavior public :: jacobian_generating_vector public :: dh_jacobian public :: REVOLUTE_JOINT public :: PRISMATIC_JOINT interface dh_forward_kinematics module procedure :: dh_forward_kinematics_2 module procedure :: dh_forward_kinematics_3 module procedure :: dh_forward_kinematics_4 module procedure :: dh_forward_kinematics_5 module procedure :: dh_forward_kinematics_6 module procedure :: dh_forward_kinematics_7 module procedure :: dh_forward_kinematics_8 module procedure :: dh_forward_kinematics_array end interface interface dh_jacobian module procedure :: dh_build_jacobian end interface integer ( int32 ), parameter :: REVOLUTE_JOINT = 0 !! Defines a revolute joint. integer ( int32 ), parameter :: PRISMATIC_JOINT = 1 !! Defines a prismatic joint. ! ------------------------------------------------------------------------------ ! PRIVATE VARIABLES - INVERSE KINEMATICS procedure ( vecfcn ), pointer , private :: kinematics_equations real ( real64 ), pointer , private , dimension (:) :: kinematic_constraints contains ! ------------------------------------------------------------------------------ pure function identity_4 () result ( rst ) !! Computes a 4-by-4 identity matrix. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting identity matrix. ! Local Variables & Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Process rst ( 1 , 1 ) = one rst ( 2 , 1 ) = zero rst ( 3 , 1 ) = zero rst ( 4 , 1 ) = zero rst ( 1 , 2 ) = zero rst ( 2 , 2 ) = one rst ( 3 , 2 ) = zero rst ( 4 , 2 ) = zero rst ( 1 , 3 ) = zero rst ( 2 , 3 ) = zero rst ( 3 , 3 ) = one rst ( 4 , 3 ) = zero rst ( 1 , 4 ) = zero rst ( 2 , 4 ) = zero rst ( 3 , 4 ) = zero rst ( 4 , 4 ) = one end function ! ------------------------------------------------------------------------------ pure function dh_rotate_x ( alpha ) result ( rst ) !! Computes the Denavit-Hartenberg matrix for a local x-axis rotation. real ( real64 ), intent ( in ) :: alpha !! The rotation angle, in radians. real ( real64 ) :: rst ( 4 , 4 ) !! The matrix. ! Local Variables & Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ) :: cx , sx ! Process cx = cos ( alpha ) sx = sin ( alpha ) rst ( 1 , 1 ) = one rst ( 2 , 1 ) = zero rst ( 3 , 1 ) = zero rst ( 4 , 1 ) = zero rst ( 1 , 2 ) = zero rst ( 2 , 2 ) = cx rst ( 3 , 2 ) = sx rst ( 4 , 2 ) = zero rst ( 1 , 3 ) = zero rst ( 2 , 3 ) = - sx rst ( 3 , 3 ) = cx rst ( 4 , 3 ) = zero rst ( 1 , 4 ) = zero rst ( 2 , 4 ) = zero rst ( 3 , 4 ) = zero rst ( 4 , 4 ) = one end function ! ------------------------------------------------------------------------------ pure function dh_rotate_z ( theta ) result ( rst ) !! Computes the Denavit-Hartenberg matrix for a local z-axis rotation. real ( real64 ), intent ( in ) :: theta !! The rotation angle, in radians. real ( real64 ) :: rst ( 4 , 4 ) !! The matrix. ! Local Variables & Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 real ( real64 ) :: cx , sx ! Process cx = cos ( theta ) sx = sin ( theta ) rst ( 1 , 1 ) = cx rst ( 2 , 1 ) = sx rst ( 3 , 1 ) = zero rst ( 4 , 1 ) = zero rst ( 1 , 2 ) = - sx rst ( 2 , 2 ) = cx rst ( 3 , 2 ) = zero rst ( 4 , 2 ) = zero rst ( 1 , 3 ) = zero rst ( 2 , 3 ) = zero rst ( 3 , 3 ) = one rst ( 4 , 3 ) = zero rst ( 1 , 4 ) = zero rst ( 2 , 4 ) = zero rst ( 3 , 4 ) = zero rst ( 4 , 4 ) = one end function ! ------------------------------------------------------------------------------ pure function dh_translate_x ( a ) result ( rst ) !! Computes the Denavit-Hartenberg matrix for a local x-axis !! translation. real ( real64 ), intent ( in ) :: a !! The translation. real ( real64 ) :: rst ( 4 , 4 ) !! The matrix. ! Local Variables & Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Process rst ( 1 , 1 ) = one rst ( 2 , 1 ) = zero rst ( 3 , 1 ) = zero rst ( 4 , 1 ) = zero rst ( 1 , 2 ) = zero rst ( 2 , 2 ) = one rst ( 3 , 2 ) = zero rst ( 4 , 2 ) = zero rst ( 1 , 3 ) = zero rst ( 2 , 3 ) = zero rst ( 3 , 3 ) = one rst ( 4 , 3 ) = zero rst ( 1 , 4 ) = a rst ( 2 , 4 ) = zero rst ( 3 , 4 ) = zero rst ( 4 , 4 ) = one end function ! ------------------------------------------------------------------------------ pure function dh_translate_z ( d ) result ( rst ) !! Computes the Denavit-Hartenberg matrix for a local z-axis !! translation. real ( real64 ), intent ( in ) :: d !! The translation. real ( real64 ) :: rst ( 4 , 4 ) !! The matrix. ! Local Variables & Parameters real ( real64 ), parameter :: zero = 0.0d0 real ( real64 ), parameter :: one = 1.0d0 ! Process rst ( 1 , 1 ) = one rst ( 2 , 1 ) = zero rst ( 3 , 1 ) = zero rst ( 4 , 1 ) = zero rst ( 1 , 2 ) = zero rst ( 2 , 2 ) = one rst ( 3 , 2 ) = zero rst ( 4 , 2 ) = zero rst ( 1 , 3 ) = zero rst ( 2 , 3 ) = zero rst ( 3 , 3 ) = one rst ( 4 , 3 ) = zero rst ( 1 , 4 ) = zero rst ( 2 , 4 ) = zero rst ( 3 , 4 ) = d rst ( 4 , 4 ) = one end function ! ------------------------------------------------------------------------------ pure function dh_matrix ( alpha , a , theta , d ) result ( rst ) !! Computes the Denavit-Hartenberg transformation matrix for the !! specified DH parameters. real ( real64 ), intent ( in ) :: alpha !! The link twist angle, in radians.  This angle is the required !! rotation of the z(i-1) axis about the link's x-axis to become !! parallel with the link's z-axis. real ( real64 ), intent ( in ) :: a !! The link length as measured along the link's x-axis. real ( real64 ), intent ( in ) :: theta !! The joint angle, in radians.  This angle is the required rotation !! of the z(i-1) axis about the z(i-1) axis to become parallel with !! the link's x-axis. real ( real64 ), intent ( in ) :: d !! The joint offset distance measured as the distance between the !! x(i-1) axis and the link's x-axis along the z(i-1) axis. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting 4-by-4 transformation matrix. ! Local Variables real ( real64 ), dimension ( 4 , 4 ) :: Rx , Dx , Rz , Dz , DxRx , RzDxRx ! Compute the matrices Rx = dh_rotate_x ( alpha ) Dx = dh_translate_x ( a ) Rz = dh_rotate_z ( theta ) Dz = dh_translate_z ( d ) ! Perform the multiplication DxRx = matmul ( Dx , Rx ) RzDxRx = matmul ( Rz , DxRx ) rst = matmul ( Dz , RzDxRx ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_2 ( T1 , T2 ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Process rst = matmul ( T1 , T2 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_3 ( T1 , T2 , T3 ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_2 ( T1 , T2 ) rst = matmul ( T0 , T3 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_4 ( T1 , T2 , T3 , T4 ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ), intent ( in ) :: T4 ( 4 , 4 ) !! The transformation matrix for the fourth link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_3 ( T1 , T2 , T3 ) rst = matmul ( T0 , T4 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_5 ( T1 , T2 , T3 , T4 , T5 ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ), intent ( in ) :: T4 ( 4 , 4 ) !! The transformation matrix for the fourth link in the linkage. real ( real64 ), intent ( in ) :: T5 ( 4 , 4 ) !! The transformation matrix for the fifth link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_4 ( T1 , T2 , T3 , T4 ) rst = matmul ( T0 , T5 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_6 ( T1 , T2 , T3 , T4 , T5 , T6 ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ), intent ( in ) :: T4 ( 4 , 4 ) !! The transformation matrix for the fourth link in the linkage. real ( real64 ), intent ( in ) :: T5 ( 4 , 4 ) !! The transformation matrix for the fifth link in the linkage. real ( real64 ), intent ( in ) :: T6 ( 4 , 4 ) !! The transformation matrix for the sixth link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_5 ( T1 , T2 , T3 , T4 , T5 ) rst = matmul ( T0 , T6 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_7 ( T1 , T2 , T3 , T4 , T5 , T6 , T7 ) & result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ), intent ( in ) :: T4 ( 4 , 4 ) !! The transformation matrix for the fourth link in the linkage. real ( real64 ), intent ( in ) :: T5 ( 4 , 4 ) !! The transformation matrix for the fifth link in the linkage. real ( real64 ), intent ( in ) :: T6 ( 4 , 4 ) !! The transformation matrix for the sixth link in the linkage. real ( real64 ), intent ( in ) :: T7 ( 4 , 4 ) !! The transformation matrix for the seventh link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_6 ( T1 , T2 , T3 , T4 , T5 , T6 ) rst = matmul ( T0 , T7 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_8 ( T1 , T2 , T3 , T4 , T5 , T6 , T7 , T8 ) & result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism. real ( real64 ), intent ( in ) :: T1 ( 4 , 4 ) !! The transformation matrix for the first link nearest ground in !! the linkage. real ( real64 ), intent ( in ) :: T2 ( 4 , 4 ) !! The transformation matrix for the second link in the linkage. real ( real64 ), intent ( in ) :: T3 ( 4 , 4 ) !! The transformation matrix for the third link in the linkage. real ( real64 ), intent ( in ) :: T4 ( 4 , 4 ) !! The transformation matrix for the fourth link in the linkage. real ( real64 ), intent ( in ) :: T5 ( 4 , 4 ) !! The transformation matrix for the fifth link in the linkage. real ( real64 ), intent ( in ) :: T6 ( 4 , 4 ) !! The transformation matrix for the sixth link in the linkage. real ( real64 ), intent ( in ) :: T7 ( 4 , 4 ) !! The transformation matrix for the seventh link in the linkage. real ( real64 ), intent ( in ) :: T8 ( 4 , 4 ) !! The transformation matrix for the eigth link in the linkage. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting transformation matrix. ! Local Variables real ( real64 ) :: T0 ( 4 , 4 ) ! Process T0 = dh_forward_kinematics_7 ( T1 , T2 , T3 , T4 , T5 , T6 , T7 ) rst = matmul ( T0 , T8 ) end function ! ------------------------------------------------------------------------------ pure function dh_forward_kinematics_array ( alpha , a , theta , d ) result ( rst ) !! Assembles all of the individual link transformation matrices into a !! single transformation matrix locating the end-effector in the parent !! coordinate system for the overall mechanism.  The first entry must !! be from the first link nearest ground. real ( real64 ), intent ( in ), dimension (:) :: alpha !! The link twist angles, in radians.  This angle is the required !! rotation of the z(i-1) axis about the link's x-axis to become !! parallel with the link's z-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: a !! The link lengths as measured along the link's x-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: theta !! The joint angles, in radians.  This angle is the required rotation !! of the z(i-1) axis about the z(i-1) axis to become parallel with !! the link's x-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: d !! The joint offsets distance measured as the distance between the !! x(i-1) axis and the link's x-axis along the z(i-1) axis. real ( real64 ) :: rst ( 4 , 4 ) !! The resulting 4-by-4 transformation matrix. ! Local Variables integer ( int32 ) :: i , n real ( real64 ) :: Ti ( 4 , 4 ) ! Initialization n = size ( alpha ) rst = identity_4 () ! Process do i = 1 , n Ti = dh_matrix ( alpha ( i ), a ( i ), theta ( i ), d ( i )) rst = matmul ( rst , Ti ) end do end function ! ------------------------------------------------------------------------------ function solve_inverse_kinematics ( mdl , qo , constraints , df , & slvr , ib , err ) result ( rst ) !! Solves the inverse kinematics problem for a linkage.  An iterative !! solution procedure is utilized. procedure ( vecfcn ), intent ( in ), pointer :: mdl !! A routine used to compute the error in the kinematics !! equations based upon the current solution estimate. real ( real64 ), intent ( in ), dimension (:) :: qo !! An M-element array containing an initial estimate of the M joint !! variables. real ( real64 ), intent ( in ), target , dimension (:) :: constraints !! An N-element array containing the target values (constraints) for !! each of the N kinematic equations in the model.  N must be at !! least equal to M (the number of joint variables). real ( real64 ), intent ( out ), optional , target , dimension (:) :: df !! An optional N-element array that, if supplied, can be used to !! retrieve the residuals of each of the N kinematic equations. class ( least_squares_solver ), intent ( inout ), optional , target :: slvr !! An optional solver that can be used in place of the default !! Levenberg-Marquardt solver. type ( iteration_behavior ), intent ( out ), optional :: ib !! An optional output that can be used to gather information on the !! solver. class ( errors ), intent ( inout ), optional , target :: err !! An errors-based object that if provided can be used to retrieve !! information relating to any errors encountered during execution. real ( real64 ), allocatable , dimension (:) :: rst !! An M-element array containing the computed joint variables. ! Local Variables integer ( int32 ) :: nvar , neqn , flag real ( real64 ), pointer , dimension (:) :: resid real ( real64 ), allocatable , target , dimension (:) :: dresid type ( vecfcn_helper ) :: helper class ( least_squares_solver ), pointer :: solver type ( least_squares_solver ), target :: default_solver procedure ( vecfcn ), pointer :: fcn class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nvar = size ( qo ) neqn = size ( constraints ) if ( present ( slvr )) then solver => slvr else solver => default_solver end if kinematics_equations => mdl kinematic_constraints => constraints ! Input Check if ( neqn < nvar ) then call report_constraint_count_error ( \"solve_inverse_kinematics\" , & nvar , neqn , errmgr ) return end if if ( present ( df )) then if ( size ( df ) /= neqn ) then call report_array_size_error ( \"solve_inverse_kinematics\" , \"df\" , & neqn , size ( df ), errmgr ) return end if end if ! Set up the solver fcn => inverse_kinematics_solver call helper % set_fcn ( fcn , neqn , nvar ) ! Local Memory Allocations allocate ( rst ( nvar ), source = qo , stat = flag ) if ( present ( df )) then resid => df else if ( flag == 0 ) allocate ( dresid ( neqn ), stat = flag ) if ( flag == 0 ) resid => dresid end if if ( flag /= 0 ) then call report_memory_error ( \"solve_inverse_kinematics\" , flag , errmgr ) return end if ! Solve the problem call solver % solve ( helper , rst , resid , ib = ib , err = errmgr ) end function ! ---------- subroutine inverse_kinematics_solver ( x , f ) ! Routine called by the inverse kinematics solver real ( real64 ), intent ( in ), dimension (:) :: x real ( real64 ), intent ( out ), dimension (:) :: f ! Compute the kinematics equations call kinematics_equations ( x , f ) ! Compare with the constraints f = f - kinematic_constraints end subroutine ! ****************************************************************************** ! V1.0.8 ADDITIONS ! JAN. 29, 2025 ! ------------------------------------------------------------------------------ pure function jacobian_generating_vector ( d , k , R , jtype ) result ( rst ) !! Computes a single Jacobian generating vector given the position vector !! of the link origin, \\vec{d}, and the joint axis unit vector, !! \\vec{k}. !! !! For a revolute joint: !! !!  \\vec{c_{i}} = \\left( \\begin{matrix} !! R \\left( \\hat{k} \\times \\vec{d_{i-1}} \\right) \\\\ !! \\vec{k_{i-1}} \\end{matrix} \\right)  !! !! For a prismatic joint: !! !!  \\vec{c_{i}} = \\left( \\begin{matrix} \\vec{k_{i-1}} \\\\ 0 \\end{matrix} !! \\right)  !! !! The Jacobian matrix is then constructed from the Jacobian generating !! vectors as follows. !! !!  J = \\left[ \\begin{matrix} \\vec{c_1} & \\vec{c_2} & ... & \\vec{c_n} !! \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: d ( 3 ) !! The position vector of the end-effector, \\vec{d}, relative to the !! link coordinate frame given in the base coordinate frame.  An easy !! way to compute this vector is to extract the first 3 elements of the !! 4th column of the transformation matrix: T_{i} T_{i+1} ... T_{n}. real ( real64 ), intent ( in ) :: k ( 3 ) !! The unit vector defining the joint axis, \\vec{k}, given in the !! base coordinate frame.  This vector can be computed most easily by !! using the transformation matrix: T = T_1 T_2 ... T_{i-1} and !! then computing \\vec{k_{i-1}} = T \\hat{k}. real ( real64 ), intent ( in ) :: R ( 3 , 3 ) !! The rotation matrix defining the orientation of the link coordinate !! frame relative to the base coordinate frame. integer ( int32 ), intent ( in ) :: jtype !! The joint type.  Must be either REVOLUTE_JOINT or PRISMATIC_JOINT. !! If incorrectly specified, the code defaults to a REVOLUTE_JOINT type. real ( real64 ) :: rst ( 6 ) !! The resulting 6-element Jacobian generating vector. ! Parameter real ( real64 ), parameter :: zi ( 3 ) = [ 0.0d0 , 0.0d0 , 1.0d0 ] ! Local Variables real ( real64 ) :: kmag , kcrossd , kunit ( 3 ) ! Ensure k is a unit vector kmag = norm2 ( k ) kunit = k / kmag ! Process if ( jtype == PRISMATIC_JOINT ) then rst ( 1 : 3 ) = kunit rst ( 4 : 6 ) = 0.0d0 else ! Compute the cross-product term rst ( 1 : 3 ) = matmul ( R , cross_product ( zi , d )) ! Fill in the remaining components rst ( 4 : 6 ) = kunit end if end function ! ------------------------------------------------------------------------------ function dh_build_jacobian ( alpha , a , theta , d , jtypes ) result ( rst ) !! Builds the Jacobian matrix for a linkage given the Denavit-Hartenberg !! parameters.  The first entry in each array must be from the first link !! nearest ground.  The Jacobian matrix relates the joint velocities !! \\dot{\\vec{q}} to the end-effector velocity \\dot{\\vec{X}} by !! \\dot{\\vec{X}} = J \\dot{\\vec{q}}. real ( real64 ), intent ( in ), dimension (:) :: alpha !! The link twist angles, in radians.  This angle is the required !! rotation of the z(i-1) axis about the link's x-axis to become !! parallel with the link's z-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: a !! The link lengths as measured along the link's x-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: theta !! The joint angles, in radians.  This angle is the required rotation !! of the z(i-1) axis about the z(i-1) axis to become parallel with !! the link's x-axis. real ( real64 ), intent ( in ), dimension ( size ( alpha )) :: d !! The joint offsets distance measured as the distance between the !! x(i-1) axis and the link's x-axis along the z(i-1) axis. integer ( int32 ), intent ( in ), dimension ( size ( alpha )) :: jtypes !! The types of each joint.  Must be either REVOLUTE_JOINT or !! PRISMATIC_JOINT.  The code defaults to REVOLUTE_JOINT. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting 6-by-N Jacobian matrix where N is the number of joint !! variables (i.e. the length of the input arrays). ! Parameters real ( real64 ), parameter :: zi_1 ( 4 ) = [ 0.0d0 , 0.0d0 , 1.0d0 , 0.0d0 ] ! Local Variables integer ( int32 ) :: i , j , n real ( real64 ) :: Ti ( 4 , 4 ), T ( 4 , 4 ), Te ( 4 , 4 ), temp ( 4 , 4 ), di_1 ( 3 ), ki_1 ( 4 ) ! Initialization n = size ( alpha ) T = identity_4 () allocate ( rst ( 6 , n )) ! Process do i = 1 , n ! Compute the orientation vector ki_1 = matmul ( T , zi_1 ) ! Compute the link transformation matrix Ti = dh_matrix ( alpha ( i ), a ( i ), theta ( i ), d ( i )) ! Compute the transformation matrix relating the link to the end ! effector. Te = Ti do j = i + 1 , n temp = dh_matrix ( alpha ( j ), a ( j ), theta ( j ), d ( j )) Te = matmul ( Te , temp ) end do ! Compute the end-effector position vector di_1 = Te ( 1 : 3 , 4 ) ! Compute the Jacobian generating vector rst (:, i ) = jacobian_generating_vector ( di_1 , ki_1 ( 1 : 3 ), T ( 1 : 3 , 1 : 3 ), & jtypes ( i )) ! Update the transformation matrix T = matmul ( T , Ti ) end do end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_kinematics.f90.html"},{"title":"dynamics_rotation.f90 – DYNAMICS","text":"Contents Modules dynamics_rotation Source Code dynamics_rotation.f90 Source Code module dynamics_rotation use iso_fortran_env use dynamics_helper implicit none private public :: rotate_x public :: rotate_y public :: rotate_z public :: rotate public :: acceleration_transform public :: velocity_transform interface rotate module procedure :: rotate_general_1 module procedure :: rotate_general_2 end interface contains ! ------------------------------------------------------------------------------ pure function rotate_x ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about an !! x-axis such that !!  \\overrightarrow{r_2} = \\textbf{R}_x \\overrightarrow{r_1} . !! !!  \\textbf{R}_x = \\left[ \\begin{matrix} 1 & 0 & 0 \\\\ 0 & !! \\cos{\\theta_x} & -\\sin{\\theta_x} \\\\ 0 & \\sin{\\theta_x} & !! \\cos{\\theta_x} \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ 1.0d0 , 0.0d0 , 0.0d0 , 0.0d0 , c , s , 0.0d0 , - s , c ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ pure function rotate_y ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about a y-axis !! such that !!  \\overrightarrow{r_2} = \\textbf{R}_y \\overrightarrow{r_1} . !! !!  \\textbf{R}_y = \\left[ \\begin{matrix} \\cos{\\theta_y} & 0 & !! \\sin{\\theta_y} \\\\ 0 & 1 & 0 \\\\ -\\sin{\\theta_y} & 0 & !! \\cos{\\theta_y} \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ c , 0.0d0 , - s , 0.0d0 , 1.0d0 , 0.0d0 , s , 0.0d0 , c ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ pure function rotate_z ( angle ) result ( rst ) !! Constructs the rotation matrix describing a rotation about a y-axis !! such that !!  \\overrightarrow{r_2} = \\textbf{R}_z \\overrightarrow{r_1} . !! !!  \\textbf{R}_z = \\left[ \\begin{matrix} \\cos{\\theta_z} & !! -\\sin{\\theta_z} & 0 \\\\ \\sin{\\theta_z} & \\cos{\\theta_z} & 0 \\\\ !! 0 & 0 & 1 \\\\ \\end{matrix} \\right]  real ( real64 ), intent ( in ) :: angle !! The rotation angle, in radians. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. ! Local Variables real ( real64 ) :: c , s ! Process c = cos ( angle ) s = sin ( angle ) rst = reshape ([ c , s , 0.0d0 , - s , c , 0.0d0 , 0.0d0 , 0.0d0 , 1.0d0 ], [ 3 , 3 ]) end function ! ------------------------------------------------------------------------------ pure function rotate_general_1 ( i , j , k , Ip , Jp , Kp ) result ( rst ) !! Constructs a rotation matrix when the orientation of the coordinate !! frame of interest is known relative to the parent coordinate frame. !! !! The matrix is of the following form. !! !!  \\textbf{R} = \\left[ \\begin{matrix} !! \\vec{I_p} \\cdot \\vec{i} & \\vec{I_p} \\cdot \\vec{j} & !! \\vec{I_p} \\cdot \\vec{k} \\\\ \\vec{J_p} \\cdot \\vec{i} & !! \\vec{J_p} \\cdot \\vec{j} & \\vec{J_p} \\cdot \\vec{k} \\\\ !! \\vec{K_p} \\cdot \\vec{i} & \\vec{K_p} \\cdot \\vec{j} & !! \\vec{K_p} \\cdot \\vec{k} \\\\ \\end{matrix} \\right]  !! !! This routine does not check for orthogonallity or unit vector length; !! therefore, to ensure correct results it is the callers responsibility !! to ensure each vector is of unit length and that the unit vectors !! are properly orthogonal. real ( real64 ), intent ( in ) :: i ( 3 ) !! The rotated coordinate frame x-axis unit vector. real ( real64 ), intent ( in ) :: j ( 3 ) !! The rotated coordinate frame y-axis unit vector. real ( real64 ), intent ( in ) :: k ( 3 ) !! The rotated coordinate frame z-axis unit vector. real ( real64 ), intent ( in ) :: Ip ( 3 ) !! The parent coordinate frame x-axis unit vector. real ( real64 ), intent ( in ) :: Jp ( 3 ) !! The parent coordinate frame y-axis unit vector. real ( real64 ), intent ( in ) :: Kp ( 3 ) !! The parent coordinate frame z-axis unit vector. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. rst ( 1 , 1 ) = dot_product ( Ip , i ) rst ( 2 , 1 ) = dot_product ( Jp , i ) rst ( 3 , 1 ) = dot_product ( Kp , i ) rst ( 1 , 2 ) = dot_product ( Ip , j ) rst ( 2 , 2 ) = dot_product ( Jp , j ) rst ( 3 , 2 ) = dot_product ( Kp , j ) rst ( 1 , 3 ) = dot_product ( Ip , k ) rst ( 2 , 3 ) = dot_product ( Jp , k ) rst ( 3 , 3 ) = dot_product ( Kp , k ) end function ! ------------------------------------------------------------------------------ pure function rotate_general_2 ( i , j , k ) result ( rst ) !! Constructs a rotation matrix when the orientation of the coordinate !! frame of interest is known relative to the parent coordinate frame. !! !! The matrix is of the following form. !! !!  \\textbf{R} = \\left[ \\begin{matrix} !! \\vec{I_p} \\cdot \\vec{i} & \\vec{I_p} \\cdot \\vec{j} & !! \\vec{I_p} \\cdot \\vec{k} \\\\ \\vec{J_p} \\cdot \\vec{i} & !! \\vec{J_p} \\cdot \\vec{j} & \\vec{J_p} \\cdot \\vec{k} \\\\ !! \\vec{K_p} \\cdot \\vec{i} & \\vec{K_p} \\cdot \\vec{j} & !! \\vec{K_p} \\cdot \\vec{k} \\\\ \\end{matrix} \\right]  !! !! The parent coordinate frame is assumed to be as follows. !! !!  \\vec{I_p} = \\left( \\begin{matrix} 1 & 0 & 0  \\end{matrix} \\right)  !! !!  \\vec{J_p} = \\left( \\begin{matrix} 0 & 1 & 0  \\end{matrix} \\right)  !! !!  \\vec{K_p} = \\left( \\begin{matrix} 0 & 0 & 1  \\end{matrix} \\right)  !! !! This routine does not check for orthogonallity or unit vector length; !! therefore, to ensure correct results it is the callers responsibility !! to ensure each vector is of unit length and that the unit vectors !! are properly orthogonal. real ( real64 ), intent ( in ) :: i ( 3 ) !! The rotated coordinate frame x-axis unit vector. real ( real64 ), intent ( in ) :: j ( 3 ) !! The rotated coordinate frame y-axis unit vector. real ( real64 ), intent ( in ) :: k ( 3 ) !! The rotated coordinate frame z-axis unit vector. real ( real64 ) :: rst ( 3 , 3 ) !! The resulting 3-by-3 matrix. rst = rotate_general_1 ( i , j , k , [ 1.0d0 , 0.0d0 , 0.0d0 ], & [ 0.0d0 , 1.0d0 , 0.0d0 ], [ 0.0d0 , 0.0d0 , 1.0d0 ]) end function ! ****************************************************************************** ! REVISION 1.0.8 ADDITIONS ! ------------------------------------------------------------------------------ pure function acceleration_transform ( alpha , omega , a , x ) result ( rst ) !! Computes the acceleration transformation matrix relating the !! position of a point expressed in a rotating and translating body !! relative to its parent frame. !! !! The transformation matrix takes the following form. !! !!  A = \\left[ \\begin{matrix} \\tilde{\\alpha} - \\tilde{\\omega} !! \\tilde{\\omega}&#94;{T} & \\vec{a} - \\left( \\tilde{\\alpha} - \\tilde{\\omega} !! \\tilde{\\omega}&#94;{T} \\right) \\vec{x} \\\\ 0 & 0 \\end{matrix} \\right]  !! !! where, !! !!  \\tilde{\\alpha} = \\left[ \\begin{matrix} 0 & -\\alpha_z & \\alpha_y \\\\ !! \\alpha_z & 0 & -\\alpha_x \\\\ -\\alpha_y & \\alpha_x & 0 \\end{matrix} !! \\right]  !! !! and, !! !!  \\tilde{\\omega} = \\left[ \\begin{matrix} 0 & -\\omega_z & \\omega_y \\\\ !! \\omega_z & 0 & -\\omega_x \\\\ -\\omega_y & \\omega_x & 0 \\end{matrix} !! \\right]  !! !! Given a vector describing the location on a moving body, !! \\vec{r_p}, the matrix is used to report its acceleration !! \\vec{a_p} = A \\vec{r_p}. real ( real64 ), intent ( in ) :: alpha ( 3 ) !! The angular acceleration vector. real ( real64 ), intent ( in ) :: omega ( 3 ) !! The angular velocity vector. real ( real64 ), intent ( in ) :: a ( 3 ) !! The translational acceleration vector describing the acceleration !! of the body in its parent coordinate frame. real ( real64 ), intent ( in ) :: x ( 3 ) !! The position vector of the body in its parent coordinate frame. real ( real64 ) :: rst ( 4 , 4 ) !! The 4-by-4 transformation matrix. ! Compute alpha = alpha - omega * omega**T rst ( 1 , 1 ) = - omega ( 3 ) ** 2 - omega ( 2 ) ** 2 rst ( 2 , 1 ) = omega ( 1 ) * omega ( 2 ) + alpha ( 3 ) rst ( 3 , 1 ) = omega ( 1 ) * omega ( 3 ) - alpha ( 2 ) rst ( 4 , 1 ) = 0.0d0 rst ( 1 , 2 ) = omega ( 1 ) * omega ( 2 ) - alpha ( 3 ) rst ( 2 , 2 ) = - omega ( 3 ) ** 2 - omega ( 1 ) ** 2 rst ( 3 , 2 ) = omega ( 2 ) * omega ( 3 ) + alpha ( 1 ) rst ( 4 , 2 ) = 0.0d0 rst ( 1 , 3 ) = omega ( 1 ) * omega ( 3 ) + alpha ( 2 ) rst ( 2 , 3 ) = omega ( 2 ) * omega ( 3 ) - alpha ( 1 ) rst ( 3 , 3 ) = - omega ( 2 ) ** 2 - omega ( 1 ) ** 2 rst ( 4 , 3 ) = 0.0d0 ! Compute a - (alpha - omega * omega**T) x rst ( 1 : 3 , 4 ) = a - matmul ( rst ( 1 : 3 , 1 : 3 ), x ) rst ( 4 , 4 ) = 0.0d0 end function ! ------------------------------------------------------------------------------ pure function velocity_transform ( omega , v , x ) result ( rst ) !! Computes the velocity transformation matrix relating the position !! of a point expressed in a rotating and translating body relative to !! its parent frame. !! !! The transformation matrix takes the following form. !! !!  V = \\left[ \\begin{matrix} \\tilde{\\omega} & \\vec{v} - !! \\tilde{\\omega} \\vec{x} \\\\ 0 & 0 \\end{matrix} \\right]  !! !! where, !! !!  \\tilde{\\omega} = \\left[ \\begin{matrix} 0 & -\\omega_z & \\omega_y \\\\ !! \\omega_z & 0 & -\\omega_x \\\\ -\\omega_y & \\omega_x & 0 \\end{matrix} !! \\right]  !! !! Given a vector describing the location on a moving body, !! \\vec{r_p}, the matrix is used to report its velocity !! \\vec{v_p} = V \\vec{r_p}. real ( real64 ), intent ( in ) :: omega ( 3 ) !! The angular velocity vector. real ( real64 ), intent ( in ) :: v ( 3 ) !! The translation velocity vector describing the velocity of the !! body in its parent coordinate frame. real ( real64 ), intent ( in ) :: x ( 3 ) !! The position vector of the body in its parent coordinate frame. real ( real64 ) :: rst ( 4 , 4 ) !! The 4-by-4 transformation matrix. ! Process rst ( 1 : 3 , 1 : 3 ) = to_skew_symmetric ( omega ) rst ( 1 : 3 , 4 ) = v - matmul ( rst ( 1 : 3 , 1 : 3 ), x ) rst ( 4 ,:) = 0.0d0 end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_rotation.f90.html"},{"title":"dynamics_stability.f90 – DYNAMICS","text":"Contents Modules dynamics_stability Source Code dynamics_stability.f90 Source Code module dynamics_stability use iso_fortran_env use ferror use dynamics_error_handling use linalg , only : eigen implicit none private public :: HYPERBOLIC_FIXED_POINT_SINK public :: HYPERBOLIC_FIXED_POINT_SOURCE public :: HYPERBOLIC_FIXED_POINT_SADDLE public :: NONHYPERBOLIC_FIXED_POINT_UNSTABLE public :: NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE public :: NONHYPERBOLIC_FIXED_POINT_CENTER public :: determine_local_stability integer ( int32 ), parameter :: HYPERBOLIC_FIXED_POINT_SINK = 100 !! Describes a hyperbolic fixed point where all of the eigenvalues of !! the dynamics matrix have a nonzero real part and all real parts are !! negative-valued.  This point is considered stable. integer ( int32 ), parameter :: HYPERBOLIC_FIXED_POINT_SOURCE = 101 !! Describes a hyperbolic fixed point where all of the eigenvalues of !! the dynamics matrix have a nonzero real part and the real !! part is positive-valued for each.  This point is considered unstable. integer ( int32 ), parameter :: HYPERBOLIC_FIXED_POINT_SADDLE = 102 !! Describes a hyperbolic fixed point where all of the eigenvalues of !! the dynamics matrix have a nonzero real part but one or more of the !! eigenvalues has a positive-valued real part. integer ( int32 ), parameter :: NONHYPERBOLIC_FIXED_POINT_UNSTABLE = 103 !! Describes a nonhyperbolic fixed point where one or more of the !! eigenvalues of the dynamics matrix have a positive-valued real part. integer ( int32 ), parameter :: NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE = 104 !! Describes a nonhyperbolic fixed point where some of the eigenvalues !! of the dynamics matrix have negative real parts and the remaining !! eigenvalues all have zero-valued real parts. integer ( int32 ), parameter :: NONHYPERBOLIC_FIXED_POINT_CENTER = 105 !! Describes a nonhyperbolic fixed point where all of the eigenvalues !! of the dynamics matrix are purely imaginary and nonzero.  This point !! is considered stable. contains ! ------------------------------------------------------------------------------ function determine_local_stability ( a , ev , err ) result ( rst ) !! Determines the nature of stability/unstability near the point at which !! the dynamics matrix was computed. real ( real64 ), intent ( in ), dimension (:,:) :: a !! An N-by-N matrix containing the 'A' matrix, also known as the !! dynamics matrix. complex ( real64 ), intent ( out ), optional , dimension (:) :: ev !! An optional N-element array that, if supplied, will be filled with !! the eigenvalues of the matrix A. class ( errors ), intent ( inout ), optional , target :: err !! An error handler object. integer ( int32 ) :: rst !! Describe the output constants ! Local Variables logical :: hyperbolic integer ( int32 ) :: i , n , flag , npositive , nnegative real ( real64 ) :: tol , rv real ( real64 ), allocatable , dimension (:,:) :: acpy complex ( real64 ), allocatable , dimension (:) :: vals class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( a , 1 ) tol = 1.0d1 * epsilon ( tol ) ! zero checking tolerance ! Input Checking if ( size ( a , 2 ) /= n ) then call report_nonsquare_matrix_error ( \"determine_local_stability\" , \"a\" , & size ( a , 1 ), size ( a , 2 ), errmgr ) return end if ! Local Memory Allocation allocate ( acpy ( n , n ), source = a , stat = flag ) if ( flag /= 0 ) go to 10 allocate ( vals ( n ), stat = flag ) if ( flag /= 0 ) go to 10 ! Perform the eigen analysis on A call eigen ( acpy , vals , err = errmgr ) if ( errmgr % has_error_occurred ()) return ! Cycle over each eigenvalue hyperbolic = . true . npositive = 0 nnegative = 0 do i = 1 , n rv = real ( vals ( i ), real64 ) if ( abs ( rv ) < tol ) then ! zero-valued real part - must be nonhyperbolic hyperbolic = . false . else if ( rv > 0.0d0 ) then ! positive-valued real part npositive = npositive + 1 else ! negative-valued real part nnegative = nnegative + 1 end if end do ! Characterize the results if ( hyperbolic ) then if ( nnegative == n ) then rst = HYPERBOLIC_FIXED_POINT_SINK else if ( npositive == n ) then rst = HYPERBOLIC_FIXED_POINT_SOURCE else rst = HYPERBOLIC_FIXED_POINT_SADDLE end if else if ( nnegative == 0 . and . npositive == 0 ) then rst = NONHYPERBOLIC_FIXED_POINT_CENTER else if ( nnegative > 0 . and . npositive == 0 ) then rst = NONHYPERBOLIC_FIXED_POINT_NEUTRALLY_STABLE else rst = NONHYPERBOLIC_FIXED_POINT_UNSTABLE end if end if ! Optional Outputs if ( present ( ev )) then if ( size ( ev ) /= n ) then call report_array_size_error ( \"determine_local_stability\" , \"ev\" , & n , size ( ev ), errmgr ) return end if ev = vals end if ! End return ! Memory Error Handling 10 continue call report_memory_error ( \"determine_local_stability\" , flag , errmgr ) return end function ! ------------------------------------------------------------------------------ ! ------------------------------------------------------------------------------ ! ------------------------------------------------------------------------------ ! ------------------------------------------------------------------------------ ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_stability.f90.html"},{"title":"dynamics_structural.f90 – DYNAMICS","text":"Contents Modules dynamics_structural Source Code dynamics_structural.f90 Source Code ! Shape Functions: ! 2D Line: https://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_thry/thy_shp1.html#shp2dlinerdof ! 3D Line: https://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_thry/thy_shp2.html#shp3d2node module dynamics_structural use iso_fortran_env use linalg , only : csr_matrix , create_csr_matrix , sort use ferror use dynamics_error_handling use dynamics_rotation implicit none private public :: DYN_ONE_POINT_INTEGRATION_RULE public :: DYN_TWO_POINT_INTEGRATION_RULE public :: DYN_THREE_POINT_INTEGRATION_RULE public :: DYN_FOUR_POINT_INTEGRATION_RULE public :: node public :: material public :: element public :: line_element public :: beam_element_2d public :: shape_function_derivative public :: shape_function_second_derivative public :: create_connectivity_matrix public :: apply_boundary_conditions public :: apply_displacement_constraint public :: restore_constrained_values public :: point public :: beam_element_3d ! ****************************************************************************** ! CONSTANTS ! ------------------------------------------------------------------------------ integer ( int32 ), parameter :: DYN_ONE_POINT_INTEGRATION_RULE = 1 !! Defines a single-point integration rule. integer ( int32 ), parameter :: DYN_TWO_POINT_INTEGRATION_RULE = 2 !! Defines a two-point integration rule. integer ( int32 ), parameter :: DYN_THREE_POINT_INTEGRATION_RULE = 3 !! Defines a three-point integration rule. integer ( int32 ), parameter :: DYN_FOUR_POINT_INTEGRATION_RULE = 4 !! Defines a four-point integration rule. ! ****************************************************************************** ! TYPES ! ------------------------------------------------------------------------------ type :: point !! Defines a point in 3D, Cartesian space. real ( real64 ) :: x !! The x-coordinate. real ( real64 ) :: y !! The y-coordinate. real ( real64 ) :: z !! The z-coordinate. end type ! ------------------------------------------------------------------------------ type , extends ( point ) :: node !! Defines a node. integer ( int32 ) :: index !! The global index of the node. integer ( int32 ) :: dof !! The number of degrees of freeedom associated with this node. end type ! ------------------------------------------------------------------------------ type :: material !! Defines a linear-elastic-isotropic material. real ( real64 ) :: density !! The density of the material. real ( real64 ) :: modulus !! The modulus of elasticity of the material. real ( real64 ) :: poissons_ratio !! The Poisson's ratio of the material. end type ! ------------------------------------------------------------------------------ type , abstract :: element !! Defines an element. type ( material ) :: material !! The material. contains procedure ( element_query ), deferred , public , pass :: get_dimensionality procedure ( element_query ), deferred , public , pass :: get_node_count procedure ( element_get_node ), deferred , public , pass :: get_node procedure ( element_query ), deferred , public , pass :: get_dof_per_node procedure ( element_shape_function ), deferred , public , pass :: & evaluate_shape_function procedure ( element_matrix_function ), deferred , public , pass :: & shape_function_matrix procedure ( element_matrix_function ), deferred , public , pass :: & strain_displacement_matrix procedure ( element_const_matrix_function ), deferred , public , & pass :: constitutive_matrix procedure ( element_matrix_function ), deferred , public , pass :: & jacobian procedure , public :: stiffness_matrix => e_stiffness_matrix procedure , public :: mass_matrix => e_mass_matrix procedure , public :: external_force_vector => e_ext_force_vector end type ! ------------------------------------------------------------------------------ type , extends ( element ), abstract :: line_element !! Defines a line element type. real ( real64 ) :: area !! The element cross-sectional area. contains procedure ( line_element_get_terminal ), deferred , public , pass :: & get_terminal_nodes procedure ( line_element_const_matrix_function ), deferred , public , & pass :: rotation_matrix procedure , public :: length => le_length procedure , public :: stiffness_matrix => le_stiffness_matrix procedure , public :: mass_matrix => le_mass_matrix procedure , public :: external_force_vector => le_ext_force_vector end type ! ------------------------------------------------------------------------------ type , extends ( line_element ) :: beam_element_2d !! Defines a two-dimensional Bernoulli-Euler beam element. real ( real64 ) :: moment_of_inertia !! The beam moment of inertia (second moment of area). type ( node ) :: node_1 !! The first node of the element (s = -1). type ( node ) :: node_2 !! The second node of the element (s = 1). contains procedure , public :: get_dimensionality => b2d_dimensionality procedure , public :: get_node_count => b2d_get_node_count procedure , public :: get_dof_per_node => b2d_dof_per_node procedure , public :: get_node => b2d_get_node procedure , public :: get_terminal_nodes => b2d_terminal_nodes procedure , public :: evaluate_shape_function => b2d_shape_function procedure , public :: shape_function_matrix => b2d_shape_function_matrix_2d procedure , public :: strain_displacement_matrix => b2d_strain_disp_matrix_2d procedure , public :: constitutive_matrix => b2d_constitutive_matrix procedure , public :: jacobian => b2d_jacobian procedure , public :: rotation_matrix => b2d_rotation_matrix procedure , public :: stiffness_matrix => b2d_stiffness_matrix procedure , public :: mass_matrix => b2d_mass_matrix end type ! ------------------------------------------------------------------------------ type , extends ( line_element ) :: beam_element_3d !! Defines a three-dimensional Bernoulli-Euler beam element. real ( real64 ) :: Ixx !! The beam moment of inertia about the element x-axis. real ( real64 ) :: Iyy !! The beam moment of inertia about the element y-axis. real ( real64 ) :: Izz !! The beam moment of inertia about the element z-axis. type ( node ) :: node_1 !! The first node of the element (s = -1). type ( node ) :: node_2 !! The second node of the element (s = 1). type ( point ) :: orientation_point !! A point used to determine the orientation of the beam in 3D !! space.  The orientation point is measured relative to the first !! node in the element.  Specifically, the element z axis is assumed !! to be defined by the location of this point relative to the !! location of node 1. contains procedure , public :: get_dimensionality => b3d_dimensionality procedure , public :: get_node_count => b3d_get_node_count procedure , public :: get_dof_per_node => b3d_dof_per_node procedure , public :: get_node => b3d_get_node procedure , public :: get_terminal_nodes => b3d_terminal_nodes procedure , public :: evaluate_shape_function => b3d_shape_function procedure , public :: shape_function_matrix => b3d_shape_function_matrix_3d procedure , public :: strain_displacement_matrix => b3d_strain_disp_matrix_3d procedure , public :: constitutive_matrix => b3d_constitutive_matrix procedure , public :: jacobian => b3d_jacobian procedure , public :: rotation_matrix => b3d_rotation_matrix procedure , public :: stiffness_matrix => b3d_stiffness_matrix procedure , public :: mass_matrix => b3d_mass_matrix end type ! ****************************************************************************** ! INTERFACES ! ------------------------------------------------------------------------------ interface pure function element_query ( this ) result ( rst ) !! Defines the signature of a function performing a query on an !! integer-valued property of a element type. use iso_fortran_env , only : int32 import element class ( element ), intent ( in ) :: this !! The element object. integer ( int32 ) :: rst !! The resulting value. end function pure function element_get_node ( this , i ) result ( rst ) !! Defines the signature of a function for retrieving the requested !! node from the element. use iso_fortran_env , only : int32 import node import element class ( element ), intent ( in ) :: this !! The element object. integer ( int32 ), intent ( in ) :: i !! The local index of the node to retrieve. type ( node ) :: rst !! The node. end function pure function element_matrix_function ( this , s ) result ( rst ) !! Defines the signature of a routine for returning a matrix !! associated with the element. use iso_fortran_env , only : real64 import element class ( element ), intent ( in ) :: this !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinates at which the matrix !! should be evaluated. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. end function pure function element_const_matrix_function ( this ) result ( rst ) !! Defines the signature of a routine for returning a matrix !! associated with the element. use iso_fortran_env , only : real64 import element class ( element ), intent ( in ) :: this !! The element object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. end function pure function element_shape_function ( this , i , s ) result ( rst ) !! Defines the signature of a routine for computing the value of !! the i-th element shape function at natural coordinate. use iso_fortran_env , only : int32 , real64 import element class ( element ), intent ( in ) :: this !! The element object. integer ( int32 ), intent ( in ) :: i !! The index of the shape function to evaluate. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinates at which to evaluate !! the shape function. real ( real64 ) :: rst !! The value of the i-th shape function at s. end function pure subroutine line_element_get_terminal ( this , i1 , i2 ) !! Defines the signature of a routine for returning the terminal !! node numbers. use iso_fortran_env , only : int32 import line_element class ( line_element ), intent ( in ) :: this !! The line_element object. integer ( int32 ), intent ( out ) :: i1 !! The index of the node at the head of the element. integer ( int32 ), intent ( out ) :: i2 !! The index of the node at the tail of the element. end subroutine pure function line_element_const_matrix_function ( this ) result ( rst ) !! Defines the signature of a routine for returning a matrix !! associated with the line_element. use iso_fortran_env , only : real64 import line_element class ( line_element ), intent ( in ) :: this !! The line_element object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. end function pure function integrand ( elem , s ) result ( rst ) !! Defines the signature of a function containing an integrand. use iso_fortran_env , only : real64 import element class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate at which to evaluate the integrand. real ( real64 ), allocatable , dimension (:,:) :: rst !! The result. end function end interface ! ****************************************************************************** ! OVERLOADED ROUTINES ! ------------------------------------------------------------------------------ interface apply_boundary_conditions module procedure :: apply_boundary_conditions_mtx module procedure :: apply_boundary_conditions_vec end interface contains ! ****************************************************************************** ! DIFFERENTIATION ROUTINES ! ------------------------------------------------------------------------------ pure function shape_function_derivative ( index , elem , s , i ) result ( rst ) !! Computes the derivative of the shape function with respect to the natural !! coordinate specified. integer ( int32 ), intent ( in ) :: index !! The index of the shape function to evaluate. class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate at which to evaluate the derivative. integer ( int32 ), intent ( in ) :: i !! The index of the natural coordinate to with which the derivative is !! to be computed. real ( real64 ) :: rst !! The result. ! Local Variables real ( real64 ) :: na , nb , h ( size ( s )) ! Initialization h = 0.0d0 h ( i ) = sqrt ( epsilon ( na )) ! Process na = elem % evaluate_shape_function ( index , s + h ) nb = elem % evaluate_shape_function ( index , s - h ) rst = ( na - nb ) / ( 2.0d0 * h ( i )) end function ! ------------------------------------------------------------------------------ pure function shape_function_second_derivative ( index , elem , s , i ) result ( rst ) !! Computes the second derivative of the shape function with respect to the !! natural coordinate specified. integer ( int32 ), intent ( in ) :: index !! The index of the shape function to evaluate. class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate at which to evaluate the derivative. integer ( int32 ), intent ( in ) :: i !! The index of the natural coordinate to with which the derivative is !! to be computed. real ( real64 ) :: rst !! The result. ! Local Variables real ( real64 ) :: na , nb , nc , h ( size ( s )) ! Initialization h = 0.0d0 h ( i ) = ( epsilon ( na )) ** 0.25d0 na = elem % evaluate_shape_function ( index , s + h ) nb = elem % evaluate_shape_function ( index , s ) nc = elem % evaluate_shape_function ( index , s - h ) rst = ( na - 2.0d0 * nb + nc ) / ( h ( i ) ** 2 ) end function ! ****************************************************************************** ! INTEGRATION ! ------------------------------------------------------------------------------ pure function get_model_parameters ( rule ) result ( rst ) !! Gets the requested integration model parameters. integer ( int32 ), intent ( in ) :: rule !! The integration rule. real ( real64 ), allocatable , dimension (:,:) :: rst !! The integration parameters. ! Local Variables real ( real64 ) :: x , w1 , w2 , pt1 , pt2 ! Process select case ( rule ) case ( DYN_ONE_POINT_INTEGRATION_RULE ) allocate ( rst ( 2 , 2 )) rst = reshape ([ 0.0d0 , 0.0d0 , 2.0d0 , 2.0d0 ], [ 2 , 2 ]) case ( DYN_TWO_POINT_INTEGRATION_RULE ) allocate ( rst ( 2 , 2 )) x = sqrt ( 3.0d0 ) / 3.0d0 rst = reshape ([ - x , x , 1.0d0 , 1.0d0 ], [ 2 , 2 ]) case ( DYN_THREE_POINT_INTEGRATION_RULE ) allocate ( rst ( 3 , 2 )) x = sqrt ( 3.0d0 / 5.0d0 ) rst = reshape ([ 0.0d0 , - x , x , w1 , w2 , w2 ], [ 3 , 2 ]) case default ! Four Point Rule allocate ( rst ( 4 , 2 )) pt1 = sqrt (( 3.0d0 / 7.0d0 ) - ( 2.0d0 / 7.0d0 ) * sqrt ( 6.0d0 / 5.0d0 )) pt1 = sqrt (( 3.0d0 / 7.0d0 ) + ( 2.0d0 / 7.0d0 ) * sqrt ( 6.0d0 / 5.0d0 )) w1 = ( 1.8d1 + sqrt ( 3.0d1 )) / 3.6d1 w2 = ( 1.8d1 - sqrt ( 3.0d1 )) / 3.6d1 rst = reshape ([ - pt1 , pt1 , - pt2 , pt2 , w1 , w1 , w2 , w2 ], [ 4 , 2 ]) end select end function ! ------------------------------------------------------------------------------ pure function integrate_1d ( fcn , elem , rule ) result ( rst ) !! Computes the integral of the specified integrand given an element and an !! integration rule. procedure ( integrand ) :: fcn !! The integrand. class ( element ), intent ( in ) :: elem !! The element object. integer ( int32 ), intent ( in ) :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE real ( real64 ), allocatable , dimension (:,:) :: rst !! The result of the integration. ! Local Variables integer ( int32 ) :: i real ( real64 ), allocatable , dimension (:,:) :: s ! Process s = get_model_parameters ( rule ) rst = s ( 1 , 2 ) * fcn ( elem , [ s ( 1 , 1 )]) do i = 2 , size ( s , 1 ) rst = rst + s ( i , 2 ) * fcn ( elem , [ s ( i , 1 )]) end do end function ! ------------------------------------------------------------------------------ pure function integrate ( fcn , elem , rule ) result ( rst ) !! Computes the integral of the specified integrand given an element and an !! integration rule. procedure ( integrand ) :: fcn !! The integrand. class ( element ), intent ( in ) :: elem !! The element object. integer ( int32 ), intent ( in ) :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE real ( real64 ), allocatable , dimension (:,:) :: rst !! The result of the integration. ! Process select type ( elem ) class is ( line_element ) rst = integrate_1d ( fcn , elem , rule ) end select end function ! ****************************************************************************** ! ASSEMBLY ROUTINES ! ------------------------------------------------------------------------------ pure function find_global_dof ( n , nodes ) result ( rst ) !! Finds the index of the global DOF node in a list of nodes. class ( node ), intent ( in ) :: n !! The node for which to search. class ( node ), intent ( in ), dimension (:) :: nodes !! The list of nodes integer ( int32 ) :: rst !! The requested index. ! Local Variables integer ( int32 ) :: i ! Process rst = 0 do i = 1 , size ( nodes ) if ( n % index == nodes ( i )% index ) then rst = rst + 1 exit end if rst = rst + nodes ( i )% dof end do end function ! ------------------------------------------------------------------------------ function create_connectivity_matrix ( gdof , e , nodes , err ) result ( rst ) !! Creates a connectivity matrix for the element. integer ( int32 ), intent ( in ) :: gdof !! The number of global degrees of freedom. class ( element ), intent ( in ) :: e !! The element. class ( node ), intent ( in ), dimension (:) :: nodes !! The global node list. class ( errors ), intent ( inout ), optional , target :: err !! An optional error handling object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables integer ( int32 ) :: i , j , col , nnodes , nnz , row , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if nnodes = e % get_node_count () nnz = e % get_dof_per_node () * nnodes allocate ( rst ( nnz , gdof ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"create_connectivity_matrix\" , flag , errmgr ) return end if ! Process row = 0 do j = 1 , nnodes col = find_global_dof ( e % get_node ( j ), nodes ) do i = 1 , e % get_dof_per_node () row = row + 1 rst ( row , col ) = 1.0d0 col = col + 1 end do end do end function ! ------------------------------------------------------------------------------ function apply_boundary_conditions_mtx ( gdof , x , err ) result ( rst ) !! Applies boundary conditions to a matrix by removal of the appropriate !! rows and columns. integer ( int32 ), intent ( inout ), dimension (:) :: gdof !! An array of the global degrees of freedom to restrain.  The array !! is sorted into ascending order on output. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix to constrain. class ( errors ), intent ( inout ), optional , target :: err !! An optional error handling object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The altered matrix. ! Local Variables integer ( int32 ) :: i , j , ii , m , n , nbc , mnew , flag integer ( int32 ), allocatable , dimension (:) :: indices class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if m = size ( x , 1 ) n = size ( x , 2 ) nbc = size ( gdof ) mnew = m - nbc ! Input Checking if ( m /= n ) then call report_nonsquare_matrix_error ( \"apply_boundary_conditions_mtx\" , & \"x\" , m , n , errmgr ) return end if if ( mnew < 1 ) then call report_overconstraint_error ( \"apply_boundary_conditions_mtx\" , & errmgr ) return end if do i = 1 , nbc if ( gdof ( i ) < 1 . or . gdof ( i ) > m ) then call report_array_index_out_of_bounds_error ( & \"apply_boundary_conditions_mtx\" , \"gdof\" , gdof ( i ), m , errmgr ) return end if end do ! Memory Allocation allocate ( rst ( mnew , mnew ), stat = flag ) if ( flag == 0 ) allocate ( indices ( m - nbc ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"apply_boundary_conditions_mtx\" , flag , errmgr ) return end if ! Sort gdof into ascending order call sort ( gdof , . true .) ! Check for duplicate values in GDOF do i = 2 , nbc if ( gdof ( i ) == gdof ( i - 1 )) then call report_nonmonotonic_array_error (& \"apply_boundary_conditions_mtx\" , \"gdof\" , i , errmgr ) return end if end do ! Process ii = 1 j = 0 do i = 1 , m if ( gdof ( ii ) /= i ) then j = j + 1 indices ( j ) = i else ii = ii + 1 if ( ii > nbc ) ii = nbc end if end do ! Now, we only need store the rows and columns stored in indices rst = x ( indices , indices ) end function ! ------------------------------------------------------------------------------ function apply_boundary_conditions_vec ( gdof , x , err ) result ( rst ) !! Applies boundary conditions to a vector by removal of the appropriate !! items. integer ( int32 ), intent ( inout ), dimension (:) :: gdof !! An array of the global degrees of freedom to restrain.  The array !! is sorted into ascending order on output. real ( real64 ), intent ( in ), dimension (:) :: x !! The vector to constrain. class ( errors ), intent ( inout ), optional , target :: err !! An optional error handling object. real ( real64 ), allocatable , dimension (:) :: rst !! The altered vector. ! Local Variables integer ( int32 ) :: i , j , ii , n , nbc , nnew , flag integer ( int32 ), allocatable , dimension (:) :: indices class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) nbc = size ( gdof ) nnew = n - nbc ! Input Checking if ( nnew < 1 ) then call report_overconstraint_error ( \"apply_boundary_conditions_vec\" , & errmgr ) return end if do i = 1 , nbc if ( gdof ( i ) < 1 . or . gdof ( i ) > n ) then call report_array_index_out_of_bounds_error ( & \"apply_boundary_conditions_vec\" , \"gdof\" , gdof ( i ), n , errmgr ) return end if end do ! Memory Allocation allocate ( rst ( nnew ), stat = flag ) if ( flag == 0 ) allocate ( indices ( n - nbc ), stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"apply_boundary_conditions_vec\" , flag , errmgr ) return end if ! Sort gdof into ascending order call sort ( gdof , . true .) ! Check for duplicate values in GDOF do i = 2 , nbc if ( gdof ( i ) == gdof ( i - 1 )) then call report_nonmonotonic_array_error ( & \"apply_boundary_conditions_vec\" , \"gdof\" , i , errmgr ) return end if end do ! Process ii = 1 j = 0 do i = 1 , n if ( gdof ( ii ) /= i ) then j = j + 1 indices ( j ) = i else ii = ii + 1 if ( ii > nbc ) ii = nbc end if end do ! Now, just store the appropriate items in the output vector rst = x ( indices ) end function ! ------------------------------------------------------------------------------ function restore_constrained_values ( gdof , x , err ) result ( rst ) !! Restores the constrained degrees-of-freedom from the boundary conditions !! applied by apply_boundary_conditions. integer ( int32 ), intent ( inout ), dimension (:) :: gdof !! An array of the global degrees of freedom to restrain.  The array !! is sorted into ascending order on output. real ( real64 ), intent ( in ), dimension (:) :: x !! The constrained vector. class ( errors ), intent ( inout ), optional , target :: err !! An optional error handling object. real ( real64 ), allocatable , dimension (:) :: rst !! The altered vector. ! Local Variables integer ( int32 ) :: i , j , ii , n , nbc , nnew , flag class ( errors ), pointer :: errmgr type ( errors ), target :: deferr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if n = size ( x ) nbc = size ( gdof ) nnew = n + nbc ! Input Checking do i = 1 , nbc if ( gdof ( i ) < 1 . or . gdof ( i ) > nnew ) then call report_array_index_out_of_bounds_error ( & \"restore_constrained_values\" , \"gdof\" , gdof ( i ), nnew , errmgr ) return end if end do ! Memory Allocation allocate ( rst ( nnew ), source = 0.0d0 , stat = flag ) if ( flag /= 0 ) then call report_memory_error ( \"restore_constrained_values\" , flag , errmgr ) return end if ! Sort gdof into ascending order call sort ( gdof , . true .) ! Check for duplicate values in GDOF do i = 2 , nbc if ( gdof ( i ) == gdof ( i - 1 )) then call report_nonmonotonic_array_error ( & \"restore_constrained_values\" , \"gdof\" , i , errmgr ) return end if end do ! Process ii = 1 j = 0 do i = 1 , nnew if ( i == gdof ( ii )) then ii = ii + 1 if ( ii > nbc ) ii = nbc else j = j + 1 rst ( i ) = x ( j ) end if end do end function ! ------------------------------------------------------------------------------ ! REF: https://www.sciencedirect.com/topics/engineering/prescribed-displacement-boundary-condition subroutine apply_displacement_constraint ( dof , val , k , f ) !! Applies a displacement constraint to the specified degree of freedom. integer ( int32 ), intent ( in ) :: dof !! The global degree-of-freedom to which the constraint should be !! applied. real ( real64 ), intent ( in ) :: val !! The value of the displacement constraint. real ( real64 ), intent ( inout ), dimension (:,:) :: k !! The stiffness matrix to which the constraint should be applied. real ( real64 ), intent ( inout ), dimension (:) :: f !! The external force vector to which the constraint should be applied. ! Wipe out the rows in the matrix and place a value of 1 on the diagonal k ( dof ,:) = 0.0d0 k ( dof , dof ) = 1.0d0 ! Update the external force vector f ( dof ) = val end subroutine ! ****************************************************************************** ! ELEMENT MEMBERS ! ------------------------------------------------------------------------------ pure function e_stiffness_matrix ( this , rule ) result ( rst ) !! Computes the stiffness matrix for the element. class ( element ), intent ( in ) :: this !! The element object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables integer ( int32 ) :: r ! Initialization if ( present ( rule )) then r = rule else r = DYN_TWO_POINT_INTEGRATION_RULE end if ! Process rst = integrate ( element_stiffness_integrand , this , r ) end function ! ---------- pure function element_stiffness_integrand ( elem , s ) result ( rst ) !! The integrand function for computing the stiffness matrix of an element. class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate vector at which to evaluate the integrand. real ( real64 ), allocatable , dimension (:,:) :: rst !! The integrand. ! Local Variables real ( real64 ) :: jdet real ( real64 ), allocatable , dimension (:,:) :: b , bt , d , x , jac ! Process b = elem % strain_displacement_matrix ( s ) bt = transpose ( b ) d = elem % constitutive_matrix () jac = elem % jacobian ( s ) jdet = det ( jac ) x = matmul ( d , b ) rst = jdet * matmul ( bt , x ) end function ! ------------------------------------------------------------------------------ pure function e_mass_matrix ( this , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( element ), intent ( in ) :: this !! The element object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables integer ( int32 ) :: r ! Initialization if ( present ( rule )) then r = rule else r = DYN_TWO_POINT_INTEGRATION_RULE end if ! Process rst = integrate ( element_mass_integrand , this , r ) end function ! ---------- pure function element_mass_integrand ( elem , s ) result ( rst ) !! The integrand function for computing the mass matrix of an element. class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate vector at which to evaluate the integrand. real ( real64 ), allocatable , dimension (:,:) :: rst !! The integrand. ! Local Variables real ( real64 ) :: jdet real ( real64 ), allocatable , dimension (:,:) :: N , Nt , jac ! Process N = elem % shape_function_matrix ( s ) Nt = transpose ( N ) jac = elem % jacobian ( s ) jdet = det ( jac ) rst = elem % material % density * jdet * matmul ( Nt , N ) end function ! ------------------------------------------------------------------------------ pure function e_ext_force_vector ( this , q , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( element ), intent ( in ) :: this !! The element object. real ( real64 ), intent ( in ), dimension (:) :: q !! The surface traction forces vector or body force vector. !! For instance, a 2D problem this vector would look like [qx, qy]**T. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting vector. ! Local Variables integer ( int32 ) :: r ! Initialization if ( present ( rule )) then r = rule else r = DYN_TWO_POINT_INTEGRATION_RULE end if ! Process rst = matmul ( & integrate ( element_ext_force_integrand , this , r ), & q & ) end function ! ---------- pure function element_ext_force_integrand ( elem , s ) result ( rst ) !! The integrand function for computing the external force vector of an !! element. class ( element ), intent ( in ) :: elem !! The element object. real ( real64 ), intent ( in ), dimension (:) :: s !! The natural coordinate vector at which to evaluate the integrand. real ( real64 ), allocatable , dimension (:,:) :: rst !! The integrand. ! Local Variables real ( real64 ) :: jdet real ( real64 ), allocatable , dimension (:,:) :: Nt , jac ! Process Nt = transpose ( elem % shape_function_matrix ( s )) jac = elem % jacobian ( s ) jdet = det ( jac ) rst = jdet * Nt end function ! ****************************************************************************** ! LINE_ELEMENT MEMBERS ! ------------------------------------------------------------------------------ pure function le_length ( this ) result ( rst ) !! Computes the length of the line_element. class ( line_element ), intent ( in ) :: this !! The line_element object. real ( real64 ) :: rst !! The length of the line element. ! Local Variables real ( real64 ) :: dx , dy , dz integer ( int32 ) :: i1 , i2 type ( node ) :: n1 , n2 ! Process call this % get_terminal_nodes ( i1 , i2 ) n1 = this % get_node ( i1 ) n2 = this % get_node ( i2 ) dx = n2 % x - n1 % x dy = n2 % y - n1 % y dz = n2 % z - n1 % z rst = sqrt ( dx ** 2 + dy ** 2 + dz ** 2 ) end function ! ------------------------------------------------------------------------------ pure function le_stiffness_matrix ( this , rule ) result ( rst ) !! Computes the stiffness matrix for the element. class ( line_element ), intent ( in ) :: this !! The line_element object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Compute the stiffness matrix and apply the rotation transformation rst = e_stiffness_matrix ( this , rule ) rst = matmul ( Tt , matmul ( rst , T )) end function ! ------------------------------------------------------------------------------ pure function le_mass_matrix ( this , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( line_element ), intent ( in ) :: this !! The line_element object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Compute the mass matrix and apply the rotation transformation rst = e_mass_matrix ( this , rule ) rst = this % area * matmul ( Tt , matmul ( rst , T )) end function ! ------------------------------------------------------------------------------ pure function le_ext_force_vector ( this , q , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( line_element ), intent ( in ) :: this !! The line_element object. real ( real64 ), intent ( in ), dimension (:) :: q !! The surface traction forces vector or body force vector. !! For instance, a 2D problem this vector would look like [qx, qy]**T. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - DYN_ONE_POINT_INTEGRATION_RULE !! !! - DYN_TWO_POINT_INTEGRATION_RULE !! !! - DYN_THREE_POINT_INTEGRATION_RULE !! !! - DYN_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is DYN_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:) :: rst !! The resulting vector. ! Local Variables real ( real64 ), allocatable , dimension (:,:) :: T ! Compute the rotation matrix T = this % rotation_matrix () ! Compute the force vector rst = e_ext_force_vector ( this , q , rule ) rst = matmul ( T , rst ) end function ! ****************************************************************************** ! BEAM_2D ROUTINES ! ------------------------------------------------------------------------------ pure function b2d_dimensionality ( this ) result ( rst ) !! Gets the dimensionality of the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ) :: rst !! The dimensionality. rst = 2 end function ! ------------------------------------------------------------------------------ pure function b2d_get_node_count ( this ) result ( rst ) !! Gets the number of nodes for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ) :: rst !! The number of nodes. rst = 2 end function ! ------------------------------------------------------------------------------ pure function b2d_dof_per_node ( this ) result ( rst ) !! Gets the number of degrees of freedom per node. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ) :: rst !! The number of DOF per node. rst = 3 end function ! ------------------------------------------------------------------------------ pure function b2d_get_node ( this , i ) result ( rst ) !! Gets the requested node from the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ), intent ( in ) :: i !! The local index of the node to retrieve. type ( node ) :: rst !! The requested node. if ( i == 1 ) then rst = this % node_1 else rst = this % node_2 end if end function ! ------------------------------------------------------------------------------ pure subroutine b2d_terminal_nodes ( this , i1 , i2 ) !! Gets the terminal node numbers for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ), intent ( out ) :: i1 !! The index of the node at the head of the element. integer ( int32 ), intent ( out ) :: i2 !! The index of the node at the tail of the element. i1 = 1 i2 = 2 end subroutine ! ------------------------------------------------------------------------------ pure function b2d_shape_function ( this , i , s ) result ( rst ) !! Evaluates the i-th shape function at natural coordinate s. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ), intent ( in ) :: i !! The index of the shape function to evaluate. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate !! the shape function. real ( real64 ) :: rst !! The value of the i-th shape function at s. ! Local Variables real ( real64 ) :: l ! Process select case ( i ) case ( 1 ) rst = 0.5d0 * ( 1.0d0 - s ( 1 )) case ( 2 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 )) ** 2 * ( 2.0d0 + s ( 1 )) case ( 3 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 )) ** 2 * ( 1.0d0 + s ( 1 )) case ( 4 ) rst = 0.5d0 * ( 1.0d0 + s ( 1 )) case ( 5 ) rst = 0.25d0 * ( 1.0d0 + s ( 1 )) ** 2 * ( 2.0d0 - s ( 1 )) case ( 6 ) rst = 0.25d0 * ( 1.0d0 + s ( 1 )) ** 2 * ( s ( 1 ) - 1.0d0 ) case default rst = 0.0d0 end select end function ! ------------------------------------------------------------------------------ pure function b2d_shape_function_matrix_2d ( this , s ) result ( rst ) !! Computes the shape function matrix for a beam element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the shape !! functions. real ( real64 ), allocatable , dimension (:,:) :: rst !! The shape function matrix. ! Local Variables real ( real64 ) :: n1 , n2 , n3 , n4 , n5 , n6 , l ! Initialization allocate ( rst ( 2 , 6 ), source = 0.0d0 ) l = this % length () ! Process n1 = this % evaluate_shape_function ( 1 , s ) n2 = this % evaluate_shape_function ( 2 , s ) n3 = 0.5d0 * l * this % evaluate_shape_function ( 3 , s ) n4 = this % evaluate_shape_function ( 4 , s ) n5 = this % evaluate_shape_function ( 5 , s ) n6 = 0.5d0 * l * this % evaluate_shape_function ( 6 , s ) rst ( 1 , 1 ) = n1 rst ( 2 , 2 ) = n2 rst ( 2 , 3 ) = n3 rst ( 1 , 4 ) = n4 rst ( 2 , 5 ) = n5 rst ( 2 , 6 ) = n6 end function ! ------------------------------------------------------------------------------ pure function b2d_strain_disp_matrix_2d ( this , s ) result ( rst ) !! Computes the strain-displacement matrix for a 2D beam element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The strain-displacement matrix. ! Local Variables real ( real64 ) :: l , dsdx , dn1ds , dn2ds , dn3ds , dn4ds , dn5ds , dn6ds ! Initialization allocate ( rst ( 2 , 6 ), source = 0.0d0 ) ! Process l = this % length () dsdx = 2.0d0 / l ! s = 2 * x / L - 1, so ds/dx = 2 / L dn1ds = shape_function_derivative ( 1 , this , s , 1 ) dn2ds = shape_function_second_derivative ( 2 , this , s , 1 ) dn3ds = shape_function_second_derivative ( 3 , this , s , 1 ) dn4ds = shape_function_derivative ( 4 , this , s , 1 ) dn5ds = shape_function_second_derivative ( 5 , this , s , 1 ) dn6ds = shape_function_second_derivative ( 6 , this , s , 1 ) rst ( 1 , 1 ) = dn1ds * dsdx rst ( 2 , 2 ) = dn2ds * dsdx ** 2 rst ( 2 , 3 ) = 0.5d0 * l * dn3ds * dsdx ** 2 rst ( 1 , 4 ) = dn4ds * dsdx rst ( 2 , 5 ) = dn5ds * dsdx ** 2 rst ( 2 , 6 ) = 0.5d0 * l * dn6ds * dsdx ** 2 end function ! ------------------------------------------------------------------------------ pure function b2d_constitutive_matrix ( this ) result ( rst ) !! Computes the constitutive matrix for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Process allocate ( rst ( 2 , 2 ), source = 0.0d0 ) rst ( 1 , 1 ) = this % area * this % material % modulus rst ( 2 , 2 ) = this % moment_of_inertia * this % material % modulus end function ! ------------------------------------------------------------------------------ pure function b2d_jacobian ( this , s ) result ( rst ) !! Computes the Jacobian matrix for a 2D beam element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The Jacobian matrix. rst = reshape ([ 0.5d0 * this % length ()], [ 1 , 1 ]) end function ! ------------------------------------------------------------------------------ pure function b2d_rotation_matrix ( this ) result ( rst ) !! Computes the rotation matrix for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting 6-by-6 rotation matrix. ! Local Variables real ( real64 ) :: theta , ct , st type ( node ) :: n1 , n2 ! Process allocate ( rst ( 6 , 6 ), source = 0.0d0 ) n1 = this % get_node ( 1 ) n2 = this % get_node ( 2 ) theta = atan2 ( n2 % y - n1 % y , n2 % x - n1 % x ) ct = cos ( theta ) st = sin ( theta ) rst ( 1 , 1 ) = ct rst ( 2 , 1 ) = st rst ( 1 , 2 ) = - st rst ( 2 , 2 ) = ct rst ( 3 , 3 ) = 1.0d0 rst ( 4 , 4 ) = ct rst ( 5 , 4 ) = st rst ( 4 , 5 ) = - st rst ( 5 , 5 ) = ct rst ( 6 , 6 ) = 1.0d0 end function ! ------------------------------------------------------------------------------ pure function b2d_stiffness_matrix ( this , rule ) result ( rst ) !! Computes the stiffness matrix for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ) :: A , E , I , L real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Initialization A = this % area E = this % material % modulus I = this % moment_of_inertia L = this % length () ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Construct the stiffness matrix allocate ( rst ( 6 , 6 ), source = 0.0d0 ) rst ( 1 , 1 ) = A * E / L rst ( 2 , 2 ) = 1 2.0d0 * E * I / ( L ** 3 ) rst ( 3 , 3 ) = 4.0d0 * E * I / L rst ( 2 , 3 ) = 6.0d0 * E * I / ( L ** 2 ) rst ( 3 , 2 ) = rst ( 2 , 3 ) rst ( 1 , 4 ) = - rst ( 1 , 1 ) rst ( 4 , 1 ) = rst ( 1 , 4 ) rst ( 2 , 5 ) = - rst ( 2 , 2 ) rst ( 5 , 2 ) = rst ( 2 , 5 ) rst ( 2 , 6 ) = rst ( 2 , 3 ) rst ( 6 , 2 ) = rst ( 2 , 6 ) rst ( 3 , 5 ) = - rst ( 2 , 3 ) rst ( 5 , 3 ) = rst ( 3 , 5 ) rst ( 3 , 6 ) = 2.0d0 * E * I / L rst ( 6 , 3 ) = rst ( 3 , 6 ) rst ( 4 : 6 , 4 : 6 ) = rst ( 1 : 3 , 1 : 3 ) rst ( 5 , 6 ) = - rst ( 2 , 3 ) rst ( 6 , 5 ) = rst ( 5 , 6 ) ! Apply the transformation rst = matmul ( Tt , matmul ( rst , T )) end function ! ------------------------------------------------------------------------------ pure function b2d_mass_matrix ( this , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( beam_element_2d ), intent ( in ) :: this !! The beam_element_2d object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ) :: rho , A , L , f real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Initialization rho = this % material % density A = this % area L = this % length () f = rho * A * L / 4.2d2 ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Construct the mass matrix allocate ( rst ( 6 , 6 ), source = 0.0d0 ) rst ( 1 , 1 ) = 1.4d2 * f rst ( 4 , 1 ) = 7.0d1 * f rst ( 2 , 2 ) = 1.56d2 * f rst ( 3 , 2 ) = 2.2d1 * L * f rst ( 5 , 2 ) = 5.4d1 * f rst ( 6 , 2 ) = - 1.3d1 * L * f rst ( 2 , 3 ) = rst ( 3 , 2 ) rst ( 3 , 3 ) = 4.0d0 * L ** 2 * f rst ( 5 , 3 ) = 1.3d1 * L * f rst ( 6 , 3 ) = - 3.0d0 * L ** 2 * f rst ( 1 , 4 ) = rst ( 4 , 1 ) rst ( 4 , 4 ) = rst ( 1 , 1 ) rst ( 2 , 5 ) = rst ( 5 , 2 ) rst ( 3 , 5 ) = rst ( 5 , 3 ) rst ( 5 , 5 ) = rst ( 2 , 2 ) rst ( 6 , 5 ) = - 2.2d1 * L * f rst ( 2 , 6 ) = rst ( 6 , 2 ) rst ( 3 , 6 ) = rst ( 6 , 3 ) rst ( 5 , 6 ) = rst ( 6 , 5 ) rst ( 6 , 6 ) = rst ( 3 , 3 ) ! Apply the transformation rst = matmul ( Tt , matmul ( rst , T )) end function ! ****************************************************************************** ! PRIVATE ROUTINES ! ------------------------------------------------------------------------------ pure function det_1 ( x ) result ( rst ) ! Determinant of a 1-by-1 matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x real ( real64 ) :: rst rst = x ( 1 , 1 ) end function ! ------------------------------------------------------------------------------ pure function det_2 ( x ) result ( rst ) ! Determinant of a 2-by-2 matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x real ( real64 ) :: rst rst = x ( 1 , 1 ) * x ( 2 , 2 ) - x ( 1 , 2 ) * x ( 2 , 1 ) end function ! ------------------------------------------------------------------------------ pure function det_3 ( x ) result ( rst ) ! Determinant of a 3-by-3 matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x real ( real64 ) :: rst rst = x ( 1 , 1 ) * ( x ( 2 , 2 ) * x ( 3 , 3 ) - x ( 2 , 3 ) * x ( 3 , 2 )) - & x ( 1 , 2 ) * ( x ( 2 , 1 ) * x ( 3 , 3 ) - x ( 2 , 3 ) * x ( 3 , 1 )) + & x ( 1 , 3 ) * ( x ( 2 , 1 ) * x ( 3 , 2 ) - x ( 2 , 2 ) * x ( 3 , 1 )) end function ! ------------------------------------------------------------------------------ pure function det ( x ) result ( rst ) !! Computes the determinant of a matrix. real ( real64 ), intent ( in ), dimension (:,:) :: x !! The matrix on which to operate. real ( real64 ) :: rst !! The determinant. select case ( size ( x , 1 )) case ( 1 ) rst = det_1 ( x ) case ( 2 ) rst = det_2 ( x ) case ( 3 ) rst = det_3 ( x ) case default rst = 0.0d0 end select end function ! ------------------------------------------------------------------------------ ! REF: https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line pure function normal_vector_to_line ( pt1 , pt2 , pt ) result ( rst ) !! Computes the normal vector to a line defined by pt1 and pt2 assuming !! some point (pt) not on the line. class ( point ), intent ( in ) :: pt1 !! The origin point of the line segment. class ( point ), intent ( in ) :: pt2 !! The termination point of the line segment. class ( point ), intent ( in ) :: pt !! A point, not on the line. real ( real64 ) :: rst ( 3 ) !! The resulting normal vector (unit length). ! Local Variables real ( real64 ) :: a ( 3 ), p ( 3 ), n ( 3 ), amp ( 3 ) ! Initialization a = [ pt1 % x , pt1 % y , pt1 % z ] n = [ pt2 % x , pt2 % y , pt2 % z ] - a p = [ pt % x , pt % y , pt % z ] amp = a - p rst = amp - dot_product ( amp , n ) * n rst = rst / norm2 ( rst ) end function ! ****************************************************************************** ! BEAM_3D ROUTINES ! ------------------------------------------------------------------------------ pure function b3d_dimensionality ( this ) result ( rst ) !! Gets the dimensionality of the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ) :: rst !! The dimensionality. rst = 3 end function ! ------------------------------------------------------------------------------ pure function b3d_get_node_count ( this ) result ( rst ) !! Gets the number of nodes for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ) :: rst !! The number of nodes. rst = 2 end function ! ------------------------------------------------------------------------------ pure function b3d_dof_per_node ( this ) result ( rst ) !! Gets the number of degrees of freedom per node. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ) :: rst !! The number of DOF per node. rst = 6 end function ! ------------------------------------------------------------------------------ pure function b3d_get_node ( this , i ) result ( rst ) !! Gets the requested node from the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ), intent ( in ) :: i !! The local index of the node to retrieve. type ( node ) :: rst !! The requested node. if ( i == 1 ) then rst = this % node_1 else rst = this % node_2 end if end function ! ------------------------------------------------------------------------------ pure subroutine b3d_terminal_nodes ( this , i1 , i2 ) !! Gets the terminal node numbers for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ), intent ( out ) :: i1 !! The index of the node at the head of the element. integer ( int32 ), intent ( out ) :: i2 !! The index of the node at the tail of the element. i1 = 1 i2 = 2 end subroutine ! ------------------------------------------------------------------------------ pure function b3d_shape_function ( this , i , s ) result ( rst ) !! Evaluates the i-th shape function at natural coordinate s. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ), intent ( in ) :: i !! The index of the shape function to evaluate. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate !! the shape function. real ( real64 ) :: rst !! The value of the i-th shape function at s. ! Local Variables real ( real64 ) :: l ! Process select case ( i ) case ( 1 ) rst = 0.5d0 * ( 1.0d0 - s ( 1 )) case ( 2 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 )) ** 2 * ( 2.0d0 + s ( 1 )) case ( 3 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 )) ** 2 * ( 2.0d0 + s ( 1 )) case ( 4 ) rst = 0.5d0 * ( 1.0d0 - s ( 1 )) case ( 5 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 ) ** 2 ) * ( 1.0d0 - s ( 1 )) case ( 6 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 ) ** 2 ) * ( 1.0d0 - s ( 1 )) case ( 7 ) rst = 0.5d0 * ( 1.0d0 + s ( 1 )) case ( 8 ) rst = 0.25d0 * ( 1.0d0 + s ( 1 )) ** 2 * ( 2.0d0 - s ( 1 )) case ( 9 ) rst = 0.25d0 * ( 1.0d0 + s ( 1 )) ** 2 * ( 2.0d0 - s ( 1 )) case ( 10 ) rst = 0.5d0 * ( 1.0d0 + s ( 1 )) case ( 11 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 ) ** 2 ) * ( 1.0d0 + s ( 1 )) case ( 12 ) rst = 0.25d0 * ( 1.0d0 - s ( 1 ) ** 2 ) * ( 1.0d0 + s ( 1 )) case default rst = 0.0d0 end select end function ! ------------------------------------------------------------------------------ pure function b3d_shape_function_matrix_3d ( this , s ) result ( rst ) !! Computes the shape function matrix for a beam element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the shape !! functions. real ( real64 ), allocatable , dimension (:,:) :: rst !! The shape function matrix. ! Local Variables real ( real64 ) :: n1 , n2 , n3 , n4 , n5 , n6 , n7 , n8 , n9 , n10 , n11 , n12 , l ! Initialization allocate ( rst ( 4 , 12 ), source = 0.0d0 ) l = this % length () ! Process n1 = this % evaluate_shape_function ( 1 , s ) n2 = this % evaluate_shape_function ( 2 , s ) n3 = this % evaluate_shape_function ( 3 , s ) n4 = this % evaluate_shape_function ( 4 , s ) n5 = - 0.5d0 * l * this % evaluate_shape_function ( 5 , s ) n6 = 0.5d0 * l * this % evaluate_shape_function ( 6 , s ) n7 = this % evaluate_shape_function ( 7 , s ) n8 = this % evaluate_shape_function ( 8 , s ) n9 = this % evaluate_shape_function ( 9 , s ) n10 = this % evaluate_shape_function ( 10 , s ) n11 = 0.5d0 * l * this % evaluate_shape_function ( 11 , s ) n12 = - 0.5d0 * l * this % evaluate_shape_function ( 12 , s ) rst ( 1 , 1 ) = n1 rst ( 2 , 2 ) = n2 rst ( 3 , 3 ) = n3 rst ( 4 , 4 ) = n4 rst ( 3 , 5 ) = n5 rst ( 2 , 6 ) = n6 rst ( 1 , 7 ) = n7 rst ( 2 , 8 ) = n8 rst ( 3 , 9 ) = n9 rst ( 4 , 10 ) = n10 rst ( 3 , 11 ) = n11 rst ( 2 , 12 ) = n12 end function ! ------------------------------------------------------------------------------ pure function b3d_strain_disp_matrix_3d ( this , s ) result ( rst ) !! Computes the strain-displacement matrix for a 3D beam element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The strain-displacement matrix. ! Local Variables real ( real64 ) :: l , dsdx , dn1ds , dn2ds , dn3ds , dn4ds , dn5ds , dn6ds , & dn7ds , dn8ds , dn9ds , dn10ds , dn11ds , dn12ds ! Initialization allocate ( rst ( 4 , 12 ), source = 0.0d0 ) ! Process l = this % length () dsdx = 2.0d0 / l ! s = 2 * x / L - 1, so ds/dx = 2 / L dn1ds = shape_function_derivative ( 1 , this , s , 1 ) dn2ds = shape_function_second_derivative ( 2 , this , s , 1 ) dn3ds = shape_function_second_derivative ( 3 , this , s , 1 ) dn4ds = shape_function_derivative ( 4 , this , s , 1 ) dn5ds = - 0.5d0 * l * shape_function_second_derivative ( 5 , this , s , 1 ) dn6ds = 0.5d0 * l * shape_function_second_derivative ( 6 , this , s , 1 ) dn7ds = shape_function_derivative ( 7 , this , s , 1 ) dn8ds = shape_function_second_derivative ( 8 , this , s , 1 ) dn9ds = shape_function_second_derivative ( 9 , this , s , 1 ) dn10ds = shape_function_derivative ( 10 , this , s , 1 ) dn11ds = 0.5d0 * l * shape_function_second_derivative ( 11 , this , s , 1 ) dn12ds = - 0.5d0 * l * shape_function_second_derivative ( 12 , this , s , 1 ) ! Build the matrix rst ( 1 , 1 ) = dn1ds * dsdx rst ( 2 , 2 ) = dn2ds * dsdx ** 2 rst ( 3 , 3 ) = dn3ds * dsdx ** 2 rst ( 4 , 4 ) = dn4ds * dsdx rst ( 3 , 5 ) = dn5ds * dsdx ** 2 rst ( 2 , 6 ) = dn6ds * dsdx ** 2 rst ( 1 , 7 ) = dn7ds * dsdx rst ( 2 , 8 ) = dn8ds * dsdx ** 2 rst ( 3 , 9 ) = dn9ds * dsdx ** 2 rst ( 4 , 10 ) = dn10ds * dsdx rst ( 3 , 11 ) = dn11ds * dsdx ** 2 rst ( 2 , 12 ) = dn12ds * dsdx ** 2 end function ! ------------------------------------------------------------------------------ pure function b3d_constitutive_matrix ( this ) result ( rst ) !! Computes the constitutive matrix for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Process allocate ( rst ( 4 , 4 ), source = 0.0d0 ) rst ( 1 , 1 ) = this % area * this % material % modulus rst ( 2 , 2 ) = this % Izz * this % material % modulus rst ( 3 , 3 ) = this % Iyy * this % material % modulus rst ( 4 , 4 ) = this % Ixx * this % material % modulus / & ( 2.0d0 * ( 1.0d0 + this % material % poissons_ratio )) end function ! ------------------------------------------------------------------------------ pure function b3d_jacobian ( this , s ) result ( rst ) !! Computes the Jacobian matrix for a 3D beam element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. real ( real64 ), intent ( in ), dimension (:) :: s !! The value of the natural coordinate at which to evaluate the matrix. real ( real64 ), allocatable , dimension (:,:) :: rst !! The Jacobian matrix. rst = reshape ([ 0.5d0 * this % length ()], [ 1 , 1 ]) end function ! ------------------------------------------------------------------------------ pure function b3d_rotation_matrix ( this ) result ( rst ) !! Computes the rotation matrix for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting 12-by-12 rotation matrix. ! Local Variables real ( real64 ) :: i ( 3 ), j ( 3 ), k ( 3 ) ! Define the unit vectors i = [ & this % node_2 % x - this % node_1 % x , & this % node_2 % y - this % node_1 % y , & this % node_2 % z - this % node_1 % z & ] i = i / norm2 ( i ) k = normal_vector_to_line ( this % node_1 , this % node_2 , this % orientation_point ) j = [ & k ( 2 ) * i ( 3 ) - k ( 3 ) * i ( 2 ), & k ( 3 ) * i ( 1 ) - k ( 1 ) * i ( 3 ), & k ( 1 ) * i ( 2 ) - k ( 2 ) * i ( 1 ) & ] ! Construct the matrix allocate ( rst ( 12 , 12 ), source = 0.0d0 ) rst ( 1 : 3 , 1 : 3 ) = rotate ( i , j , k ) rst ( 4 : 6 , 4 : 6 ) = rst ( 1 : 3 , 1 : 3 ) rst ( 7 : 9 , 7 : 9 ) = rst ( 1 : 3 , 1 : 3 ) rst ( 10 : 12 , 10 : 12 ) = rst ( 1 : 3 , 1 : 3 ) end function ! ------------------------------------------------------------------------------ ! https://www.researchgate.net/publication/352816965_3-D_Beam_Finite_Element_Programming_-A_Practical_Guide_Part_1 ! https://homes.civil.aau.dk/jc/FemteSemester/Beams3D.pdf ! https://www.sesamx.io/blog/beam_finite_element/ ! https://www.brown.edu/Departments/Engineering/Courses/En2340/Projects/Projects_2015/Wenqiang_Fan.pdf ! https://www.mm.bme.hu/~gyebro/files/ans_help_v182/ans_thry/thy_shp2.html#shp3d2node pure function b3d_stiffness_matrix ( this , rule ) result ( rst ) !! Computes the stiffness matrix for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ) :: A , E , Iyy , Izz , Jxx , G , L real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Initialization A = this % area Jxx = this % Ixx Iyy = this % Iyy Izz = this % Izz E = this % material % modulus G = E / ( 2.0d0 * ( 1.0d0 + this % material % poissons_ratio )) L = this % length () ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Construct the stiffness matrix allocate ( rst ( 12 , 12 ), source = 0.0d0 ) rst ( 1 , 1 ) = A * E / L rst ( 7 , 1 ) = - rst ( 1 , 1 ) rst ( 2 , 2 ) = 1.2d1 * E * Izz / L ** 3 rst ( 6 , 2 ) = 6.0d0 * E * Izz / L ** 2 rst ( 8 , 2 ) = - rst ( 2 , 2 ) rst ( 12 , 2 ) = rst ( 6 , 2 ) rst ( 3 , 3 ) = 1.2d1 * E * Iyy / L ** 3 rst ( 5 , 3 ) = - 6.0d0 * E * Iyy / L ** 2 rst ( 9 , 3 ) = - rst ( 3 , 3 ) rst ( 11 , 3 ) = rst ( 5 , 3 ) rst ( 4 , 4 ) = G * Jxx / L rst ( 10 , 4 ) = - rst ( 4 , 4 ) rst ( 3 , 5 ) = rst ( 5 , 3 ) rst ( 5 , 5 ) = 4.0d0 * E * Iyy / L rst ( 9 , 5 ) = - rst ( 11 , 3 ) rst ( 11 , 5 ) = 2.0d0 * E * Iyy / L rst ( 2 , 6 ) = rst ( 6 , 2 ) rst ( 6 , 6 ) = 4.0d0 * E * Izz / L rst ( 8 , 6 ) = - rst ( 12 , 2 ) rst ( 12 , 6 ) = 2.0d0 * E * Izz / L rst ( 1 , 7 ) = rst ( 7 , 1 ) rst ( 7 , 7 ) = rst ( 1 , 1 ) rst ( 2 , 8 ) = rst ( 8 , 2 ) rst ( 6 , 8 ) = rst ( 8 , 6 ) rst ( 8 , 8 ) = rst ( 2 , 2 ) rst ( 12 , 8 ) = - rst ( 6 , 2 ) rst ( 3 , 9 ) = rst ( 9 , 3 ) rst ( 5 , 9 ) = rst ( 9 , 5 ) rst ( 9 , 9 ) = rst ( 3 , 3 ) rst ( 11 , 9 ) = - rst ( 5 , 3 ) rst ( 4 , 10 ) = rst ( 10 , 4 ) rst ( 10 , 10 ) = rst ( 4 , 4 ) rst ( 3 , 11 ) = rst ( 11 , 3 ) rst ( 5 , 11 ) = rst ( 11 , 5 ) rst ( 9 , 11 ) = rst ( 11 , 9 ) rst ( 11 , 11 ) = rst ( 5 , 5 ) rst ( 2 , 12 ) = rst ( 12 , 2 ) rst ( 6 , 12 ) = rst ( 12 , 6 ) rst ( 8 , 12 ) = rst ( 12 , 8 ) rst ( 12 , 12 ) = rst ( 6 , 6 ) ! Apply the transformation rst = matmul ( Tt , matmul ( rst , T )) end function ! ------------------------------------------------------------------------------ pure function b3d_mass_matrix ( this , rule ) result ( rst ) !! Computes the mass matrix for the element. class ( beam_element_3d ), intent ( in ) :: this !! The beam_element_3d object. integer ( int32 ), intent ( in ), optional :: rule !! The integration rule.  The rule must be one of the following: !! !! - MECH_ONE_POINT_INTEGRATION_RULE !! !! - MECH_TWO_POINT_INTEGRATION_RULE !! !! - MECH_THREE_POINT_INTEGRATION_RULE !! !! - MECH_FOUR_POINT_INTEGRATION_RULE !! !! The default integration rule is MECH_TWO_POINT_INTEGRATION_RULE. real ( real64 ), allocatable , dimension (:,:) :: rst !! The resulting matrix. ! Local Variables real ( real64 ) :: rho , L real ( real64 ), allocatable , dimension (:,:) :: T , Tt ! Initialization rho = this % material % density L = this % length () ! Compute the rotation matrix T = this % rotation_matrix () Tt = transpose ( T ) ! Compute the mass matrix allocate ( rst ( 12 , 12 ), source = 0.0d0 ) rst ( 1 , 1 ) = L * rho / 3.0d0 rst ( 7 , 1 ) = L * rho / 6.0d0 rst ( 2 , 2 ) = 1.3d1 * L * rho / 3.5d1 rst ( 6 , 2 ) = 1.1d1 * rho * L ** 2 / 2.1d2 rst ( 8 , 2 ) = 9.0d0 * L * rho / 7.0d1 rst ( 12 , 2 ) = - 1.3d1 * rho * L ** 2 / 4.2d2 rst ( 3 , 3 ) = 1.3d0 * rho * L / 3.5d1 rst ( 5 , 3 ) = - 1.1d0 * rho * L ** 2 / 2.1d2 rst ( 9 , 3 ) = 9.0d0 * rho * L / 7.0d1 rst ( 11 , 3 ) = 1.3d1 * rho * L ** 2 / 4.2d2 rst ( 4 , 4 ) = rho * L / 3.0d0 rst ( 10 , 4 ) = rho * L / 6.0d0 rst ( 3 , 5 ) = rst ( 5 , 3 ) rst ( 5 , 5 ) = rho * L ** 3 / 1.05d2 rst ( 9 , 5 ) = - 1.3d1 * rho * L ** 2 / 4.2d2 rst ( 11 , 5 ) = - rho * L ** 3 / 1.4d2 rst ( 2 , 6 ) = rst ( 6 , 2 ) rst ( 6 , 6 ) = rho * L ** 3 / 1.05d2 rst ( 8 , 6 ) = 1.3d1 * rho * L ** 2 / 4.2d2 rst ( 12 , 6 ) = - rho * L ** 3 / 1.4d2 rst ( 1 , 7 ) = rst ( 7 , 1 ) rst ( 7 , 7 ) = rst ( 1 , 1 ) rst ( 2 , 8 ) = rst ( 8 , 2 ) rst ( 6 , 8 ) = rst ( 8 , 6 ) rst ( 8 , 8 ) = rst ( 2 , 2 ) rst ( 12 , 8 ) = - 1.1d1 * rho * L ** 2 / 2.1d2 rst ( 3 , 9 ) = rst ( 9 , 3 ) rst ( 5 , 9 ) = rst ( 9 , 5 ) rst ( 9 , 9 ) = rst ( 3 , 3 ) rst ( 11 , 9 ) = 1.1d1 * rho * L ** 2 / 2.1d2 rst ( 4 , 10 ) = rst ( 10 , 4 ) rst ( 10 , 10 ) = rst ( 4 , 4 ) rst ( 3 , 11 ) = rst ( 11 , 3 ) rst ( 9 , 11 ) = rst ( 11 , 9 ) rst ( 11 , 11 ) = rst ( 5 , 5 ) rst ( 2 , 12 ) = rst ( 12 , 2 ) rst ( 6 , 12 ) = rst ( 12 , 6 ) rst ( 8 , 12 ) = rst ( 12 , 8 ) rst ( 12 , 12 ) = rst ( 6 , 6 ) ! Apply the transformation rst = matmul ( Tt , matmul ( rst , T )) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_structural.f90.html"},{"title":"dynamics_system_id.f90 – DYNAMICS","text":"Contents Modules dynamics_system_id Source Code dynamics_system_id.f90 Source Code module dynamics_system_id use iso_fortran_env use ferror use dynamics_error_handling use diffeq use fstats implicit none private public :: dynamic_system_measurement public :: model_information public :: siso_model_fit_least_squares public :: ode_integrator public :: regression_statistics public :: iteration_controls public :: lm_solver_options public :: convergence_info public :: iteration_update public :: constraint_equations interface subroutine constraint_equations ( xg , fg , xc , p , fc , args ) !! An interface to a set of routines for defining constraint !! equations to the fitting process. use iso_fortran_env , only : real64 real ( real64 ), intent ( in ), dimension (:) :: xg !! An N-element array containing the N independent variable !! values for the N differential equation solution points. real ( real64 ), intent ( in ), dimension (:) :: fg !! An N-element array containing the N differential equation !! solution points. real ( real64 ), intent ( in ), dimension (:) :: xc !! An M-element array containing the M independent variable !! values for the M constraint equations. real ( real64 ), intent ( in ), dimension (:) :: p !! An array containing the model parameters. real ( real64 ), intent ( out ), dimension (:) :: fc !! An M-element array where the values of the constraint !! equations should be written. class ( * ), intent ( inout ), optional :: args !! An optional argument that can be used to pass data in/out !! of this routine. end subroutine end interface type dynamic_system_measurement !! A container of a single measurement data set. real ( real64 ), allocatable , dimension (:) :: t !! The time points at which the measurements were taken. real ( real64 ), allocatable , dimension (:) :: output !! The output data. real ( real64 ), allocatable , dimension (:) :: input !! The input data. end type type model_information !! A container for model information. real ( real64 ), allocatable , dimension (:) :: model !! An array containing the model parameters. class ( base_interpolator ), pointer :: excitation !! An interpolation object allowing sampling of the excitation !! function. class ( * ), pointer :: user_info !! Information the user has passed along. end type type regression_information !! A container of information being shared with the regression function. integer ( int32 ), allocatable , dimension (:,:) :: start_stop !! An N-by-2 matrix containing the starting indices of each data !! set in the first column, and the ending indices of each data !! set in the second column. class ( ode_integrator ), pointer :: integrator !! A pointer to the ODE integrator. integer ( int32 ) :: solution_index !! The column index of the solution component to extract from the !! ODE solver output.  Do not account for the time vector (e.g. !! enter a value of 1 to extract the first solution component.) real ( real64 ), allocatable , dimension (:,:) :: initial_conditions !! The initial conditions array to pass to the ODE solver. real ( real64 ), allocatable , dimension (:) :: excitation_data !! An array of excitation data to pass to the ODE solver. procedure ( ode ), pointer , nopass :: ode_routine !! The routine, defined by the calling code, containing the ODE's !! to solve. logical :: uses_constraints !! True if constraint equations are to be utilized; else, false. procedure ( constraint_equations ), pointer , nopass :: constraints !! A pointer to the constraint equations routine. class ( * ), pointer :: user_info !! Information the user has passed along. end type interface siso_model_fit_least_squares module procedure :: siso_model_fit_least_squares_1 module procedure :: siso_model_fit_least_squares_2 end interface contains ! ------------------------------------------------------------------------------ subroutine siso_model_fit_least_squares_1 ( fcn , x , ic , p , integrator , ind , & maxp , minp , stats , alpha , controls , settings , info , status , cov , xc , yc , & constraints , weights , args , & err ) !! Attempts to fit a model of a single-intput, single-output (SISO) dynamic !! system by means of an iterative least-squares solver.  The algorithm !! computes the solution to the differential equations numerically, and !! compares the output to the known solution via a Levenberg-Marquardt !! least-squares solver. procedure ( ode ), pointer , intent ( in ) :: fcn !! The routine containing the ODE's being fit.  To communicate !! model parameters and other relevant information, an instance of the !! [[model_information]] type is passed to the optional argument of this !! routine.  Use the \"select type\" construct to access this information. class ( dynamic_system_measurement ), intent ( in ), dimension (:) :: x !! An M-element array of arrays with each array containing the measured !! input and output of the system being identified. real ( real64 ), intent ( in ), dimension (:) :: ic !! The initial condition vector for the equations in fcn. real ( real64 ), intent ( inout ), dimension (:) :: p !! An N-element array containing an initial guess at the parameters. !! On output, the computed model parameters. class ( ode_integrator ), intent ( inout ), optional , target :: integrator !! The integrator to use when solving the system equations.  If not !! supplied, the default integrator will be used.  The default !! integrator is a Runge-Kutta integrator (Dormand-Prince). integer ( int32 ), intent ( in ), optional :: ind !! The index of the ODE in fcn providing the output to fit.  If !! no value is supplied, a value of 1 will be utilized. real ( real64 ), intent ( in ), optional , dimension (:) :: maxp !! An optional N-element array that can be used as upper limits on the !! parameter values. If no upper limit is requested for a particular !! parameter, utilize a very large value. The internal default is to !! utilize huge() as a value. real ( real64 ), intent ( in ), optional , dimension (:) :: minp !! An optional N-element array that can be used as lower limits on the !! parameter values. If no lower limit is requested for a particalar !! parameter, utilize a very large magnitude, but negative, value. The !! internal default is to utilize -huge() as a value. type ( regression_statistics ), intent ( out ), optional , dimension (:) :: stats !! An optional N-element array that, if supplied, will be used to !! return statistics about the fit for each parameter. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals. The default value is 0.05 such that a 95% confidence !! interval is calculated. type ( iteration_controls ), intent ( in ), optional :: controls !! An optional input providing custom iteration controls. type ( lm_solver_options ), intent ( in ), optional :: settings !! An optional input providing custom settings for the solver. type ( convergence_info ), intent ( out ), optional :: info !! An optional output that can be used to gain information about the !! iterative solution and the nature of the convergence. procedure ( iteration_update ), pointer , intent ( in ), optional :: status !! An optional pointer to a routine that can be used to extract !! iteration information. real ( real64 ), intent ( out ), optional , dimension (:,:) :: cov !! An optional N-by-N matrix that, if supplied, will be used to return !! the covariance matrix. real ( real64 ), intent ( in ), optional , dimension (:) :: xc !! An optional NC-element array containing the values of the independent !! variable at which the constraint equations are defined. real ( real64 ), intent ( in ), optional , dimension (:) :: yc !! An optional NC-element array containing the constraint function !! values at xc. procedure ( constraint_equations ), pointer , optional :: constraints !! An optional input, that must be utilized with the xc and yc inputs, !! but allows for the implementation of additional constraints on the !! solution outside of the differential equations being fitted.  An !! example usage would be an additional set of quasi-static tests that !! could help identify a stiffness term, for instance.  Other uses of !! course can be imagined. real ( real64 ), intent ( in ), optional , dimension (:) :: weights !! An optional array containing weighting factors for every equation. class ( * ), intent ( inout ), optional , target :: args !! User-defined information to pass along to fcn.  These arguments, !! if supplied, will be passed through to fcn by means of the !! [[model_information]] type. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: i , i1 , i2 , n , ni , npts , nc , flag real ( real64 ), allocatable , dimension (:) :: t , f , ymod , resid class ( errors ), pointer :: errmgr type ( errors ), target :: deferr type ( runge_kutta_45 ), target :: default_ode_solver type ( regression_information ) :: addinfo procedure ( regression_function ), pointer :: fcnptr ! Initialization if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( xc ) . and . present ( yc ) . and . present ( constraints )) then nc = size ( xc ) if ( size ( yc ) /= nc ) then call report_array_size_error ( \"siso_model_fit_least_squares_1\" , & \"yc\" , nc , size ( yc ), errmgr ) return end if else nc = 0 end if n = size ( x ) fcnptr => nlsq_fun allocate ( addinfo % start_stop ( n , 2 ), stat = flag ) if ( flag /= 0 ) go to 100 i1 = 1 i2 = 0 npts = 0 do i = 1 , n ni = size ( x ( i )% t ) npts = npts + ni i2 = i2 + ni addinfo % start_stop ( i , 1 ) = i1 addinfo % start_stop ( i , 2 ) = i2 i1 = i2 + 1 end do npts = npts + nc allocate ( t ( npts ), f ( npts ), addinfo % excitation_data ( npts ), ymod ( npts ), & resid ( npts ), stat = flag ) if ( flag /= 0 ) go to 100 do i = 1 , n i1 = addinfo % start_stop ( i , 1 ) i2 = addinfo % start_stop ( i , 2 ) t ( i1 : i2 ) = x ( i )% t addinfo % excitation_data ( i1 : i2 ) = x ( i )% input f ( i1 : i2 ) = x ( i )% output end do if ( nc > 0 ) then i1 = i2 + 1 t ( i1 : npts ) = xc f ( i1 : npts ) = yc end if if ( present ( integrator )) then addinfo % integrator => integrator else addinfo % integrator => default_ode_solver end if allocate ( addinfo % initial_conditions ( 1 , size ( ic ))) addinfo % initial_conditions ( 1 ,:) = ic if ( present ( ind )) then addinfo % solution_index = ind else addinfo % solution_index = 1 end if addinfo % ode_routine => fcn if ( nc > 0 ) then addinfo % uses_constraints = . true . addinfo % constraints => constraints else addinfo % uses_constraints = . false . end if if ( present ( args )) addinfo % user_info => args ! Solve the system call nonlinear_least_squares ( fcnptr , t , f , p , ymod , resid , maxp = maxp , & minp = minp , stats = stats , alpha = alpha , controls = controls , & settings = settings , info = info , status = status , cov = cov , & args = addinfo , err = errmgr , weights = weights ) if ( errmgr % has_error_occurred ()) return ! End return ! Memory Error 100 continue call report_memory_error ( \"siso_model_fit_least_squares_1\" , flag , errmgr ) end subroutine ! -------------------- subroutine siso_model_fit_least_squares_2 ( fcn , x , ic , p , integrator , ind , & maxp , minp , stats , alpha , controls , settings , info , status , cov , xc , yc , & constraints , weights , args , & err ) !! Attempts to fit a model of a single-intput, single-output (SISO) dynamic !! system by means of an iterative least-squares solver.  The algorithm !! computes the solution to the differential equations numerically, and !! compares the output to the known solution via a Levenberg-Marquardt !! least-squares solver. procedure ( ode ), pointer , intent ( in ) :: fcn !! The routine containing the ODE's being fit.  To communicate !! model parameters and other relevant information, an instance of the !! [[model_information]] type is passed to the optional argument of this !! routine.  Use the \"select type\" construct to access this information. class ( dynamic_system_measurement ), intent ( in ), dimension (:) :: x !! An M-element array of arrays with each array containing the measured !! input and output of the system being identified. real ( real64 ), intent ( in ), dimension (:,:) :: ic !! An M-by-NEQN matrix of initial condition vectors for the NEQN !! equations in fcn, one set for each of the M sets of data in x. real ( real64 ), intent ( inout ), dimension (:) :: p !! An N-element array containing an initial guess at the parameters. !! On output, the computed model parameters. class ( ode_integrator ), intent ( inout ), optional , target :: integrator !! The integrator to use when solving the system equations.  If not !! supplied, the default integrator will be used.  The default !! integrator is a Runge-Kutta integrator (Dormand-Prince). integer ( int32 ), intent ( in ), optional :: ind !! The index of the ODE in fcn providing the output to fit.  If !! no value is supplied, a value of 1 will be utilized. real ( real64 ), intent ( in ), optional , dimension (:) :: maxp !! An optional N-element array that can be used as upper limits on the !! parameter values. If no upper limit is requested for a particular !! parameter, utilize a very large value. The internal default is to !! utilize huge() as a value. real ( real64 ), intent ( in ), optional , dimension (:) :: minp !! An optional N-element array that can be used as lower limits on the !! parameter values. If no lower limit is requested for a particalar !! parameter, utilize a very large magnitude, but negative, value. The !! internal default is to utilize -huge() as a value. type ( regression_statistics ), intent ( out ), optional , dimension (:) :: stats !! An optional N-element array that, if supplied, will be used to !! return statistics about the fit for each parameter. real ( real64 ), intent ( in ), optional :: alpha !! The significance level at which to evaluate the confidence !! intervals. The default value is 0.05 such that a 95% confidence !! interval is calculated. type ( iteration_controls ), intent ( in ), optional :: controls !! An optional input providing custom iteration controls. type ( lm_solver_options ), intent ( in ), optional :: settings !! An optional input providing custom settings for the solver. type ( convergence_info ), intent ( out ), optional :: info !! An optional output that can be used to gain information about the !! iterative solution and the nature of the convergence. procedure ( iteration_update ), pointer , intent ( in ), optional :: status !! An optional pointer to a routine that can be used to extract !! iteration information. real ( real64 ), intent ( out ), optional , dimension (:,:) :: cov !! An optional N-by-N matrix that, if supplied, will be used to return !! the covariance matrix. real ( real64 ), intent ( in ), optional , dimension (:) :: xc !! An optional NC-element array containing the values of the independent !! variable at which the constraint equations are defined. real ( real64 ), intent ( in ), optional , dimension (:) :: yc !! An optional NC-element array containing the constraint function !! values at xc. procedure ( constraint_equations ), pointer , optional :: constraints !! An optional input, that must be utilized with the xc and yc inputs, !! but allows for the implementation of additional constraints on the !! solution outside of the differential equations being fitted.  An !! example usage would be an additional set of quasi-static tests that !! could help identify a stiffness term, for instance.  Other uses of !! course can be imagined. real ( real64 ), intent ( in ), optional , dimension (:) :: weights !! An optional array containing weighting factors for every equation. class ( * ), intent ( inout ), optional , target :: args !! User-defined information to pass along to fcn.  These arguments, !! if supplied, will be passed through to fcn by means of the !! [[model_information]] type. class ( errors ), intent ( inout ), optional , target :: err !! An error handling object. ! Local Variables integer ( int32 ) :: i , i1 , i2 , n , ni , npts , nc , flag real ( real64 ), allocatable , dimension (:) :: t , f , ymod , resid class ( errors ), pointer :: errmgr type ( errors ), target :: deferr type ( runge_kutta_45 ), target :: default_ode_solver type ( regression_information ) :: addinfo procedure ( regression_function ), pointer :: fcnptr ! Initialization & Error Checking if ( present ( err )) then errmgr => err else errmgr => deferr end if if ( present ( xc ) . and . present ( yc ) . and . present ( constraints )) then nc = size ( xc ) if ( size ( yc ) /= nc ) then call report_array_size_error ( \"siso_model_fit_least_squares_2\" , & \"yc\" , nc , size ( yc ), errmgr ) return end if else nc = 0 end if n = size ( x ) fcnptr => nlsq_fun if ( size ( ic , 1 ) /= n ) then call report_matrix_size_error ( \"siso_model_fit_least_squares_2\" , \"ic\" , & n , size ( ic , 2 ), size ( ic , 1 ), size ( ic , 2 ), errmgr ) return end if allocate ( addinfo % start_stop ( n , 2 ), stat = flag ) if ( flag /= 0 ) go to 100 i1 = 1 i2 = 0 npts = 0 do i = 1 , n ni = size ( x ( i )% t ) npts = npts + ni i2 = i2 + ni addinfo % start_stop ( i , 1 ) = i1 addinfo % start_stop ( i , 2 ) = i2 i1 = i2 + 1 end do npts = npts + nc allocate ( t ( npts ), f ( npts ), addinfo % excitation_data ( npts ), ymod ( npts ), & resid ( npts ), stat = flag ) if ( flag /= 0 ) go to 100 do i = 1 , n i1 = addinfo % start_stop ( i , 1 ) i2 = addinfo % start_stop ( i , 2 ) t ( i1 : i2 ) = x ( i )% t addinfo % excitation_data ( i1 : i2 ) = x ( i )% input f ( i1 : i2 ) = x ( i )% output end do if ( nc > 0 ) then i1 = i2 + 1 t ( i1 : npts ) = xc f ( i1 : npts ) = yc end if if ( present ( integrator )) then addinfo % integrator => integrator else addinfo % integrator => default_ode_solver end if addinfo % initial_conditions = ic if ( present ( ind )) then addinfo % solution_index = ind else addinfo % solution_index = 1 end if addinfo % ode_routine => fcn if ( nc > 0 ) then addinfo % uses_constraints = . true . addinfo % constraints => constraints else addinfo % uses_constraints = . false . end if if ( present ( args )) addinfo % user_info => args ! Solve the system call nonlinear_least_squares ( fcnptr , t , f , p , ymod , resid , maxp = maxp , & minp = minp , stats = stats , alpha = alpha , controls = controls , & settings = settings , info = info , status = status , cov = cov , & args = addinfo , err = errmgr , weights = weights ) if ( errmgr % has_error_occurred ()) return ! End return ! Memory Error 100 continue call report_memory_error ( \"siso_model_fit_least_squares_2\" , flag , errmgr ) end subroutine ! -------------------- subroutine nlsq_fun ( t , p , f , check , args ) !! The routine called by the nonlinear least-squares solver from the !! siso_model_fit_least_squares routine. real ( real64 ), intent ( in ), dimension (:) :: t !! All of the time values from every data set supplied to the !! least-squares solver.  The args instance contains information on !! how to break apart this array. real ( real64 ), intent ( in ), dimension (:) :: p !! An array containing the model parameters. real ( real64 ), intent ( out ), dimension (:) :: f !! An array, the same size as t, where the function values will be !! written. logical , intent ( out ) :: check !! Set to true to force a stop to the iteration process; else, set !! to false to allow iterations to proceed normally. class ( * ), intent ( inout ), optional :: args !! A regression_information object containing information on how to !! arrange and solve the differential equations. ! Local Variables type ( model_information ) :: ode_info integer ( int32 ) :: i , n , ind , i1 , i2 integer ( int32 ), allocatable , dimension (:,:) :: limits real ( real64 ), allocatable , dimension (:) :: excitation , ici real ( real64 ), allocatable , dimension (:,:) :: sol , ic class ( ode_integrator ), pointer :: integrator type ( linear_interpolator ), target :: forcing_function type ( ode_container ) :: mdl type ( errors ) :: err logical :: uses_constraints procedure ( constraint_equations ), pointer :: constraints class ( * ), pointer :: user_info ! Get the supplied information select type ( args ) class is ( regression_information ) limits = args % start_stop integrator => args % integrator ind = args % solution_index + 1 ! +1 accounts for the time vector excitation = args % excitation_data ic = args % initial_conditions mdl % fcn => args % ode_routine if ( associated ( args % user_info )) then ode_info % user_info => args % user_info user_info => args % user_info end if uses_constraints = args % uses_constraints if ( uses_constraints ) constraints => args % constraints end select ! Initialization check = . false . n = size ( limits , 1 ) ode_info % model = p ! Cycle over each segment and compute the solution do i = 1 , n ! Get the locations within the array at which the relevant data is ! located i1 = limits ( i , 1 ) i2 = limits ( i , 2 ) ! Set up the interpolator for the forcing term call forcing_function % initialize ( t ( i1 : i2 ), excitation ( i1 : i2 ), err = err ) if ( err % has_error_occurred ()) go to 10 ode_info % excitation => forcing_function ! Solve the ODE's if ( size ( ic , 1 ) == 1 ) then ici = ic ( 1 ,:) else ici = ic ( i ,:) end if call integrator % clear_buffer () call integrator % solve ( mdl , t ( i1 : i2 ), ici , args = ode_info , err = err ) if ( err % has_error_occurred ()) go to 10 sol = integrator % get_solution () f ( i1 : i2 ) = sol (:, ind ) end do ! Constraints if ( uses_constraints ) then if ( associated ( user_info )) then call constraints ( t ( 1 : i2 ), f ( 1 : i2 ), t ( i2 + 1 :), p , f ( i2 + 1 :), & args = user_info ) else call constraints ( t ( 1 : i2 ), f ( 1 : i2 ), t ( i2 + 1 :), p , f ( i2 + 1 :)) end if end if ! End return ! Error Handling 10 continue check = . true . ! terminate iterations return end subroutine ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_system_id.f90.html"},{"title":"dynamics_vibrations.f90 – DYNAMICS","text":"Contents Modules dynamics_vibrations Source Code dynamics_vibrations.f90 Source Code module dynamics_vibrations use iso_fortran_env use peaks use ieee_arithmetic implicit none private public :: q_factor public :: estimate_bandwidth public :: logarithmic_decrement public :: damping_from_log_decrement public :: find_free_response_properties public :: rise_time public :: find_settling_amplitude public :: damping_from_fractional_overshoot public :: evaluate_step_response contains ! ------------------------------------------------------------------------------ pure elemental function q_factor ( zeta ) result ( rst ) !! Estimates the Q-factor for a vibratory system.  The Q-factor is computed !! Q = \\frac{1}{2 \\zeta}. real ( real64 ), intent ( in ) :: zeta !! The damping ratio. real ( real64 ) :: rst !! The Q-factor. ! Process rst = 1.0d0 / ( 2.0d0 * zeta ) end function ! ------------------------------------------------------------------------------ pure elemental function estimate_bandwidth ( fn , zeta ) result ( rst ) !! Estimates the bandwidth of the resonant mode of a vibratory system. !! The bandwidth is the width of the range of frequencies for which the !! energy is at least half its peak value and is computed as !! \\Delta f = \\frac{f_n}{Q}. real ( real64 ), intent ( in ) :: fn !! The resonant frequency.  The units are not important; however, !! the units of the output will be the same as the units of this !! parameter. real ( real64 ), intent ( in ) :: zeta !! The damping ratio. real ( real64 ) :: rst !! The bandwidth. ! Process rst = fn / q_factor ( zeta ) end function ! ------------------------------------------------------------------------------ pure elemental function logarithmic_decrement ( x1 , x2 , n ) result ( rst ) !! Computes the logarithmic decrement given the value of two  successive !! peaks in the time history of the free vibratory response of the system. !! The logarithmic decrement is calculated as follows. !! !!  \\delta = \\frac{1}{N} \\ln \\left( \\frac{x(t)}{x(t + N T)} \\right) = !! \\frac{1}{N} \\ln \\left( \\frac{x_1}{x_2} \\right)  real ( real64 ), intent ( in ) :: x1 !! The amplitude of the first peak. real ( real64 ), intent ( in ) :: x2 !! The amplitude of the second peak that occurs N periods after the !! first. integer ( int32 ), intent ( in ) :: n !! The number of periods of oscillation seperating the two peaks. real ( real64 ) :: rst !! The logarithmic decrement \\delta. ! Process rst = ( 1.0d0 / n ) * log ( x1 / x2 ) end function ! ------------------------------------------------------------------------------ pure elemental function damping_from_log_decrement ( delta ) result ( rst ) !! Computes the damping ratio from the logarithmic decrement \\delta. !! The damping ratio is related to the logarithmic decrement by the !! following relationship. !! !!  \\zeta = \\frac{\\delta}{\\sqrt{4 \\pi&#94;2 + \\delta&#94;2}}  real ( real64 ), intent ( in ) :: delta !! The logarithmic decrement. real ( real64 ) :: rst !! The damping ratio. ! Process real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) rst = delta / sqrt ( 4.0d0 * pi ** 2 + delta ** 2 ) end function ! ------------------------------------------------------------------------------ subroutine find_free_response_properties ( t , x , delta , fn , x1 , x2 , t1 , t2 , s , n ) !! Given a free-response time history, this routine attempts to find the !! logarithmic decrement and resonant frequency of a vibratory system. The !! logarithmic decrement is estimated by finding successive peaks by !! means of peak detection. real ( real64 ), intent ( in ), dimension (:) :: t !! An N-element array containing the values in time real ( real64 ), intent ( in ), dimension (:) :: x !! An N-element array containing the response sampled at the time points !! given in t. real ( real64 ), intent ( out ) :: delta !! The logarithmic decrement estimate.  If sufficient peaks cannot be !! located, the routine returns NaN. real ( real64 ), intent ( out ) :: fn !! The damped resonant frequency in units of Hz, assuming that the !! time values are in seconds.  If the time units are not in seconds, !! the units will be cycle/unit time with unit time being the units !! in which t is supplied.  If sufficient peaks cannot be located, the !! routine returns NaN. real ( real64 ), intent ( out ), optional :: x1 !! An optional parameter that, if provided, allows for the routine to !! return the amplitude of the first peak.  If sufficient peaks cannot !! be located, the routine returns NaN. real ( real64 ), intent ( out ), optional :: x2 !! An optional parameter that, if provided, allows for the routine to !! return the amplitude of the second peak.  If sufficient peaks cannot !! be located, the routine returns NaN. real ( real64 ), intent ( out ), optional :: t1 !! An optional parameter that, if provided, allows for the routine to !! return the time at which the first peak was located.  If sufficient !! peaks cannot be located, the routine returns NaN. real ( real64 ), intent ( out ), optional :: t2 !! An optional parameter that, if provided, allows for the routine to !! return the time at which the second peak was located.  If sufficient !! peaks cannot be located, the routine returns NaN. real ( real64 ), intent ( in ), optional :: s !! An optional input that, if provided, allows for control of the !! sensitivity of the peak detection algorithm.  The default is 0.1% !! of the peak-peak amplitude of the signal. integer ( int32 ), intent ( in ), optional :: n !! An optional input that, if provided, determines the number of !! periods to allow between peak selection for the logarithmic !! decrement calculation.  The default is 1. ! Local Variables integer ( int32 ) :: np , i1 , i2 , j2 real ( real64 ) :: xmax , xmin , dx , x1p , x2p , t1p , t2p , nan integer ( int32 ), allocatable , dimension (:) :: maxind , minind real ( real64 ), allocatable , dimension (:) :: maxvals , minvals ! Determine a suitable sensitivity to peak detection if ( present ( s )) then dx = s else xmax = maxval ( x ) xmin = minval ( x ) dx = 1.0d-3 * ( xmax - xmin ) end if ! Peak Count if ( present ( n )) then np = n else np = 1 end if ! Additional initialization nan = ieee_value ( nan , IEEE_QUIET_NAN ) delta = nan fn = nan t1p = nan t2p = nan x1p = nan x2p = nan ! Locate peaks call peak_detect ( x , dx , maxind , maxvals , minind , minvals ) if ( size ( maxind ) < 2 ) then ! Return NaN's as we couldn't find enough peaks go to 10 end if i1 = maxind ( 1 ) np = min ( np , size ( maxind ) - 1 ) j2 = np + 1 i2 = maxind ( j2 ) t1p = t ( i1 ) t2p = t ( i2 ) x1p = x ( i1 ) x2p = x ( i2 ) delta = logarithmic_decrement ( x1p , x2p , np ) fn = np / ( t2p - t1p ) ! End 10 continue if ( present ( x1 )) x1 = x1p if ( present ( x2 )) x2 = x2p if ( present ( t1 )) t1 = t1p if ( present ( t2 )) t2 = t2p end subroutine ! ------------------------------------------------------------------------------ pure elemental function rise_time ( wn , zeta ) result ( rst ) !! Computes the rise time for an underdamped, second-order system.  The !! rise time is the time it takes for the system response to go from 0% !! to 100% of its final value and is given by the following relationship. !! !!  t_r = \\frac{1}{\\omega_d} \\left( \\pi - !! \\arctan \\frac{\\sqrt{1 - zeta&#94;2}}{\\zeta} \\right)  real ( real64 ), intent ( in ) :: wn !! The resonant frequency of the system, in rad/s. real ( real64 ), intent ( in ) :: zeta !! The damping ratio of the system.  This value must be less than 1 !! as this relationship is only valid for an underdamped system. real ( real64 ) :: rst !! The rise time, in units of seconds. ! Local Variables real ( real64 ) :: arg ! Parameters real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) ! Process arg = sqrt ( 1.0d0 - zeta ** 2 ) rst = ( 1.0d0 / ( wn * arg )) * ( pi * atan ( arg / zeta )) end function ! ------------------------------------------------------------------------------ pure function find_settling_amplitude ( x ) result ( rst ) use fftpack , only : rfft !! Estimates the settling amplitude for a step response. real ( real64 ), intent ( in ), dimension (:) :: x !! The step response of the system. real ( real64 ) :: rst !! The settling amplitude of the step response. ! Local Variables real ( real64 ), allocatable , dimension (:) :: xfft ! Compute the FFT of X and normalize xfft = rfft ( x ) / size ( x ) ! We only need the DC component rst = xfft ( 1 ) end function ! ------------------------------------------------------------------------------ pure function damping_from_fractional_overshoot ( x ) result ( rst ) !! Employs the method of fractional overshoot to estimate the damping ratio !! from the response of a system to a step input.  This method is useful !! for cases where the damping ratio is between approximately 0.5 to 0.8. !! In such range, the logarithmic decrement approach becomes less precise. !! !! The fractional overshoot method locates the amplitude of the first !! peak of oscillation (x_p) and the settling amplitude (x_f), and !! the estimates the damping ratio as follows. !! !!  s = \\frac{x_p - x_f}{x_f}  !! !!  \\zeta = \\frac{1}{\\sqrt{1 + \\left( \\frac{\\pi}{\\ln{s}} \\right)&#94;2}}  real ( real64 ), intent ( in ), dimension (:) :: x !! The step response of the system. real ( real64 ) :: rst !! The estimated damping ratio. ! Parameters real ( real64 ), parameter :: pi = 2.0d0 * acos ( 0.0d0 ) ! Local Variables real ( real64 ) :: xp , xf , s ! Locate the amplitude terms xp = maxval ( abs ( x )) xf = abs ( find_settling_amplitude ( x )) s = ( xp - xf ) / xf ! Compute the damping ratio rst = 1.0d0 / sqrt ( 1.0d0 + ( pi / log ( s )) ** 2 ) end function ! ------------------------------------------------------------------------------ pure elemental function evaluate_step_response ( wn , zeta , xs , t ) result ( rst ) !! Evaluates the response of an underdamped single-degree-of-freedom, !! linear system to a step function of amplitude X_s. !! !! The step function response of an underdamped linear SDOF system is given !! as follows. !! !!  \\ddot{x} + 2 \\zeta \\omega_n \\dot{x} + \\omega_n&#94;2 x = \\frac{F(t)}{m}  !! !!  \\frac{x(t)}{X_s} = 1 - e&#94;{-\\zeta \\omega_n t} \\left( !! \\frac{\\zeta \\omega_n}{\\omega_d} \\sin{\\omega_d t} + \\cos{\\omega_d t} !! \\right)  !! !! where, !! !!  \\omega_d = \\omega_n \\sqrt{1 - \\zeta&#94;2}  !! !! and !! !!  X_s = \\frac{F}{k}  real ( real64 ), intent ( in ) :: wn !! The resonant frequency, in rad/s. real ( real64 ), intent ( in ) :: zeta !! The damping ratio. real ( real64 ), intent ( in ) :: xs !! The amplitude of the step input. real ( real64 ), intent ( in ) :: t !! The point in time at which to evaluate the response (units = s). real ( real64 ) :: rst !! The step response. ! Local Variables real ( real64 ) :: wd , A ! Process wd = wn * sqrt ( 1.0d0 - zeta ** 2 ) A = zeta * wn / wd rst = xs * ( 1.0d0 - exp ( - zeta * wn * t ) * ( A * sin ( wd * t ) + cos ( wd * t ))) end function ! ------------------------------------------------------------------------------ end module","tags":"","loc":"sourcefile\\dynamics_vibrations.f90.html"}]}